{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.jpeg","path":"images/avatar.jpeg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"bcc503b08fdf89b27278034a5c7b88b03bc9abc7","modified":1561009495847},{"_id":"themes/next/.DS_Store","hash":"1f0f4685052ffb44a8e1219bf922bedc2e0015d7","modified":1561011250116},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1560998676350},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1560998676351},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1560998676351},{"_id":"themes/next/.gitignore","hash":"32ea93f21d8693d5d8fa4eef1c51a21ad0670047","modified":1560998676352},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1560998676352},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1560998676352},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1560998676353},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1560998676353},{"_id":"themes/next/.travis.yml","hash":"c42d9608c8c7fe90de7b1581a8dc3886e90c179e","modified":1560998676353},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1560998676353},{"_id":"themes/next/README.en.md","hash":"32d6cdfec1447f54aae1d7f1365ce6733dfcec8f","modified":1560998676354},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1560998676354},{"_id":"themes/next/_config.yml","hash":"9423b5ae43e4892b6401d19de97b0be69b63682e","modified":1561012306790},{"_id":"themes/next/bower.json","hash":"7d7938f9da896fe710aa0e9120140e528bf058df","modified":1560998676354},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1560998676355},{"_id":"themes/next/package.json","hash":"193dad6f59a588908fac082cc46fe067dac1b84d","modified":1560998676377},{"_id":"source/_posts/http cache.md","hash":"18928537efdef3dc87e1bc8b9036361f42390235","modified":1561007686464},{"_id":"source/_posts/proxy.md","hash":"3b7c8c889d773f597944887712685f4128a7f54b","modified":1561007682849},{"_id":"source/_posts/关于tcp.md","hash":"99adfeba14937afa81906926a8ab6d54a4b1d3ff","modified":1561006652675},{"_id":"source/_posts/前端框架的趋势-hook入门.md","hash":"2e4093baa7640173e78c1da841e7aba54009ee3f","modified":1561001195518},{"_id":"source/_posts/常见网络攻击.md","hash":"cde4d2f701b70b2079128d0d5dedf4ca98d754d4","modified":1561000363096},{"_id":"source/_posts/手写async函数.md","hash":"ef01689a26324faaaad91a7f42f707cdfd2db2bb","modified":1561007112895},{"_id":"source/_posts/网页布局相关.md","hash":"c963df31964d26ff8a3083db5e70cc0be07fc93a","modified":1561000134963},{"_id":"source/_posts/防抖和节流.md","hash":"6f049731ddd3db8e007edf89e1a97ae7c9723609","modified":1560999781608},{"_id":"source/_posts/随笔.md","hash":"342a85f2366780373e63fbe5e7aee3aa0feb6a58","modified":1560999870744},{"_id":"source/about/index.md","hash":"f91db09921253501be0b34b4d71bfa5d39148814","modified":1561012386629},{"_id":"themes/next/.git/HEAD","hash":"75173e2dd18a6221ff84742ff53d01ac5c6e04b0","modified":1560998676345},{"_id":"themes/next/.git/config","hash":"510faaf0899b89e8a0a0a7ebeff0d4b0aa5ad38f","modified":1560998649239},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1560998644745},{"_id":"themes/next/.git/index","hash":"ac09cef98e9c21fa8acc5c044fa365625321b919","modified":1561008159563},{"_id":"themes/next/.git/packed-refs","hash":"3bb2e8e3fad44742d3e3bfadfb0b4d791fe9fe9e","modified":1560998676344},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1560998676351},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"b56c01cdfc6ee7ffea8a8a9fa149263f368caef6","modified":1560998676351},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"37bd0ec1d655c601946fc5f5ac2fe8ed1e529b77","modified":1560998676351},{"_id":"themes/next/languages/de.yml","hash":"306db8c865630f32c6b6260ade9d3209fbec8011","modified":1560998676355},{"_id":"themes/next/languages/default.yml","hash":"4cc6aeb1ac09a58330e494c8771773758ab354af","modified":1560998676355},{"_id":"themes/next/languages/en.yml","hash":"e7def07a709ef55684490b700a06998c67f35f39","modified":1560998676355},{"_id":"themes/next/languages/fr-FR.yml","hash":"24180322c83587a153cea110e74e96eacc3355ad","modified":1560998676355},{"_id":"themes/next/languages/id.yml","hash":"2835ea80dadf093fcf47edd957680973f1fb6b85","modified":1560998676355},{"_id":"themes/next/languages/ja.yml","hash":"1c3a05ab80a6f8be63268b66da6f19da7aa2c638","modified":1560998676356},{"_id":"themes/next/languages/ko.yml","hash":"be150543379150f78329815af427bf152c0e9431","modified":1560998676356},{"_id":"themes/next/languages/pt-BR.yml","hash":"958e49571818a34fdf4af3232a07a024050f8f4e","modified":1560998676356},{"_id":"themes/next/languages/pt.yml","hash":"36c8f60dacbe5d27d84d0e0d6974d7679f928da0","modified":1560998676356},{"_id":"themes/next/languages/ru.yml","hash":"1549a7c2fe23caa7cbedcd0aa2b77c46e57caf27","modified":1560998676356},{"_id":"themes/next/languages/zh-Hans.yml","hash":"f3ccfcdde7af893ff2ff2d3201b0ab492ccba9b1","modified":1561012095630},{"_id":"themes/next/languages/zh-hk.yml","hash":"1c917997413bf566cb79e0975789f3c9c9128ccd","modified":1560998676357},{"_id":"themes/next/languages/zh-tw.yml","hash":"0b2c18aa76570364003c8d1cd429fa158ae89022","modified":1560998676357},{"_id":"themes/next/layout/_layout.swig","hash":"06b1eab2e00273e0b94bd32dc682bd92c1e0a747","modified":1560998676358},{"_id":"themes/next/layout/archive.swig","hash":"383f64deab105724fd5512371963bd9e9aafbffd","modified":1560998676375},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1560998676375},{"_id":"themes/next/layout/index.swig","hash":"03e8a2cda03bad42ac0cb827025eb81f95d496a2","modified":1560998676375},{"_id":"themes/next/layout/page.swig","hash":"37c874cd720acf0eda8d26e063278f2b6ae8d3a6","modified":1560998676376},{"_id":"themes/next/layout/post.swig","hash":"2d5f8d7f0a96b611e2d5a5e4d111fc17726a990f","modified":1560998676376},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1560998676376},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1560998676376},{"_id":"themes/next/scripts/merge-configs.js","hash":"13c8b3a2d9fce06c2488820d9248d190c8100e0a","modified":1560998676377},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1560998676378},{"_id":"themes/next/source/.DS_Store","hash":"07d7d50412def0f65603d25fadeb1e1997578520","modified":1561011686117},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1560998676455},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1560998676455},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1560998676456},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560998676405},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1560998644746},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1560998644745},{"_id":"themes/next/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1560998644747},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1560998644747},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1560998644747},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1560998644746},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1560998644748},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1560998644746},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1560998644747},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1560998644747},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1560998644748},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1560998644745},{"_id":"themes/next/.git/logs/HEAD","hash":"82abd5ffb4e116c13fcbb28269040d13679c6502","modified":1560998676346},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1560998676358},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1560998676358},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1560998676359},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"53d4f83b2b7fb4387dfc9fe81519abd56fbce4ae","modified":1560998676359},{"_id":"themes/next/layout/_macro/post.swig","hash":"911363776867d9523a3e322cdf591d49cd166403","modified":1560998676359},{"_id":"themes/next/layout/_macro/reward.swig","hash":"5d5f70deb6074cb4dd0438463e14ccf89213c282","modified":1560998676359},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"faa7886ccf986890cd776f4e9d70cb89fe9fda5f","modified":1560998676360},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1560998676360},{"_id":"themes/next/layout/_partials/comments.swig","hash":"ce7094ee05878161e7568a6dfae5b56ff3fbd6e1","modified":1560998676360},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1560998676360},{"_id":"themes/next/layout/_partials/head.swig","hash":"1f14d3f494b2dbbcee802fd6f6d1abd5b7e2304c","modified":1560998676360},{"_id":"themes/next/layout/_partials/header.swig","hash":"a1ffbb691dfad3eaf2832a11766e58a179003b8b","modified":1560998676361},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1560998676361},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1560998676362},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1560998676362},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1560998676364},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1560998676364},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9baf90f7c40b3b10f288e9268c3191e895890cea","modified":1560998676366},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1560998676371},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1560998676371},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1560998676372},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1560998676372},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1560998676372},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1560998676373},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1560998676378},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1560998676378},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1560998676378},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1560998676379},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1560998676379},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1560998676379},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1560998676379},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1560998676379},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1560998676380},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1560998676405},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1560998676405},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1560998676406},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1560998676406},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1560998676406},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1560998676407},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1560998676407},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1560998676407},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1560998676407},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1560998676408},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1560998676408},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1560998676408},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1560998676408},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1560998676409},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1560998676409},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560998676365},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560998676365},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560998676398},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560998676398},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560998676398},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560998676404},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1560998676405},{"_id":"themes/next/source/images/avatar.jpeg","hash":"fbe93a17dc065717f44739b0a040fda4d916cd2b","modified":1561011245517},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1560998676361},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1560998676361},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1560998676362},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1560998676362},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1560998676362},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1560998676363},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1560998676363},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1560998676363},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1560998676364},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1560998676365},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1560998676365},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1560998676366},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1560998676366},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1560998676367},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1560998676367},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1560998676367},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1560998676368},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1560998676368},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"3358d11b9a26185a2d36c96049e4340e701646e4","modified":1560998676368},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1560998676368},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1560998676369},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1560998676369},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1560998676369},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1560998676369},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1560998676370},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1560998676370},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1560998676370},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"ee63aa2e49507b884a2d56778479cf01c723d751","modified":1560998676370},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1560998676371},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1560998676371},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1560998676374},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1560998676374},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1560998676374},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1560998676374},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1560998676397},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1560998676398},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"eaedfaf06dae94ba77a8f4893e2e434bf8859bac","modified":1560998676398},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1560998676398},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"49b5210fa62d6cbc6a98f57d89d5067a06ab3561","modified":1560998676404},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1560998676404},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"cfee25d790e4f9b7d57f0dc7e2ea9c1649f08f11","modified":1560998676404},{"_id":"themes/next/source/css/_variables/base.styl","hash":"d477196c5699c8261b08e993a77ef67054d86166","modified":1560998676405},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1560998676409},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1560998676410},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"6117f97b4984b8e33f21c726132da64ba678e4ed","modified":1560998676410},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1560998676410},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1560998676410},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1560998676411},{"_id":"themes/next/source/js/src/motion.js","hash":"dc0365b2fb315a8b43d3ef19b59d3a82a366fcc1","modified":1560998676411},{"_id":"themes/next/source/js/src/post-details.js","hash":"0693695a9512641daff63d99da772625a058ab18","modified":1560998676411},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1560998676412},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1560998676412},{"_id":"themes/next/source/js/src/utils.js","hash":"2917c39c75b14b6dab7e1c46ab4d87b4df9fcd5d","modified":1560998676412},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1560998676416},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1560998676419},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"7fd2f3e2773555392ef40df40cae3bedb884f17a","modified":1560998676419},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1560998676420},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1560998676420},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1560998676424},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1560998676424},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1560998676425},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1560998676425},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1560998676426},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1560998676426},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1560998676426},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1560998676426},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1560998676427},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1560998676439},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1560998676440},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1560998676440},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1560998676441},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1560998676441},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1560998676441},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1560998676441},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1560998676442},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1560998676442},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1560998676442},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1560998676442},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1560998676443},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1560998676443},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1560998676443},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1560998676443},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1560998676444},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1560998676444},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1560998676444},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1560998676444},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1560998676444},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1560998676445},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1560998676445},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1560998676446},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1560998676446},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1560998676451},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1560998676451},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1560998676454},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1560998676454},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1560998676455},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1560998676440},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1560998676345},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1560998676373},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1560998676373},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"d026c8489f66ab6c12ad04bd37f1d5b6f2f3f0d1","modified":1560998676381},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1560998676381},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1560998676381},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1560998676381},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1560998676381},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1560998676386},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1560998676393},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1560998676396},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"2915df7152ea095a6290ef69157fd67669e0e793","modified":1560998676396},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1560998676396},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"86b6fd7f1b1be3ae98f8af6b23a6b1299c670ce9","modified":1560998676396},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1560998676397},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1560998676397},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1560998676397},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"bc8c388553bbcf95897459a466ba35bffd5ec5f0","modified":1560998676398},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1560998676399},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1560998676399},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1560998676399},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1560998676399},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1560998676399},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1560998676400},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1560998676400},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1560998676401},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1560998676402},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1560998676402},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1560998676402},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1560998676402},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1560998676403},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1560998676403},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1560998676403},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1560998676403},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e3e23751d4ad24e8714b425d768cf68e37de7ded","modified":1560998676403},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1560998676403},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1560998676411},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1560998676414},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1560998676415},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1560998676415},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1560998676420},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1560998676421},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1560998676421},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1560998676421},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1560998676421},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1560998676422},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1560998676423},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1560998676423},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1560998676424},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1560998676425},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1560998676426},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1560998676427},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1560998676427},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1560998676428},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1560998676450},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1560998676451},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1560998676414},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1560998676438},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1560998676439},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1560998676454},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"2c6da5e8510667c266c2da3c8fc843ff8f043d3d","modified":1560998676345},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1560998676382},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1560998676382},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1560998676382},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1560998676383},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1560998676383},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1560998676383},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1560998676383},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"740d37f428b8f4574a76fc95cc25e50e0565f45e","modified":1560998676384},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1560998676384},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1560998676384},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1560998676385},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1560998676385},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1560998676385},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1560998676385},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1560998676386},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1560998676387},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1560998676387},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1560998676387},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"88c7d75646b66b168213190ee4cd874609afd5e3","modified":1560998676387},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1560998676388},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"ed88c8b51d0517759c777e71a6bfbe2907bcd994","modified":1560998676388},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1560998676388},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ee554b1031ef0070a5916477939021800e3c9d27","modified":1560998676388},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1560998676389},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1560998676389},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1560998676389},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1560998676389},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"08a500b2984f109b751f3697ca33172d1340591a","modified":1560998676390},{"_id":"themes/next/source/css/_common/components/post/post-wordcount.styl","hash":"4fda5d38c6c8d910e3bf5c74a48a8d4a3f3dc73d","modified":1560998676390},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"51eca243220cf57133a4becae9b78514bcfdc723","modified":1560998676390},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"65a64d5662637b66e2f039a5f58217afe7a6e800","modified":1560998676391},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1560998676391},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"5f6ea57aabfa30a437059bf8352f1ad829dbd4ff","modified":1560998676391},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1560998676391},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1560998676391},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1560998676392},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"77c92a449ce84d558d26d052681f2e0dd77c70c9","modified":1560998676392},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1560998676392},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"57d2c8a060f5e4e1a0aef9aae11a0016cf7ac5ba","modified":1560998676392},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1560998676392},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1560998676393},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1560998676393},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1560998676393},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1560998676393},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1560998676393},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"45df0cf4c97b47e05573bcd41028ee50f3fdf432","modified":1560998676394},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1560998676394},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1560998676394},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1560998676394},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1560998676394},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1560998676394},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1560998676395},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1560998676395},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1560998676395},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1560998676395},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1560998676395},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"aeff0e6e23725e8baea27c890ccbbf466024f767","modified":1560998676396},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1560998676400},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1560998676401},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1560998676402},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1560998676413},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1560998676413},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1560998676413},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1560998676414},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1560998676422},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1560998676422},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1560998676422},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1560998676422},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1560998676423},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1560998676423},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1560998676429},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1560998676431},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1560998676437},{"_id":"themes/next/.git/objects/pack/pack-cab418463cd893872a0ff15ce8d9047332b9e5c1.idx","hash":"a6b07e47b81e230c17ee052afe99cb97b688bb35","modified":1560998676335},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1560998676419},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1560998676450},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1560998676435},{"_id":"themes/next/.git/objects/pack/pack-cab418463cd893872a0ff15ce8d9047332b9e5c1.pack","hash":"8ae43a23dddc9895f4c16760c5d4b12614ec6226","modified":1560998676328}],"Category":[],"Data":[],"Page":[{"title":"个人简历","date":"2019-06-20T06:31:08.000Z","tag":"about","_content":"\n\n# 联系方式\n\n- 手机：18551809643\n- Email：gk.jing@gmail.com\n- 微信号：jgk15110625817\n\n---\n\n# 个人信息\n\n - 景国凯/男/1992 \n - 本科/山西师范大学电子信息工程 \n - 工作年限：4年(15届毕业)\n - Github：[https://github.com/jinggk](https://github.com/jinggk)\n\n - 期望职位：资深Web前端工程师\n - 期望薪资：税前月薪20k~25k，特别喜欢的公司可例外\n - 期望城市：南京\n\n---\n\n# 工作经历\n\n<!-- ## 南京贝湾教育科技有限公司 （ 2017年9月 ~ 现在 ）\n\n### 备考训练营\n备考训练营是针对在校大学生备考四六级考试的一个项目，具体的实现包含了native + webview的结合，个人主要负责webview部分的开发，以及个别与native的沟通协作，具体如下：\n1.0版本的所有webview部分开发\n2.0版本的部分webview开发\n3.0版本的小部分webview开发\n\n(1).除了一些每一版本中稳定的迭代，最大挑战就是运营每一期活动的经常变动，因此在2.0结束到3.0期间尝试了类似于飞冰的GUI工具，起名为夸父项目，但是由于新项目的需求以及后端人员不能够有效投入，还有一些额外的原因吧，导致这个项目被搁置了（只出了一个初版），不过在3.0的开发中已经实现了代码中配置化开发，这样只要不是特别大的改动在4.0基本可以实现内部配置化开发，因此假以时日夸父还是可以做起来。\n\n(2).夸父项目功能简介：\n1.页面的自动化配置，\n2.定时任务的设置，\n3.A/B测试的配置，\n4.微信授权，内部预览功能的设置\n对了，夸父通过iframe的方式实现实时预览，因此也算是所见即所得的GUI工具。\n\n夸父项目的搁置也让我明白了一个道理，步子不能迈的太大，容易做不起来，加入开始的时候就先实现代码中的组件配置化，可能现在就已经投入使用了。\n\n(3).另外就是和移动端的配合，因为APP的一些历史原因吧，我接受做webview的时候，使用的交互是前端使用href跳转一个xxx.native.xxx的私有路由，移动端进行拦截实现的，这个有个很大的问题，假如用户没有及时更新(移动端的痛点，热更新不好搞，尤其是ios端)，webview统一上去后，用户其实点击的时候没有任何响应，所以当时我了解了这个情况后感觉很惊讶，怎么会不考虑这个问题，而且IOS和Android端的路由表配置的相当乱~(历史原因吧),哪些在用哪些不用都不清楚，因此都不敢删除，所以我当时想了一个方案就是虽然交互方式改不了，但是可以改协议的方式，把私有协议改为http的，这样的话http默认画一个提示用户去升级的页面，判断IOS和android分别到各自的商店去下载新版app，这样，即时用户没更新点了之后也知道发生了什么事情，提升了用户体验吧；\n\n(4).还有一个问题就是webview覆盖跳转的问题，我们都知道移动端webview load了一个url后，如果再利用href跳转默认会出现2层history栈，因此webview在左上角的返回旁边多了一个关闭按钮，用户点了不会返回之前的webview页面，而是直接到原生页面去了，当时想了一个方案就是在query中带一个特殊的参数，移动端一旦监听到这个额外的参数，就重新开一个webview来load这个新的url，这样不会出现关闭按钮，同时还能正常返回上一个页面，当然这种情况是要看场景使用的，因为带这个参数的返回下，上一个页面不会刷新，有刷新需求的要想办法，网上很多就不说了。\n\n等等。\n\n\n### 备考下的小程序项目 \n参与了5个小程序的开发(扇贝精听，扇贝长难句，扇贝精品课，扇贝发音私教，扇贝四六级查分助手)\n\n1.小程序的开发，就正常开发和迭代，另外针对小程序我带领团队一起开发了nuwa(女娲)监控系统，我们在webview的错误监控用了sentry，但是小程序没法用，开始的时候我们尝试了fundebug(试用了不到一个月就下了)，但是他们是按beat的次数来收费的，感觉也就那样，于是大家商量一起自己实现一个基于小程序的监控系统，大概2个迭代的时间(半个月)，就上线了第一版，今年3月份过来我们整改wxcommon的时候迭代了第二版，现在已经很稳定了，并且已经推向了全公司的各个部门使用，得到了一致的好评，这个项目sdk端的核心就是重写了小程序的一些核心生命周期的方法来抓取一些错误，同时对于请求的错误，我们重新了wx.request来实现的，遇到的最大的问题其实到现在还是没解决掉，只能通过约束来实现，问题是因为我们会把一些生命周期搞成异步的，async onLoad(){}，这样会有个问题，没有地方可以catch这个异步，它的运行在小程序的底层，所以这个地方我们只能是约束在内部await的时候一定要单独catch，然后我们的sdk会提供一个单独的handleError，允许丢一个错误进来进行上报，只能这样，暂时我也没想到好的办法。\n\n2.带领我们的团队封装了wxcommon这个lib，里面有一些各个业务组使用的util，比如支付，生成海报，版本检测等等，nuwa也在这个里面，还有一个就是对audiomanager的处理，因为微信原生的audiomanager经常出问题，做过小程序对于微信自己的坑应该都了解，经常有bug，并且在devtool，android和ios的表现形式都不一样，因此我们自己二次封装了这个东西，并且在内部屏蔽了对不同平台的处理，使其对外表现形式尽量一致，等等\n\n\n### libs开发\n\n1.wxcommon的迭代升级，修改打包方式，文档产出等\n2.generator更新，一个生成前端项目的cli工具\n3.部分exam-utils开发，所有备考组libs的集合\n4.公司所有前端的eslint规范和文档产出\n5.等等一些小pr\n\n心得：经常用的lib一定要迭代和维护，文档一定要配套更新，\n更新一定要及时通知到所有的前端开发，否则会出现不停的重复造轮子，真的没必要，很容易造成用的人以为没有的情况。\n\n### 团队经验\n\n备考项目组开始的时候技术只有4个人，一个前端，一个后端，2个移动端，现在有10个人了，4个前端，4个后端，2个移动端，因此我也提升到我们组内前端小团队的小leader了，每个迭代前端的迭代任务如何分配和执行，大家如何协作分工，同时又能保证每个人都有各自的fallback，比如A请假或者离职，这个项目一定有一个不是特别熟悉但是可以正常接手处理的B存在，团队建设，分享等等都有一些自己的心得吧。\n\n### 团队合作\n\n除了组内的团队，还会经常参与到与运营或者产品进行一些需求的评审，协助运营开发一些运营常用的工具，比如“先知”数据分析，前端的打点sdk是无埋点的，后端的实时数据分析，还有微信公众号的一些二维码生成工具，关键字回复设置功能等等，推进一些公司前端方向的基础建设等等。 -->\n \n## JKL公司 （ 2010年3月 ~ 2012年8月 ）\n\n### MNO项目 \n我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。\n\n\n### PQR项目 \n我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。\n\n\n### 其他项目\n\n（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。）\n\n---\n\n# 开源项目和作品\n（这一段用于放置工作以外的、可证明你的能力的材料）\n\n## 开源项目\n（对于程序员来讲，没有什么比Show me the code能有说服力了）\n\n - [STU](http://github.com/yourname/projectname)：项目的简要说明，Star和Fork数多的可以注明\n - [WXYZ](http://github.com/yourname/projectname)：项目的简要说明，Star和Fork数多的可以注明\n\n## 技术文章\n（挑选你写作或翻译的技术文章，好的文章可以从侧面证实你的表达和沟通能力，也帮助招聘方更了解你）\n\n- [一个产品经理眼中的云计算：前生今世和未来](http://get.jobdeer.com/706.get)\n- [来自HeroKu的HTTP API 设计指南(翻译文章)](http://get.jobdeer.com/343.get) （ ```好的翻译文章可以侧证你对英文技术文档的阅读能力```）\n\n## 演讲和讲义\n（放置你代表公司在一些技术会议上做过的演讲，以及你在公司分享时制作的讲义）\n\n  - 2014架构师大会演讲：[如何通过Docker优化内部开发](http://jobdeer.com)\n - 9月公司内部分享：[云计算的前生今世](http://jobdeer.com)\n\n# 技能清单\n（我一般主张将技能清单写入到工作经历里边去。不过很难完整，所以有这么一段也不错）\n\n以下均为我熟练使用的技能\n\n- Web开发：PHP/Hack/Node\n- Web框架：ThinkPHP/Yaf/Yii/Lavaral/LazyPHP\n- 前端框架：Bootstrap/AngularJS/EmberJS/HTML5/Cocos2dJS/ionic\n- 前端工具：Bower/Gulp/SaSS/LeSS/PhoneGap\n- 数据库相关：MySQL/PgSQL/PDO/SQLite\n- 版本管理、文档和自动化部署工具：Svn/Git/PHPDoc/Phing/Composer\n- 单元测试：PHPUnit/SimpleTest/Qunit\n- 云和开放平台：SAE/BAE/AWS/微博开放平台/微信应用开发\n\n## 参考技能关键字\n\n本技能关键字列表是从最近招聘Web前端的数百份JD中统计出来的，括号中是出现的词频。如果你的简历要投递给有机器（简历分选系统）和不如机器（不懂技术的HR）筛选简历环节的地方，请一定从下边高频关键词中选择5～10个适合你自己的。\n\n- web(889)\n- javascript(596)\n- css(555)\n- html(430)\n- jquery(323)\n- html5(312)\n- js(311)\n- ajax(196)\n- css3(176)\n- w3c(168)\n- div(156)\n- php(134)\n- xhtml(106)\n- java(92)\n- ui(78)\n- photoshop(75)\n- dom(63)\n- xml(56)\n- json(54)\n- yui(51)\n- flash(45)\n- bootstrap(43)\n- python(43)\n- http(38)\n- dreamweaver(38)\n- ext(33)\n- linux(33)\n- seo(32)\n- prototype(29)\n- chrome(28)\n- pc(28)\n- nodejs(28)\n- firefox(26)\n- ps(25)\n- angularjs(25)\n- fireworks(24)\n- extjs(23)\n- safari(22)\n- www(22)\n- mobile(22)\n- jsp(22)\n- mvc(22)\n- backbone(21)\n- node(21)\n- ruby(20)\n- github(19)\n- ios(18)\n- ie6(18)\n- android(18)\n- asp(18)\n- sass(17)\n- wap(16)\n- mootools(16)\n- ie(16)\n- mysql(15)\n- flex(14)\n- firebug(13)\n- bom(13)\n- webapp(12)\n- less(12)\n- web2(11)\n- angular(10)\n- git(10)\n- dw(10)\n- as(10)\n- mac(10)\n- psd(8)\n- o2o(7)\n- dojo(7)\n- actionscript3(6)\n- grunt(5)\n- ue(5)\n- zepto(5)\n- actionscript(5)\n- ie8(5)\n- coffeescript(5)\n- django(4)\n\n---\n\n# 致谢\n感谢您花时间阅读我的简历，期待能有机会和您共事。\n","source":"about/index.md","raw":"---\ntitle: 个人简历\ndate: 2019-06-20 14:31:08\ntag: about\n---\n\n\n# 联系方式\n\n- 手机：18551809643\n- Email：gk.jing@gmail.com\n- 微信号：jgk15110625817\n\n---\n\n# 个人信息\n\n - 景国凯/男/1992 \n - 本科/山西师范大学电子信息工程 \n - 工作年限：4年(15届毕业)\n - Github：[https://github.com/jinggk](https://github.com/jinggk)\n\n - 期望职位：资深Web前端工程师\n - 期望薪资：税前月薪20k~25k，特别喜欢的公司可例外\n - 期望城市：南京\n\n---\n\n# 工作经历\n\n<!-- ## 南京贝湾教育科技有限公司 （ 2017年9月 ~ 现在 ）\n\n### 备考训练营\n备考训练营是针对在校大学生备考四六级考试的一个项目，具体的实现包含了native + webview的结合，个人主要负责webview部分的开发，以及个别与native的沟通协作，具体如下：\n1.0版本的所有webview部分开发\n2.0版本的部分webview开发\n3.0版本的小部分webview开发\n\n(1).除了一些每一版本中稳定的迭代，最大挑战就是运营每一期活动的经常变动，因此在2.0结束到3.0期间尝试了类似于飞冰的GUI工具，起名为夸父项目，但是由于新项目的需求以及后端人员不能够有效投入，还有一些额外的原因吧，导致这个项目被搁置了（只出了一个初版），不过在3.0的开发中已经实现了代码中配置化开发，这样只要不是特别大的改动在4.0基本可以实现内部配置化开发，因此假以时日夸父还是可以做起来。\n\n(2).夸父项目功能简介：\n1.页面的自动化配置，\n2.定时任务的设置，\n3.A/B测试的配置，\n4.微信授权，内部预览功能的设置\n对了，夸父通过iframe的方式实现实时预览，因此也算是所见即所得的GUI工具。\n\n夸父项目的搁置也让我明白了一个道理，步子不能迈的太大，容易做不起来，加入开始的时候就先实现代码中的组件配置化，可能现在就已经投入使用了。\n\n(3).另外就是和移动端的配合，因为APP的一些历史原因吧，我接受做webview的时候，使用的交互是前端使用href跳转一个xxx.native.xxx的私有路由，移动端进行拦截实现的，这个有个很大的问题，假如用户没有及时更新(移动端的痛点，热更新不好搞，尤其是ios端)，webview统一上去后，用户其实点击的时候没有任何响应，所以当时我了解了这个情况后感觉很惊讶，怎么会不考虑这个问题，而且IOS和Android端的路由表配置的相当乱~(历史原因吧),哪些在用哪些不用都不清楚，因此都不敢删除，所以我当时想了一个方案就是虽然交互方式改不了，但是可以改协议的方式，把私有协议改为http的，这样的话http默认画一个提示用户去升级的页面，判断IOS和android分别到各自的商店去下载新版app，这样，即时用户没更新点了之后也知道发生了什么事情，提升了用户体验吧；\n\n(4).还有一个问题就是webview覆盖跳转的问题，我们都知道移动端webview load了一个url后，如果再利用href跳转默认会出现2层history栈，因此webview在左上角的返回旁边多了一个关闭按钮，用户点了不会返回之前的webview页面，而是直接到原生页面去了，当时想了一个方案就是在query中带一个特殊的参数，移动端一旦监听到这个额外的参数，就重新开一个webview来load这个新的url，这样不会出现关闭按钮，同时还能正常返回上一个页面，当然这种情况是要看场景使用的，因为带这个参数的返回下，上一个页面不会刷新，有刷新需求的要想办法，网上很多就不说了。\n\n等等。\n\n\n### 备考下的小程序项目 \n参与了5个小程序的开发(扇贝精听，扇贝长难句，扇贝精品课，扇贝发音私教，扇贝四六级查分助手)\n\n1.小程序的开发，就正常开发和迭代，另外针对小程序我带领团队一起开发了nuwa(女娲)监控系统，我们在webview的错误监控用了sentry，但是小程序没法用，开始的时候我们尝试了fundebug(试用了不到一个月就下了)，但是他们是按beat的次数来收费的，感觉也就那样，于是大家商量一起自己实现一个基于小程序的监控系统，大概2个迭代的时间(半个月)，就上线了第一版，今年3月份过来我们整改wxcommon的时候迭代了第二版，现在已经很稳定了，并且已经推向了全公司的各个部门使用，得到了一致的好评，这个项目sdk端的核心就是重写了小程序的一些核心生命周期的方法来抓取一些错误，同时对于请求的错误，我们重新了wx.request来实现的，遇到的最大的问题其实到现在还是没解决掉，只能通过约束来实现，问题是因为我们会把一些生命周期搞成异步的，async onLoad(){}，这样会有个问题，没有地方可以catch这个异步，它的运行在小程序的底层，所以这个地方我们只能是约束在内部await的时候一定要单独catch，然后我们的sdk会提供一个单独的handleError，允许丢一个错误进来进行上报，只能这样，暂时我也没想到好的办法。\n\n2.带领我们的团队封装了wxcommon这个lib，里面有一些各个业务组使用的util，比如支付，生成海报，版本检测等等，nuwa也在这个里面，还有一个就是对audiomanager的处理，因为微信原生的audiomanager经常出问题，做过小程序对于微信自己的坑应该都了解，经常有bug，并且在devtool，android和ios的表现形式都不一样，因此我们自己二次封装了这个东西，并且在内部屏蔽了对不同平台的处理，使其对外表现形式尽量一致，等等\n\n\n### libs开发\n\n1.wxcommon的迭代升级，修改打包方式，文档产出等\n2.generator更新，一个生成前端项目的cli工具\n3.部分exam-utils开发，所有备考组libs的集合\n4.公司所有前端的eslint规范和文档产出\n5.等等一些小pr\n\n心得：经常用的lib一定要迭代和维护，文档一定要配套更新，\n更新一定要及时通知到所有的前端开发，否则会出现不停的重复造轮子，真的没必要，很容易造成用的人以为没有的情况。\n\n### 团队经验\n\n备考项目组开始的时候技术只有4个人，一个前端，一个后端，2个移动端，现在有10个人了，4个前端，4个后端，2个移动端，因此我也提升到我们组内前端小团队的小leader了，每个迭代前端的迭代任务如何分配和执行，大家如何协作分工，同时又能保证每个人都有各自的fallback，比如A请假或者离职，这个项目一定有一个不是特别熟悉但是可以正常接手处理的B存在，团队建设，分享等等都有一些自己的心得吧。\n\n### 团队合作\n\n除了组内的团队，还会经常参与到与运营或者产品进行一些需求的评审，协助运营开发一些运营常用的工具，比如“先知”数据分析，前端的打点sdk是无埋点的，后端的实时数据分析，还有微信公众号的一些二维码生成工具，关键字回复设置功能等等，推进一些公司前端方向的基础建设等等。 -->\n \n## JKL公司 （ 2010年3月 ~ 2012年8月 ）\n\n### MNO项目 \n我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。\n\n\n### PQR项目 \n我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。\n\n\n### 其他项目\n\n（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。）\n\n---\n\n# 开源项目和作品\n（这一段用于放置工作以外的、可证明你的能力的材料）\n\n## 开源项目\n（对于程序员来讲，没有什么比Show me the code能有说服力了）\n\n - [STU](http://github.com/yourname/projectname)：项目的简要说明，Star和Fork数多的可以注明\n - [WXYZ](http://github.com/yourname/projectname)：项目的简要说明，Star和Fork数多的可以注明\n\n## 技术文章\n（挑选你写作或翻译的技术文章，好的文章可以从侧面证实你的表达和沟通能力，也帮助招聘方更了解你）\n\n- [一个产品经理眼中的云计算：前生今世和未来](http://get.jobdeer.com/706.get)\n- [来自HeroKu的HTTP API 设计指南(翻译文章)](http://get.jobdeer.com/343.get) （ ```好的翻译文章可以侧证你对英文技术文档的阅读能力```）\n\n## 演讲和讲义\n（放置你代表公司在一些技术会议上做过的演讲，以及你在公司分享时制作的讲义）\n\n  - 2014架构师大会演讲：[如何通过Docker优化内部开发](http://jobdeer.com)\n - 9月公司内部分享：[云计算的前生今世](http://jobdeer.com)\n\n# 技能清单\n（我一般主张将技能清单写入到工作经历里边去。不过很难完整，所以有这么一段也不错）\n\n以下均为我熟练使用的技能\n\n- Web开发：PHP/Hack/Node\n- Web框架：ThinkPHP/Yaf/Yii/Lavaral/LazyPHP\n- 前端框架：Bootstrap/AngularJS/EmberJS/HTML5/Cocos2dJS/ionic\n- 前端工具：Bower/Gulp/SaSS/LeSS/PhoneGap\n- 数据库相关：MySQL/PgSQL/PDO/SQLite\n- 版本管理、文档和自动化部署工具：Svn/Git/PHPDoc/Phing/Composer\n- 单元测试：PHPUnit/SimpleTest/Qunit\n- 云和开放平台：SAE/BAE/AWS/微博开放平台/微信应用开发\n\n## 参考技能关键字\n\n本技能关键字列表是从最近招聘Web前端的数百份JD中统计出来的，括号中是出现的词频。如果你的简历要投递给有机器（简历分选系统）和不如机器（不懂技术的HR）筛选简历环节的地方，请一定从下边高频关键词中选择5～10个适合你自己的。\n\n- web(889)\n- javascript(596)\n- css(555)\n- html(430)\n- jquery(323)\n- html5(312)\n- js(311)\n- ajax(196)\n- css3(176)\n- w3c(168)\n- div(156)\n- php(134)\n- xhtml(106)\n- java(92)\n- ui(78)\n- photoshop(75)\n- dom(63)\n- xml(56)\n- json(54)\n- yui(51)\n- flash(45)\n- bootstrap(43)\n- python(43)\n- http(38)\n- dreamweaver(38)\n- ext(33)\n- linux(33)\n- seo(32)\n- prototype(29)\n- chrome(28)\n- pc(28)\n- nodejs(28)\n- firefox(26)\n- ps(25)\n- angularjs(25)\n- fireworks(24)\n- extjs(23)\n- safari(22)\n- www(22)\n- mobile(22)\n- jsp(22)\n- mvc(22)\n- backbone(21)\n- node(21)\n- ruby(20)\n- github(19)\n- ios(18)\n- ie6(18)\n- android(18)\n- asp(18)\n- sass(17)\n- wap(16)\n- mootools(16)\n- ie(16)\n- mysql(15)\n- flex(14)\n- firebug(13)\n- bom(13)\n- webapp(12)\n- less(12)\n- web2(11)\n- angular(10)\n- git(10)\n- dw(10)\n- as(10)\n- mac(10)\n- psd(8)\n- o2o(7)\n- dojo(7)\n- actionscript3(6)\n- grunt(5)\n- ue(5)\n- zepto(5)\n- actionscript(5)\n- ie8(5)\n- coffeescript(5)\n- django(4)\n\n---\n\n# 致谢\n感谢您花时间阅读我的简历，期待能有机会和您共事。\n","updated":"2019-06-20T06:36:04.676Z","path":"about/index.html","_id":"cjx4afn4b0001q67w4l9d6um4","comments":1,"layout":"page","content":"<h1 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h1><ul>\n<li>手机：18551809643</li>\n<li>Email：<a href=\"mailto:gk.jing@gmail.com\" target=\"_blank\" rel=\"noopener\">gk.jing@gmail.com</a></li>\n<li>微信号：jgk15110625817</li>\n</ul>\n<hr>\n<h1 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h1><ul>\n<li><p>景国凯/男/1992 </p>\n</li>\n<li><p>本科/山西师范大学电子信息工程 </p>\n</li>\n<li><p>工作年限：4年(15届毕业)</p>\n</li>\n<li><p>Github：<a href=\"https://github.com/jinggk\" target=\"_blank\" rel=\"noopener\">https://github.com/jinggk</a></p>\n</li>\n<li><p>期望职位：资深Web前端工程师</p>\n</li>\n<li><p>期望薪资：税前月薪20k~25k，特别喜欢的公司可例外</p>\n</li>\n<li><p>期望城市：南京</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h1><!-- ## 南京贝湾教育科技有限公司 （ 2017年9月 ~ 现在 ）\n\n### 备考训练营\n备考训练营是针对在校大学生备考四六级考试的一个项目，具体的实现包含了native + webview的结合，个人主要负责webview部分的开发，以及个别与native的沟通协作，具体如下：\n1.0版本的所有webview部分开发\n2.0版本的部分webview开发\n3.0版本的小部分webview开发\n\n(1).除了一些每一版本中稳定的迭代，最大挑战就是运营每一期活动的经常变动，因此在2.0结束到3.0期间尝试了类似于飞冰的GUI工具，起名为夸父项目，但是由于新项目的需求以及后端人员不能够有效投入，还有一些额外的原因吧，导致这个项目被搁置了（只出了一个初版），不过在3.0的开发中已经实现了代码中配置化开发，这样只要不是特别大的改动在4.0基本可以实现内部配置化开发，因此假以时日夸父还是可以做起来。\n\n(2).夸父项目功能简介：\n1.页面的自动化配置，\n2.定时任务的设置，\n3.A/B测试的配置，\n4.微信授权，内部预览功能的设置\n对了，夸父通过iframe的方式实现实时预览，因此也算是所见即所得的GUI工具。\n\n夸父项目的搁置也让我明白了一个道理，步子不能迈的太大，容易做不起来，加入开始的时候就先实现代码中的组件配置化，可能现在就已经投入使用了。\n\n(3).另外就是和移动端的配合，因为APP的一些历史原因吧，我接受做webview的时候，使用的交互是前端使用href跳转一个xxx.native.xxx的私有路由，移动端进行拦截实现的，这个有个很大的问题，假如用户没有及时更新(移动端的痛点，热更新不好搞，尤其是ios端)，webview统一上去后，用户其实点击的时候没有任何响应，所以当时我了解了这个情况后感觉很惊讶，怎么会不考虑这个问题，而且IOS和Android端的路由表配置的相当乱~(历史原因吧),哪些在用哪些不用都不清楚，因此都不敢删除，所以我当时想了一个方案就是虽然交互方式改不了，但是可以改协议的方式，把私有协议改为http的，这样的话http默认画一个提示用户去升级的页面，判断IOS和android分别到各自的商店去下载新版app，这样，即时用户没更新点了之后也知道发生了什么事情，提升了用户体验吧；\n\n(4).还有一个问题就是webview覆盖跳转的问题，我们都知道移动端webview load了一个url后，如果再利用href跳转默认会出现2层history栈，因此webview在左上角的返回旁边多了一个关闭按钮，用户点了不会返回之前的webview页面，而是直接到原生页面去了，当时想了一个方案就是在query中带一个特殊的参数，移动端一旦监听到这个额外的参数，就重新开一个webview来load这个新的url，这样不会出现关闭按钮，同时还能正常返回上一个页面，当然这种情况是要看场景使用的，因为带这个参数的返回下，上一个页面不会刷新，有刷新需求的要想办法，网上很多就不说了。\n\n等等。\n\n\n### 备考下的小程序项目 \n参与了5个小程序的开发(扇贝精听，扇贝长难句，扇贝精品课，扇贝发音私教，扇贝四六级查分助手)\n\n1.小程序的开发，就正常开发和迭代，另外针对小程序我带领团队一起开发了nuwa(女娲)监控系统，我们在webview的错误监控用了sentry，但是小程序没法用，开始的时候我们尝试了fundebug(试用了不到一个月就下了)，但是他们是按beat的次数来收费的，感觉也就那样，于是大家商量一起自己实现一个基于小程序的监控系统，大概2个迭代的时间(半个月)，就上线了第一版，今年3月份过来我们整改wxcommon的时候迭代了第二版，现在已经很稳定了，并且已经推向了全公司的各个部门使用，得到了一致的好评，这个项目sdk端的核心就是重写了小程序的一些核心生命周期的方法来抓取一些错误，同时对于请求的错误，我们重新了wx.request来实现的，遇到的最大的问题其实到现在还是没解决掉，只能通过约束来实现，问题是因为我们会把一些生命周期搞成异步的，async onLoad(){}，这样会有个问题，没有地方可以catch这个异步，它的运行在小程序的底层，所以这个地方我们只能是约束在内部await的时候一定要单独catch，然后我们的sdk会提供一个单独的handleError，允许丢一个错误进来进行上报，只能这样，暂时我也没想到好的办法。\n\n2.带领我们的团队封装了wxcommon这个lib，里面有一些各个业务组使用的util，比如支付，生成海报，版本检测等等，nuwa也在这个里面，还有一个就是对audiomanager的处理，因为微信原生的audiomanager经常出问题，做过小程序对于微信自己的坑应该都了解，经常有bug，并且在devtool，android和ios的表现形式都不一样，因此我们自己二次封装了这个东西，并且在内部屏蔽了对不同平台的处理，使其对外表现形式尽量一致，等等\n\n\n### libs开发\n\n1.wxcommon的迭代升级，修改打包方式，文档产出等\n2.generator更新，一个生成前端项目的cli工具\n3.部分exam-utils开发，所有备考组libs的集合\n4.公司所有前端的eslint规范和文档产出\n5.等等一些小pr\n\n心得：经常用的lib一定要迭代和维护，文档一定要配套更新，\n更新一定要及时通知到所有的前端开发，否则会出现不停的重复造轮子，真的没必要，很容易造成用的人以为没有的情况。\n\n### 团队经验\n\n备考项目组开始的时候技术只有4个人，一个前端，一个后端，2个移动端，现在有10个人了，4个前端，4个后端，2个移动端，因此我也提升到我们组内前端小团队的小leader了，每个迭代前端的迭代任务如何分配和执行，大家如何协作分工，同时又能保证每个人都有各自的fallback，比如A请假或者离职，这个项目一定有一个不是特别熟悉但是可以正常接手处理的B存在，团队建设，分享等等都有一些自己的心得吧。\n\n### 团队合作\n\n除了组内的团队，还会经常参与到与运营或者产品进行一些需求的评审，协助运营开发一些运营常用的工具，比如“先知”数据分析，前端的打点sdk是无埋点的，后端的实时数据分析，还有微信公众号的一些二维码生成工具，关键字回复设置功能等等，推进一些公司前端方向的基础建设等等。 -->\n\n<h2 id=\"JKL公司-（-2010年3月-2012年8月-）\"><a href=\"#JKL公司-（-2010年3月-2012年8月-）\" class=\"headerlink\" title=\"JKL公司 （ 2010年3月 ~ 2012年8月 ）\"></a>JKL公司 （ 2010年3月 ~ 2012年8月 ）</h2><h3 id=\"MNO项目\"><a href=\"#MNO项目\" class=\"headerlink\" title=\"MNO项目\"></a>MNO项目</h3><p>我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。</p>\n<h3 id=\"PQR项目\"><a href=\"#PQR项目\" class=\"headerlink\" title=\"PQR项目\"></a>PQR项目</h3><p>我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。</p>\n<h3 id=\"其他项目\"><a href=\"#其他项目\" class=\"headerlink\" title=\"其他项目\"></a>其他项目</h3><p>（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。）</p>\n<hr>\n<h1 id=\"开源项目和作品\"><a href=\"#开源项目和作品\" class=\"headerlink\" title=\"开源项目和作品\"></a>开源项目和作品</h1><p>（这一段用于放置工作以外的、可证明你的能力的材料）</p>\n<h2 id=\"开源项目\"><a href=\"#开源项目\" class=\"headerlink\" title=\"开源项目\"></a>开源项目</h2><p>（对于程序员来讲，没有什么比Show me the code能有说服力了）</p>\n<ul>\n<li><a href=\"http://github.com/yourname/projectname\" target=\"_blank\" rel=\"noopener\">STU</a>：项目的简要说明，Star和Fork数多的可以注明</li>\n<li><a href=\"http://github.com/yourname/projectname\" target=\"_blank\" rel=\"noopener\">WXYZ</a>：项目的简要说明，Star和Fork数多的可以注明</li>\n</ul>\n<h2 id=\"技术文章\"><a href=\"#技术文章\" class=\"headerlink\" title=\"技术文章\"></a>技术文章</h2><p>（挑选你写作或翻译的技术文章，好的文章可以从侧面证实你的表达和沟通能力，也帮助招聘方更了解你）</p>\n<ul>\n<li><a href=\"http://get.jobdeer.com/706.get\" target=\"_blank\" rel=\"noopener\">一个产品经理眼中的云计算：前生今世和未来</a></li>\n<li><a href=\"http://get.jobdeer.com/343.get\" target=\"_blank\" rel=\"noopener\">来自HeroKu的HTTP API 设计指南(翻译文章)</a> （ <code>好的翻译文章可以侧证你对英文技术文档的阅读能力</code>）</li>\n</ul>\n<h2 id=\"演讲和讲义\"><a href=\"#演讲和讲义\" class=\"headerlink\" title=\"演讲和讲义\"></a>演讲和讲义</h2><p>（放置你代表公司在一些技术会议上做过的演讲，以及你在公司分享时制作的讲义）</p>\n<ul>\n<li>2014架构师大会演讲：<a href=\"http://jobdeer.com\" target=\"_blank\" rel=\"noopener\">如何通过Docker优化内部开发</a><ul>\n<li>9月公司内部分享：<a href=\"http://jobdeer.com\" target=\"_blank\" rel=\"noopener\">云计算的前生今世</a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"技能清单\"><a href=\"#技能清单\" class=\"headerlink\" title=\"技能清单\"></a>技能清单</h1><p>（我一般主张将技能清单写入到工作经历里边去。不过很难完整，所以有这么一段也不错）</p>\n<p>以下均为我熟练使用的技能</p>\n<ul>\n<li>Web开发：PHP/Hack/Node</li>\n<li>Web框架：ThinkPHP/Yaf/Yii/Lavaral/LazyPHP</li>\n<li>前端框架：Bootstrap/AngularJS/EmberJS/HTML5/Cocos2dJS/ionic</li>\n<li>前端工具：Bower/Gulp/SaSS/LeSS/PhoneGap</li>\n<li>数据库相关：MySQL/PgSQL/PDO/SQLite</li>\n<li>版本管理、文档和自动化部署工具：Svn/Git/PHPDoc/Phing/Composer</li>\n<li>单元测试：PHPUnit/SimpleTest/Qunit</li>\n<li>云和开放平台：SAE/BAE/AWS/微博开放平台/微信应用开发</li>\n</ul>\n<h2 id=\"参考技能关键字\"><a href=\"#参考技能关键字\" class=\"headerlink\" title=\"参考技能关键字\"></a>参考技能关键字</h2><p>本技能关键字列表是从最近招聘Web前端的数百份JD中统计出来的，括号中是出现的词频。如果你的简历要投递给有机器（简历分选系统）和不如机器（不懂技术的HR）筛选简历环节的地方，请一定从下边高频关键词中选择5～10个适合你自己的。</p>\n<ul>\n<li>web(889)</li>\n<li>javascript(596)</li>\n<li>css(555)</li>\n<li>html(430)</li>\n<li>jquery(323)</li>\n<li>html5(312)</li>\n<li>js(311)</li>\n<li>ajax(196)</li>\n<li>css3(176)</li>\n<li>w3c(168)</li>\n<li>div(156)</li>\n<li>php(134)</li>\n<li>xhtml(106)</li>\n<li>java(92)</li>\n<li>ui(78)</li>\n<li>photoshop(75)</li>\n<li>dom(63)</li>\n<li>xml(56)</li>\n<li>json(54)</li>\n<li>yui(51)</li>\n<li>flash(45)</li>\n<li>bootstrap(43)</li>\n<li>python(43)</li>\n<li>http(38)</li>\n<li>dreamweaver(38)</li>\n<li>ext(33)</li>\n<li>linux(33)</li>\n<li>seo(32)</li>\n<li>prototype(29)</li>\n<li>chrome(28)</li>\n<li>pc(28)</li>\n<li>nodejs(28)</li>\n<li>firefox(26)</li>\n<li>ps(25)</li>\n<li>angularjs(25)</li>\n<li>fireworks(24)</li>\n<li>extjs(23)</li>\n<li>safari(22)</li>\n<li>www(22)</li>\n<li>mobile(22)</li>\n<li>jsp(22)</li>\n<li>mvc(22)</li>\n<li>backbone(21)</li>\n<li>node(21)</li>\n<li>ruby(20)</li>\n<li>github(19)</li>\n<li>ios(18)</li>\n<li>ie6(18)</li>\n<li>android(18)</li>\n<li>asp(18)</li>\n<li>sass(17)</li>\n<li>wap(16)</li>\n<li>mootools(16)</li>\n<li>ie(16)</li>\n<li>mysql(15)</li>\n<li>flex(14)</li>\n<li>firebug(13)</li>\n<li>bom(13)</li>\n<li>webapp(12)</li>\n<li>less(12)</li>\n<li>web2(11)</li>\n<li>angular(10)</li>\n<li>git(10)</li>\n<li>dw(10)</li>\n<li>as(10)</li>\n<li>mac(10)</li>\n<li>psd(8)</li>\n<li>o2o(7)</li>\n<li>dojo(7)</li>\n<li>actionscript3(6)</li>\n<li>grunt(5)</li>\n<li>ue(5)</li>\n<li>zepto(5)</li>\n<li>actionscript(5)</li>\n<li>ie8(5)</li>\n<li>coffeescript(5)</li>\n<li>django(4)</li>\n</ul>\n<hr>\n<h1 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h1><p>感谢您花时间阅读我的简历，期待能有机会和您共事。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h1><ul>\n<li>手机：18551809643</li>\n<li>Email：<a href=\"mailto:gk.jing@gmail.com\" target=\"_blank\" rel=\"noopener\">gk.jing@gmail.com</a></li>\n<li>微信号：jgk15110625817</li>\n</ul>\n<hr>\n<h1 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h1><ul>\n<li><p>景国凯/男/1992 </p>\n</li>\n<li><p>本科/山西师范大学电子信息工程 </p>\n</li>\n<li><p>工作年限：4年(15届毕业)</p>\n</li>\n<li><p>Github：<a href=\"https://github.com/jinggk\" target=\"_blank\" rel=\"noopener\">https://github.com/jinggk</a></p>\n</li>\n<li><p>期望职位：资深Web前端工程师</p>\n</li>\n<li><p>期望薪资：税前月薪20k~25k，特别喜欢的公司可例外</p>\n</li>\n<li><p>期望城市：南京</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h1><!-- ## 南京贝湾教育科技有限公司 （ 2017年9月 ~ 现在 ）\n\n### 备考训练营\n备考训练营是针对在校大学生备考四六级考试的一个项目，具体的实现包含了native + webview的结合，个人主要负责webview部分的开发，以及个别与native的沟通协作，具体如下：\n1.0版本的所有webview部分开发\n2.0版本的部分webview开发\n3.0版本的小部分webview开发\n\n(1).除了一些每一版本中稳定的迭代，最大挑战就是运营每一期活动的经常变动，因此在2.0结束到3.0期间尝试了类似于飞冰的GUI工具，起名为夸父项目，但是由于新项目的需求以及后端人员不能够有效投入，还有一些额外的原因吧，导致这个项目被搁置了（只出了一个初版），不过在3.0的开发中已经实现了代码中配置化开发，这样只要不是特别大的改动在4.0基本可以实现内部配置化开发，因此假以时日夸父还是可以做起来。\n\n(2).夸父项目功能简介：\n1.页面的自动化配置，\n2.定时任务的设置，\n3.A/B测试的配置，\n4.微信授权，内部预览功能的设置\n对了，夸父通过iframe的方式实现实时预览，因此也算是所见即所得的GUI工具。\n\n夸父项目的搁置也让我明白了一个道理，步子不能迈的太大，容易做不起来，加入开始的时候就先实现代码中的组件配置化，可能现在就已经投入使用了。\n\n(3).另外就是和移动端的配合，因为APP的一些历史原因吧，我接受做webview的时候，使用的交互是前端使用href跳转一个xxx.native.xxx的私有路由，移动端进行拦截实现的，这个有个很大的问题，假如用户没有及时更新(移动端的痛点，热更新不好搞，尤其是ios端)，webview统一上去后，用户其实点击的时候没有任何响应，所以当时我了解了这个情况后感觉很惊讶，怎么会不考虑这个问题，而且IOS和Android端的路由表配置的相当乱~(历史原因吧),哪些在用哪些不用都不清楚，因此都不敢删除，所以我当时想了一个方案就是虽然交互方式改不了，但是可以改协议的方式，把私有协议改为http的，这样的话http默认画一个提示用户去升级的页面，判断IOS和android分别到各自的商店去下载新版app，这样，即时用户没更新点了之后也知道发生了什么事情，提升了用户体验吧；\n\n(4).还有一个问题就是webview覆盖跳转的问题，我们都知道移动端webview load了一个url后，如果再利用href跳转默认会出现2层history栈，因此webview在左上角的返回旁边多了一个关闭按钮，用户点了不会返回之前的webview页面，而是直接到原生页面去了，当时想了一个方案就是在query中带一个特殊的参数，移动端一旦监听到这个额外的参数，就重新开一个webview来load这个新的url，这样不会出现关闭按钮，同时还能正常返回上一个页面，当然这种情况是要看场景使用的，因为带这个参数的返回下，上一个页面不会刷新，有刷新需求的要想办法，网上很多就不说了。\n\n等等。\n\n\n### 备考下的小程序项目 \n参与了5个小程序的开发(扇贝精听，扇贝长难句，扇贝精品课，扇贝发音私教，扇贝四六级查分助手)\n\n1.小程序的开发，就正常开发和迭代，另外针对小程序我带领团队一起开发了nuwa(女娲)监控系统，我们在webview的错误监控用了sentry，但是小程序没法用，开始的时候我们尝试了fundebug(试用了不到一个月就下了)，但是他们是按beat的次数来收费的，感觉也就那样，于是大家商量一起自己实现一个基于小程序的监控系统，大概2个迭代的时间(半个月)，就上线了第一版，今年3月份过来我们整改wxcommon的时候迭代了第二版，现在已经很稳定了，并且已经推向了全公司的各个部门使用，得到了一致的好评，这个项目sdk端的核心就是重写了小程序的一些核心生命周期的方法来抓取一些错误，同时对于请求的错误，我们重新了wx.request来实现的，遇到的最大的问题其实到现在还是没解决掉，只能通过约束来实现，问题是因为我们会把一些生命周期搞成异步的，async onLoad(){}，这样会有个问题，没有地方可以catch这个异步，它的运行在小程序的底层，所以这个地方我们只能是约束在内部await的时候一定要单独catch，然后我们的sdk会提供一个单独的handleError，允许丢一个错误进来进行上报，只能这样，暂时我也没想到好的办法。\n\n2.带领我们的团队封装了wxcommon这个lib，里面有一些各个业务组使用的util，比如支付，生成海报，版本检测等等，nuwa也在这个里面，还有一个就是对audiomanager的处理，因为微信原生的audiomanager经常出问题，做过小程序对于微信自己的坑应该都了解，经常有bug，并且在devtool，android和ios的表现形式都不一样，因此我们自己二次封装了这个东西，并且在内部屏蔽了对不同平台的处理，使其对外表现形式尽量一致，等等\n\n\n### libs开发\n\n1.wxcommon的迭代升级，修改打包方式，文档产出等\n2.generator更新，一个生成前端项目的cli工具\n3.部分exam-utils开发，所有备考组libs的集合\n4.公司所有前端的eslint规范和文档产出\n5.等等一些小pr\n\n心得：经常用的lib一定要迭代和维护，文档一定要配套更新，\n更新一定要及时通知到所有的前端开发，否则会出现不停的重复造轮子，真的没必要，很容易造成用的人以为没有的情况。\n\n### 团队经验\n\n备考项目组开始的时候技术只有4个人，一个前端，一个后端，2个移动端，现在有10个人了，4个前端，4个后端，2个移动端，因此我也提升到我们组内前端小团队的小leader了，每个迭代前端的迭代任务如何分配和执行，大家如何协作分工，同时又能保证每个人都有各自的fallback，比如A请假或者离职，这个项目一定有一个不是特别熟悉但是可以正常接手处理的B存在，团队建设，分享等等都有一些自己的心得吧。\n\n### 团队合作\n\n除了组内的团队，还会经常参与到与运营或者产品进行一些需求的评审，协助运营开发一些运营常用的工具，比如“先知”数据分析，前端的打点sdk是无埋点的，后端的实时数据分析，还有微信公众号的一些二维码生成工具，关键字回复设置功能等等，推进一些公司前端方向的基础建设等等。 -->\n\n<h2 id=\"JKL公司-（-2010年3月-2012年8月-）\"><a href=\"#JKL公司-（-2010年3月-2012年8月-）\" class=\"headerlink\" title=\"JKL公司 （ 2010年3月 ~ 2012年8月 ）\"></a>JKL公司 （ 2010年3月 ~ 2012年8月 ）</h2><h3 id=\"MNO项目\"><a href=\"#MNO项目\" class=\"headerlink\" title=\"MNO项目\"></a>MNO项目</h3><p>我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。</p>\n<h3 id=\"PQR项目\"><a href=\"#PQR项目\" class=\"headerlink\" title=\"PQR项目\"></a>PQR项目</h3><p>我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。</p>\n<h3 id=\"其他项目\"><a href=\"#其他项目\" class=\"headerlink\" title=\"其他项目\"></a>其他项目</h3><p>（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。）</p>\n<hr>\n<h1 id=\"开源项目和作品\"><a href=\"#开源项目和作品\" class=\"headerlink\" title=\"开源项目和作品\"></a>开源项目和作品</h1><p>（这一段用于放置工作以外的、可证明你的能力的材料）</p>\n<h2 id=\"开源项目\"><a href=\"#开源项目\" class=\"headerlink\" title=\"开源项目\"></a>开源项目</h2><p>（对于程序员来讲，没有什么比Show me the code能有说服力了）</p>\n<ul>\n<li><a href=\"http://github.com/yourname/projectname\" target=\"_blank\" rel=\"noopener\">STU</a>：项目的简要说明，Star和Fork数多的可以注明</li>\n<li><a href=\"http://github.com/yourname/projectname\" target=\"_blank\" rel=\"noopener\">WXYZ</a>：项目的简要说明，Star和Fork数多的可以注明</li>\n</ul>\n<h2 id=\"技术文章\"><a href=\"#技术文章\" class=\"headerlink\" title=\"技术文章\"></a>技术文章</h2><p>（挑选你写作或翻译的技术文章，好的文章可以从侧面证实你的表达和沟通能力，也帮助招聘方更了解你）</p>\n<ul>\n<li><a href=\"http://get.jobdeer.com/706.get\" target=\"_blank\" rel=\"noopener\">一个产品经理眼中的云计算：前生今世和未来</a></li>\n<li><a href=\"http://get.jobdeer.com/343.get\" target=\"_blank\" rel=\"noopener\">来自HeroKu的HTTP API 设计指南(翻译文章)</a> （ <code>好的翻译文章可以侧证你对英文技术文档的阅读能力</code>）</li>\n</ul>\n<h2 id=\"演讲和讲义\"><a href=\"#演讲和讲义\" class=\"headerlink\" title=\"演讲和讲义\"></a>演讲和讲义</h2><p>（放置你代表公司在一些技术会议上做过的演讲，以及你在公司分享时制作的讲义）</p>\n<ul>\n<li>2014架构师大会演讲：<a href=\"http://jobdeer.com\" target=\"_blank\" rel=\"noopener\">如何通过Docker优化内部开发</a><ul>\n<li>9月公司内部分享：<a href=\"http://jobdeer.com\" target=\"_blank\" rel=\"noopener\">云计算的前生今世</a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"技能清单\"><a href=\"#技能清单\" class=\"headerlink\" title=\"技能清单\"></a>技能清单</h1><p>（我一般主张将技能清单写入到工作经历里边去。不过很难完整，所以有这么一段也不错）</p>\n<p>以下均为我熟练使用的技能</p>\n<ul>\n<li>Web开发：PHP/Hack/Node</li>\n<li>Web框架：ThinkPHP/Yaf/Yii/Lavaral/LazyPHP</li>\n<li>前端框架：Bootstrap/AngularJS/EmberJS/HTML5/Cocos2dJS/ionic</li>\n<li>前端工具：Bower/Gulp/SaSS/LeSS/PhoneGap</li>\n<li>数据库相关：MySQL/PgSQL/PDO/SQLite</li>\n<li>版本管理、文档和自动化部署工具：Svn/Git/PHPDoc/Phing/Composer</li>\n<li>单元测试：PHPUnit/SimpleTest/Qunit</li>\n<li>云和开放平台：SAE/BAE/AWS/微博开放平台/微信应用开发</li>\n</ul>\n<h2 id=\"参考技能关键字\"><a href=\"#参考技能关键字\" class=\"headerlink\" title=\"参考技能关键字\"></a>参考技能关键字</h2><p>本技能关键字列表是从最近招聘Web前端的数百份JD中统计出来的，括号中是出现的词频。如果你的简历要投递给有机器（简历分选系统）和不如机器（不懂技术的HR）筛选简历环节的地方，请一定从下边高频关键词中选择5～10个适合你自己的。</p>\n<ul>\n<li>web(889)</li>\n<li>javascript(596)</li>\n<li>css(555)</li>\n<li>html(430)</li>\n<li>jquery(323)</li>\n<li>html5(312)</li>\n<li>js(311)</li>\n<li>ajax(196)</li>\n<li>css3(176)</li>\n<li>w3c(168)</li>\n<li>div(156)</li>\n<li>php(134)</li>\n<li>xhtml(106)</li>\n<li>java(92)</li>\n<li>ui(78)</li>\n<li>photoshop(75)</li>\n<li>dom(63)</li>\n<li>xml(56)</li>\n<li>json(54)</li>\n<li>yui(51)</li>\n<li>flash(45)</li>\n<li>bootstrap(43)</li>\n<li>python(43)</li>\n<li>http(38)</li>\n<li>dreamweaver(38)</li>\n<li>ext(33)</li>\n<li>linux(33)</li>\n<li>seo(32)</li>\n<li>prototype(29)</li>\n<li>chrome(28)</li>\n<li>pc(28)</li>\n<li>nodejs(28)</li>\n<li>firefox(26)</li>\n<li>ps(25)</li>\n<li>angularjs(25)</li>\n<li>fireworks(24)</li>\n<li>extjs(23)</li>\n<li>safari(22)</li>\n<li>www(22)</li>\n<li>mobile(22)</li>\n<li>jsp(22)</li>\n<li>mvc(22)</li>\n<li>backbone(21)</li>\n<li>node(21)</li>\n<li>ruby(20)</li>\n<li>github(19)</li>\n<li>ios(18)</li>\n<li>ie6(18)</li>\n<li>android(18)</li>\n<li>asp(18)</li>\n<li>sass(17)</li>\n<li>wap(16)</li>\n<li>mootools(16)</li>\n<li>ie(16)</li>\n<li>mysql(15)</li>\n<li>flex(14)</li>\n<li>firebug(13)</li>\n<li>bom(13)</li>\n<li>webapp(12)</li>\n<li>less(12)</li>\n<li>web2(11)</li>\n<li>angular(10)</li>\n<li>git(10)</li>\n<li>dw(10)</li>\n<li>as(10)</li>\n<li>mac(10)</li>\n<li>psd(8)</li>\n<li>o2o(7)</li>\n<li>dojo(7)</li>\n<li>actionscript3(6)</li>\n<li>grunt(5)</li>\n<li>ue(5)</li>\n<li>zepto(5)</li>\n<li>actionscript(5)</li>\n<li>ie8(5)</li>\n<li>coffeescript(5)</li>\n<li>django(4)</li>\n</ul>\n<hr>\n<h1 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h1><p>感谢您花时间阅读我的简历，期待能有机会和您共事。</p>\n"}],"Post":[{"title":"http cache","date":"2018-12-05T09:39:03.000Z","_content":"\n### 1.强缓存\n\n#### 强缓存就是向浏览器缓存来查询文件是否存在以及是否可用\n\nhttp response header 中的expires 和 cache-control 字段,cache-control的优先级更高\n\nexpires 给的是具体的时间，这个有个明显的问题就是存在服务端和客户端时间不一致的情况，因此用的不是很多\n\ncache-control 可能的情况有\n    \n 1. public 所有内容都缓存，包括客户端和代理服务端\n 2. private 只有客户端可以缓存，这个也是cache-control的默认值\n 3. no-cache 客户端会缓存内容，但是是否使用，需要协商缓存来决定\n 4. no-store 所有内容都不缓存，包括协商缓存也不使用\n 5. max-age=time 缓存会在time时间后失效，相对值\n\n比如：\n\n```javascript\nCache-Control:public, max-age=31536000\n```\n\n\n### 2.协商缓存\n#### 协商缓存就是指强缓存失效，浏览器待着缓存标识到服务器上去查看缓存是否可用，它与强缓存最大的区别在于需要发起真正的请求\n\n常用的有两对：\n\n```javascript\nLast-Modified / If-Modified-Since\nEtag / If-None-Match // 优先级更高\n```\n\n```last-modified``` 是服务器设置的文件最后被修改的时间。\n浏览器拿到这个时间后，会再下一次发送请求的时候带上字段If-Modified-Since字段，其中放的就是上次浏览器给的最后修改的时间，服务器拿到这个时间后可以判断文件是否被更新过了从而决定是否使用缓存，如果可以使用缓存就会返回304\n\n```Etag / If-None-Match``` 和上面的原理基本一样，服务器在第一次返回的时候会携带Etag字段用来标识文件的唯一标识，类似于hash，之后浏览器在第二次请求的过程中会带上If-None-Match字段，服务器通过这个子段来判断缓存是否失效，从而返回304或者200\n\n\n#### 协商缓存和强缓存的共同点是，大家都是从使用客户端的缓存，不同点在于由谁来决定是否使用缓存。\n\n\n","source":"_posts/http cache.md","raw":"---\ntitle: http cache\ndate: 2018-12-05 17:39:03\ntags: http\n---\n\n### 1.强缓存\n\n#### 强缓存就是向浏览器缓存来查询文件是否存在以及是否可用\n\nhttp response header 中的expires 和 cache-control 字段,cache-control的优先级更高\n\nexpires 给的是具体的时间，这个有个明显的问题就是存在服务端和客户端时间不一致的情况，因此用的不是很多\n\ncache-control 可能的情况有\n    \n 1. public 所有内容都缓存，包括客户端和代理服务端\n 2. private 只有客户端可以缓存，这个也是cache-control的默认值\n 3. no-cache 客户端会缓存内容，但是是否使用，需要协商缓存来决定\n 4. no-store 所有内容都不缓存，包括协商缓存也不使用\n 5. max-age=time 缓存会在time时间后失效，相对值\n\n比如：\n\n```javascript\nCache-Control:public, max-age=31536000\n```\n\n\n### 2.协商缓存\n#### 协商缓存就是指强缓存失效，浏览器待着缓存标识到服务器上去查看缓存是否可用，它与强缓存最大的区别在于需要发起真正的请求\n\n常用的有两对：\n\n```javascript\nLast-Modified / If-Modified-Since\nEtag / If-None-Match // 优先级更高\n```\n\n```last-modified``` 是服务器设置的文件最后被修改的时间。\n浏览器拿到这个时间后，会再下一次发送请求的时候带上字段If-Modified-Since字段，其中放的就是上次浏览器给的最后修改的时间，服务器拿到这个时间后可以判断文件是否被更新过了从而决定是否使用缓存，如果可以使用缓存就会返回304\n\n```Etag / If-None-Match``` 和上面的原理基本一样，服务器在第一次返回的时候会携带Etag字段用来标识文件的唯一标识，类似于hash，之后浏览器在第二次请求的过程中会带上If-None-Match字段，服务器通过这个子段来判断缓存是否失效，从而返回304或者200\n\n\n#### 协商缓存和强缓存的共同点是，大家都是从使用客户端的缓存，不同点在于由谁来决定是否使用缓存。\n\n\n","slug":"http cache","published":1,"updated":"2019-06-20T05:14:46.464Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx4afn3x0000q67wum63c4sx","content":"<h3 id=\"1-强缓存\"><a href=\"#1-强缓存\" class=\"headerlink\" title=\"1.强缓存\"></a>1.强缓存</h3><h4 id=\"强缓存就是向浏览器缓存来查询文件是否存在以及是否可用\"><a href=\"#强缓存就是向浏览器缓存来查询文件是否存在以及是否可用\" class=\"headerlink\" title=\"强缓存就是向浏览器缓存来查询文件是否存在以及是否可用\"></a>强缓存就是向浏览器缓存来查询文件是否存在以及是否可用</h4><p>http response header 中的expires 和 cache-control 字段,cache-control的优先级更高</p>\n<p>expires 给的是具体的时间，这个有个明显的问题就是存在服务端和客户端时间不一致的情况，因此用的不是很多</p>\n<p>cache-control 可能的情况有</p>\n<ol>\n<li>public 所有内容都缓存，包括客户端和代理服务端</li>\n<li>private 只有客户端可以缓存，这个也是cache-control的默认值</li>\n<li>no-cache 客户端会缓存内容，但是是否使用，需要协商缓存来决定</li>\n<li>no-store 所有内容都不缓存，包括协商缓存也不使用</li>\n<li>max-age=time 缓存会在time时间后失效，相对值</li>\n</ol>\n<p>比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control:public, max-age=<span class=\"number\">31536000</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-协商缓存\"><a href=\"#2-协商缓存\" class=\"headerlink\" title=\"2.协商缓存\"></a>2.协商缓存</h3><h4 id=\"协商缓存就是指强缓存失效，浏览器待着缓存标识到服务器上去查看缓存是否可用，它与强缓存最大的区别在于需要发起真正的请求\"><a href=\"#协商缓存就是指强缓存失效，浏览器待着缓存标识到服务器上去查看缓存是否可用，它与强缓存最大的区别在于需要发起真正的请求\" class=\"headerlink\" title=\"协商缓存就是指强缓存失效，浏览器待着缓存标识到服务器上去查看缓存是否可用，它与强缓存最大的区别在于需要发起真正的请求\"></a>协商缓存就是指强缓存失效，浏览器待着缓存标识到服务器上去查看缓存是否可用，它与强缓存最大的区别在于需要发起真正的请求</h4><p>常用的有两对：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Last-Modified / If-Modified-Since</span><br><span class=\"line\">Etag / If-None-Match <span class=\"comment\">// 优先级更高</span></span><br></pre></td></tr></table></figure>\n\n<p><code>last-modified</code> 是服务器设置的文件最后被修改的时间。<br>浏览器拿到这个时间后，会再下一次发送请求的时候带上字段If-Modified-Since字段，其中放的就是上次浏览器给的最后修改的时间，服务器拿到这个时间后可以判断文件是否被更新过了从而决定是否使用缓存，如果可以使用缓存就会返回304</p>\n<p><code>Etag / If-None-Match</code> 和上面的原理基本一样，服务器在第一次返回的时候会携带Etag字段用来标识文件的唯一标识，类似于hash，之后浏览器在第二次请求的过程中会带上If-None-Match字段，服务器通过这个子段来判断缓存是否失效，从而返回304或者200</p>\n<h4 id=\"协商缓存和强缓存的共同点是，大家都是从使用客户端的缓存，不同点在于由谁来决定是否使用缓存。\"><a href=\"#协商缓存和强缓存的共同点是，大家都是从使用客户端的缓存，不同点在于由谁来决定是否使用缓存。\" class=\"headerlink\" title=\"协商缓存和强缓存的共同点是，大家都是从使用客户端的缓存，不同点在于由谁来决定是否使用缓存。\"></a>协商缓存和强缓存的共同点是，大家都是从使用客户端的缓存，不同点在于由谁来决定是否使用缓存。</h4>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-强缓存\"><a href=\"#1-强缓存\" class=\"headerlink\" title=\"1.强缓存\"></a>1.强缓存</h3><h4 id=\"强缓存就是向浏览器缓存来查询文件是否存在以及是否可用\"><a href=\"#强缓存就是向浏览器缓存来查询文件是否存在以及是否可用\" class=\"headerlink\" title=\"强缓存就是向浏览器缓存来查询文件是否存在以及是否可用\"></a>强缓存就是向浏览器缓存来查询文件是否存在以及是否可用</h4><p>http response header 中的expires 和 cache-control 字段,cache-control的优先级更高</p>\n<p>expires 给的是具体的时间，这个有个明显的问题就是存在服务端和客户端时间不一致的情况，因此用的不是很多</p>\n<p>cache-control 可能的情况有</p>\n<ol>\n<li>public 所有内容都缓存，包括客户端和代理服务端</li>\n<li>private 只有客户端可以缓存，这个也是cache-control的默认值</li>\n<li>no-cache 客户端会缓存内容，但是是否使用，需要协商缓存来决定</li>\n<li>no-store 所有内容都不缓存，包括协商缓存也不使用</li>\n<li>max-age=time 缓存会在time时间后失效，相对值</li>\n</ol>\n<p>比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control:public, max-age=<span class=\"number\">31536000</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-协商缓存\"><a href=\"#2-协商缓存\" class=\"headerlink\" title=\"2.协商缓存\"></a>2.协商缓存</h3><h4 id=\"协商缓存就是指强缓存失效，浏览器待着缓存标识到服务器上去查看缓存是否可用，它与强缓存最大的区别在于需要发起真正的请求\"><a href=\"#协商缓存就是指强缓存失效，浏览器待着缓存标识到服务器上去查看缓存是否可用，它与强缓存最大的区别在于需要发起真正的请求\" class=\"headerlink\" title=\"协商缓存就是指强缓存失效，浏览器待着缓存标识到服务器上去查看缓存是否可用，它与强缓存最大的区别在于需要发起真正的请求\"></a>协商缓存就是指强缓存失效，浏览器待着缓存标识到服务器上去查看缓存是否可用，它与强缓存最大的区别在于需要发起真正的请求</h4><p>常用的有两对：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Last-Modified / If-Modified-Since</span><br><span class=\"line\">Etag / If-None-Match <span class=\"comment\">// 优先级更高</span></span><br></pre></td></tr></table></figure>\n\n<p><code>last-modified</code> 是服务器设置的文件最后被修改的时间。<br>浏览器拿到这个时间后，会再下一次发送请求的时候带上字段If-Modified-Since字段，其中放的就是上次浏览器给的最后修改的时间，服务器拿到这个时间后可以判断文件是否被更新过了从而决定是否使用缓存，如果可以使用缓存就会返回304</p>\n<p><code>Etag / If-None-Match</code> 和上面的原理基本一样，服务器在第一次返回的时候会携带Etag字段用来标识文件的唯一标识，类似于hash，之后浏览器在第二次请求的过程中会带上If-None-Match字段，服务器通过这个子段来判断缓存是否失效，从而返回304或者200</p>\n<h4 id=\"协商缓存和强缓存的共同点是，大家都是从使用客户端的缓存，不同点在于由谁来决定是否使用缓存。\"><a href=\"#协商缓存和强缓存的共同点是，大家都是从使用客户端的缓存，不同点在于由谁来决定是否使用缓存。\" class=\"headerlink\" title=\"协商缓存和强缓存的共同点是，大家都是从使用客户端的缓存，不同点在于由谁来决定是否使用缓存。\"></a>协商缓存和强缓存的共同点是，大家都是从使用客户端的缓存，不同点在于由谁来决定是否使用缓存。</h4>"},{"title":"浅谈tcp","date":"2018-12-15T06:31:54.000Z","_content":"\n> 经常在前端的面试群中发现有人会碰到面试官去询问tcp的握手和挥手问题，诸如你了解tcp吗，解释一下tcp的三次握手和四次挥手，倒不是说这些问题没用吧，但是感觉其实知道不知道这个，对前端的意义(纯属个人扯淡想法)不是特别的大，所以我认为如果只是简单的问这2个问题，是没有任何意义的(不如不问，哈哈哈)，but 记得在上家公司的时候有个老哥说过，网络通信其实还是蛮重要的，毕竟我们现在无论是工作还是生活基本都处于互联网之中，尤其作为开发者基本上每天都在和http请求打交道，so 了解网络传输的原理还是有必要的，下面我们稍微深入的来看下网络传输的内容。\n\n### base\nOSI(Open Systems Interconncection，开放系统互联)网络分层\n\n 7.应用层(Application)\n 6.表示层(Presentation)\n 5.会话层(Session)\n 4.传输层(Transport)\n 3.网络层(Network)    -- 路由器\n 2.数据链路层(Data Link) -- 交换机\n 1.物理层(Physical) -- 网卡、集线器（Hub） \n \n基础内容不做过多的讲解，有需要的可以[出门右转](https://juejin.im/post/5a98e1f7f265da237410694e)\nok 我们今天主要关注的是tcp层的内容，下面的内容，如果有兴趣建议大家按照步骤实际操作去看看，首先介绍一个工具wireshark，这个工具可以帮助我们抓到tcp以及更底层的包，下载到[这里](https://www.wireshark.org/),打开后有个download，下载自己系统能用的就好，一路安装到全部完成，接下来我们开始一次实战抓包。\n\n### 抓包\n我这里利用了[百度的首页](https://www.baidu.com)做了一次抓包实验，首先要设置一个过滤\n<img src=\"https://i.loli.net/2019/06/20/5d0b002eb8a2045644.png\">\n你可以选择http 和 tcp 或者 tcp only\n<img src=\"https://i.loli.net/2019/06/20/5d0b002ebd5ca21200.png\">\n然后到控制台中去ping 一下百度首页的ip\n<img src=\"https://i.loli.net/2019/06/20/5d0b0fcfdbf5175380.png\">\n\nok 看到ip是180.97.33.108\n\n然后我们到wireshark中设置一下查询的ip\n<img src=\"https://i.loli.net/2019/06/20/5d0b10272289a28985.png\">\n到chrome中打开百度的首页，然后就能看到tcp的传输信息了\n<img src=\"https://i.loli.net/2019/06/20/5d0b002dea98659548.png\">\n内容有点多，我们通过这个内容来观察一下tcp的传输过程\n\n### tcp base\n先看下tcp的头部报文结构\n<img src=\"https://i.loli.net/2019/06/20/5d0b10e34ba3c74469.png\"/>\n1.tcp协议层是不关心ip的，具体ip的定位是由ip层来决定的，但是tcp层需要确定端口号，所以他会携带source 和 destination的port信息，以便能找到对应的端口号；\n\n2.sequence number 实际中使用的SEQ，也就是序号，这个序号起了很重要的作用，我们都知道tcp和udp最大的区别在于tcp是稳定并且有序的，其中seq就可以保证有序，当A向B发送一个数据包的时候，seq会叠加，每一个传输方在传送数据的时候都会带上这个信息，另一端能按照这个序号来排序收到信息的顺序，从未保证了信息的传递是有序的，也能通过它来确认有没有出现丢包的情况；另外要注意的是当有数据需要发送的时候，seq会随该序列号为原点，对自己将要发送的每个字节的数据进行编号，比如当前seq = 10，本次要发送的数据包大小是200字节，那么实际发送的时候会更新seq=210，以便保证传输的数据的顺序；\n\n3.acknowledge number，实际中使用的ACK，是另一端对对方seq的一个回应，一般会把对方给的seq+1然后下一次发包的时候带上，这样的话对方就知道我们是收到前面的消息的；\n\n4.windown代表的是滑动窗口，实际中用win来表示，win的大小很重要，win越大的传输越快，因为win的大小直接决定了某一端一次可以同时发送多少个数据包，而不用等待对方的应答ACK回来，但是win会随着每一个数据包的发送而变小(稍后解释)；\n\n5.reserved 是tcp传输很重要的角色，标志位，响应方会根据对方给的信号执行对应的操作，比如执行断开连接的时候一般都是使用FIN标志位；\n\n基础内容不做过多介绍，不懂的可以移步[这里]先看下概念，后面我们会结合实际来介绍(https://blog.csdn.net/jijianshuai/article/details/80883091)\n\n\n\n### 三次握手(敲黑板)\n<img src=\"https://i.loli.net/2019/06/20/5d0b002f1d28520287.png\">\n观察前几次传输，TLS类型的我们可以先忽略，它是处理ssl加密的内容，有兴趣的可以自己去google，重点看前三次的tcp，第一次是我们自己的ip向百度的服务器ip发了第一个包，seq=0，起始的数据信号是0，win=65535代表我这边的窗口大小是65535，len=0代表我这边希望接受的包的大小长度是0，mss代表我这边本次传输能接收的最大包的内容是1460(其余的我们暂时不用关心)。下面我们模拟一下对话内容：\n\nA：B，你好，我是A 请求建立连接，我的seq是0，我的win是65535，我希望本次回应我的内容长度len为0，我本次能接收的最大内容是1460，over；\nB：A，你也好，收到你的信息了，我是B，我本次的seq是0（注意，双方的序号是独立计算的，这里都从0开始的），我回应你的ack是1(A的seq+1，代表我收到你seq是0的消息了)，我的窗口大小是8192，我希望你回应我本次消息的len也是0，我这边能接收的最大回应大小是1452，over；\nA：好的，我收到你的回应了，我现在给你发送的seq是1(上一次是0，这次是1)，我回应你的ack是1(B的seq+1)，我当前的窗口大小是25984，我希望的回应长度是0；我们建立好连接了，over；\n\n到这里，完整的三次握手就结束了，后面就可以执行别的数据传输了，到这里，不知道有没有想过，为什么确定一次连接需要三次握手，不是1次，也不是2次，也不是4次，\n\n首先，1次肯定不行，1次的话 一方无法确认另一方的情况，所以最少都是2次起步，\n\n2次：\nA：喂喂喂，我是A，你听的到吗？\nB：在在在，我能听到，我是B，你能听到我吗?\nA：(听到了，老子不想理你)\nB：喂喂喂？听不听到？我X，对面死了，我挂了。。\n\n4次：\nA：喂喂喂，我是A，你听的到吗？\nB：在在在，我能听到，我是B，你能听到我吗?\nA：听到了，你呢？你能听到吗？\nB：？？你是智障？我不是说了我能听到吗，不想跟xx说话。。。\n\n所以最合理的还是3次：\n\nA：喂喂喂，我是A，你听的到吗？\nB：在在在，我能听到，我是B，你能听到我吗?\nA：听到了。我们今天去钓鱼吧。。balabala\n\nso，就是这样，其实不是不能更多，但是可靠的同时，还要考虑性能和时间问题，所以，目前公认的握手次数还是三次比较合理。\n\n\n### 四次挥手\n\n我们知道tcp的连接是全双工的，A和B是可以互相通信的，不理解的话，可以想想打电话（类比，不要当真），打电话的场景就是单双工的，因为同一时间只能一个人说话，另一个人听，如果2个人一起说话，那谁都听不清楚了，没有意义，但是tcp是全双工的，就是A 正在给 B发信息的同时，B也在给A发信息，所以当断开的时候，必须要求双方都得知道，如果只有一方知道，肯定不行，因此，断开的时候，就需要下面这样：\n\n<img src=\"http://hi.csdn.net/attachment/201108/7/0_1312718564tZXD.gif\"/>\n\nA：B，不好意思，我这边需要关闭连接了，你准备一下？(发了一个fin信号给B，等待回应)\nB：好的A，我收到你的关闭信号了，我还有数据没发好，你等我下（回应A，带回去ACK的最后一个信息，失败可以重发）\nB：A老弟，我好了，我可以关闭了，给你最后说一下，等下你回应我的话，我就直接关了；\nA：好的老哥，我回应你一下，你收到就关闭吧，不用理我(发完这条信息后，进入time_wait状态)\nB：(收到ack信息，直接就关闭了)，此过程不产生数据的交互，不算挥手次数\nA：等待2MSL(最大报文段生存时间)后，B没东西给过来，我也关了；\n\n到这里4次挥手就结束了，2个问题：\n\n1.为什么握手需要三次，而挥手却需要四次？\n\n握手的时候，A和B打个招呼，B可以直接把自己的SYN信息和对A的回应ACK信息一起带上，但是挥手的时候，A说我要断开了，B还没发完最后的数据，因此需要先回应一下A，我收到你的断开的请求了，但是你要等我把最后的内容给你，所以这里分开了2步：\n    （1）回应A；\n    （2）发送自己的最后一个数据\n\n2.为什么A进入TIME_WAIT需要等待最大报文段生存的时间后，才能关闭？\n\n原因是，担心网络不可靠而导致的丢包，最后一个回应B的ACK万一丢了怎么办，在这个时间内，A是可以重新发包的，但是超过了最大等待时间的话，就算收不到也没用了，所以就可以关闭了。\n\n\n### 如何理解滑动窗口的作用？\n从上面的内容，我们简单了解了三次握手和四次挥手的内容，然后也知道了一些报文字段的意义，但是网络本身是不稳定的，也就是说中间无法保证包一定会到对面，那么tcp是如何在尽可能少的时间内实现稳定和有序传输的？\n\n我们知道SYN信息中会带上自己的seq，序号，这样可以保证另一方接受到后知道如何排序，但是如果发送必须都是同步的，想象，A 给 B发送的时候，需要给B 1，2，3，4，5个包，发了1后，死等1的ack回来，再给2，死等2的ack回来，在linux下每个tcp的timeout最大是`2^5 - 1 = 63`s(默认的retrytime是5次)的时间，因为当发了一个包出去后，在一定时间内没收到ACK回应，为了确认不能丢包的问题，会启动重试机制，重试5次，它们的延迟分别是：1 秒、3 秒、7 秒、15 秒、31 秒，其中31s是前5次重试的时间1+2+4+8+16=31s，最后的32s是等待最后一次重试也超时(等待的时间是2的N次方秒)，所以一共就是63s，如果一个一个等，是不是有点太恐怖了，万一网络环境比较差，所以为了能在不丢包的情况下，尽量减少时间的损耗，引入了滑动窗口的概念，window\n\n由于窗口由16位bit所定义，所以接收端TCP，窗口能最大提供65535个字节的缓冲，其实这个滑动窗口主要就是做限流和缓冲用的，每一个tcp传输中的win提供的是对方的窗口大小，当A向B发数据的时候，超过B的win长度的数据会被丢掉，同时窗口还可以提高发送数据的效率，通过类似于并发的行为，如下图：\n<img src=\"https://i.loli.net/2019/06/20/5d0b002edb09192328.png\">\n\n可以看到A向B连续发了3条数据，但是回应B的ACK没有变，也就是说都是回应同一个B的同一个响应，但是A自己的seq更新了3次，先是1，然后是69最后是1521，说明这三个包是连续几乎同时发出去的，实际上只要当前数据包的大小不超过对方的window大小，就可以连续发的，接着看：\n\n<img src=\"https://i.loli.net/2019/06/20/5d0b002ee0eee77060.png\">\n这四个是B响应给A的数据包，可以看到都是在响应A给的数据包，注意看因为A连续发了好几条，B可能一下反应不过来，所以B会把这些信息放到缓冲区，但是放的数据越多，那么自己的缓冲区就越小，就是通过B自己的win来体现，我们可以看到B的win再连续变小，说明它还没处理好，到第4条信息的时候，我们看到B给了一个信息叫WINDOW UPDATE 然后发现B的win变大了，这就意味着它已经处理好A之前连续发的几个数据包了，然后就会重新更新自己的win的大小，要注意的是当tcp一端的win接近或者等于0的时候，传输将会停止，直到window update更新说buffer已经清空了，传输才会继续。\n\n\n### 丢包？\n看下面这个图\n<img src=\"https://i.loli.net/2019/06/20/5d0b11eb5c31665131.png\">\n明显能看到ACK是连续变大的，再一次链接中，不可能存在说先ACK=3922然后ACK=3913，这样的话另一端在收到3922的时候就认为之前的全部接收到了，实际上3913还没收到，所以，要注意SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包。那么，考虑以下情况，假如A给的分别是1，2，3，4到5 5个包，B这边收到1，2，Ack一个3（代表收到1，2了），然后3丢了，4和5收到了，能直接ACK = 6吗？当然不行，这样的话tcp就是不稳定的了，所以tcp会有超时重传，当1和2到了后，3没到，但是4和5到了，这个时候另一端回3，表示我这边只拿到1和2了，但是这种情况下有一个很严重的问题，就是其实4和5都到了，但是另一端没收到4和5的回应，会认为4和5也丢了，于是过了一会又开始重新传3，4，5，这样的话浪费了带宽，所以超时重传有2种方案：\n\n1.timeout后只重新传3；\n2.timeout后重新给3，4，5；\n\n2种方案有好有坏，第一种比较慢，第二种浪费带宽，所以tcp引入了一种快速超时重试机制(Fast Retransmit算法)，不以时间计算，而以数据做驱动重新传送，如果包没有连续到达，比如1到了，2没到，3，4，5也到了，这个时候，B始终返回ACK=2，代表只确认1，然后A就知道2没到，重新发2，但是B一旦收到2会直接ACK=6给A，这个的意思就是说2拿到后，345也收到了，直接给6就ok，如下图：\n\n<img src=\"https://coolshell.cn/wp-content/uploads/2014/05/FASTIncast021.png\" />\n\n上面说的只是一种特别简单的方案，目前，linux2.4之后，采用了一种更先进的方式，有想了解的可以走[这里](https://coolshell.cn/articles/11564.html)\n\n\n### 攻击\n典型的场景是DDOS攻击，也可以说是tcp的SYN Flood攻击，又叫洪水攻击；\n根据上面的分析，我们知道tcp的握手环节是比较耗时的，当client端发起连接请求的时候，server端会回应，然后等待client的最终确认信息，默认情况下的linux会等待1-63s这样，最长是63之后才会主动断开，之前这段时间内属于半连接的状态，服务器不会丢弃到，而是会等，试想如果有一个人突然想你的server瞬间之内发送了几千万个连接请求，但是对服务端的响应不做理睬，这样很容易就导致我们正常的tcp连接进不去，从而出现服务拒绝的情况，而他只需要一个简简单单的脚本去给你丢包就可以了，这种情况就会导致服务器对正常的客户端表现为宕机。。此种攻击的成本比较低，但是防护却特别麻烦，因为你必须要保证正常的不能因为访问次数的提高而出现拒绝。\n\n另外一个没有这个情况严重的攻击是[ACK Flood攻击](http://blog.51cto.com/changxy/751958),有兴趣的可以自行去查看。\n\n### TCP是个巨复杂的协议，我们今天通过一次抓包了解了三次握手，四次挥手，滑动窗口。超时重传机制和典型的tcp攻击方式，期待下次继续。。\n","source":"_posts/关于tcp.md","raw":"---\ntitle: 浅谈tcp\ndate: 2018-12-15 14:31:54\ntags: 网络\n---\n\n> 经常在前端的面试群中发现有人会碰到面试官去询问tcp的握手和挥手问题，诸如你了解tcp吗，解释一下tcp的三次握手和四次挥手，倒不是说这些问题没用吧，但是感觉其实知道不知道这个，对前端的意义(纯属个人扯淡想法)不是特别的大，所以我认为如果只是简单的问这2个问题，是没有任何意义的(不如不问，哈哈哈)，but 记得在上家公司的时候有个老哥说过，网络通信其实还是蛮重要的，毕竟我们现在无论是工作还是生活基本都处于互联网之中，尤其作为开发者基本上每天都在和http请求打交道，so 了解网络传输的原理还是有必要的，下面我们稍微深入的来看下网络传输的内容。\n\n### base\nOSI(Open Systems Interconncection，开放系统互联)网络分层\n\n 7.应用层(Application)\n 6.表示层(Presentation)\n 5.会话层(Session)\n 4.传输层(Transport)\n 3.网络层(Network)    -- 路由器\n 2.数据链路层(Data Link) -- 交换机\n 1.物理层(Physical) -- 网卡、集线器（Hub） \n \n基础内容不做过多的讲解，有需要的可以[出门右转](https://juejin.im/post/5a98e1f7f265da237410694e)\nok 我们今天主要关注的是tcp层的内容，下面的内容，如果有兴趣建议大家按照步骤实际操作去看看，首先介绍一个工具wireshark，这个工具可以帮助我们抓到tcp以及更底层的包，下载到[这里](https://www.wireshark.org/),打开后有个download，下载自己系统能用的就好，一路安装到全部完成，接下来我们开始一次实战抓包。\n\n### 抓包\n我这里利用了[百度的首页](https://www.baidu.com)做了一次抓包实验，首先要设置一个过滤\n<img src=\"https://i.loli.net/2019/06/20/5d0b002eb8a2045644.png\">\n你可以选择http 和 tcp 或者 tcp only\n<img src=\"https://i.loli.net/2019/06/20/5d0b002ebd5ca21200.png\">\n然后到控制台中去ping 一下百度首页的ip\n<img src=\"https://i.loli.net/2019/06/20/5d0b0fcfdbf5175380.png\">\n\nok 看到ip是180.97.33.108\n\n然后我们到wireshark中设置一下查询的ip\n<img src=\"https://i.loli.net/2019/06/20/5d0b10272289a28985.png\">\n到chrome中打开百度的首页，然后就能看到tcp的传输信息了\n<img src=\"https://i.loli.net/2019/06/20/5d0b002dea98659548.png\">\n内容有点多，我们通过这个内容来观察一下tcp的传输过程\n\n### tcp base\n先看下tcp的头部报文结构\n<img src=\"https://i.loli.net/2019/06/20/5d0b10e34ba3c74469.png\"/>\n1.tcp协议层是不关心ip的，具体ip的定位是由ip层来决定的，但是tcp层需要确定端口号，所以他会携带source 和 destination的port信息，以便能找到对应的端口号；\n\n2.sequence number 实际中使用的SEQ，也就是序号，这个序号起了很重要的作用，我们都知道tcp和udp最大的区别在于tcp是稳定并且有序的，其中seq就可以保证有序，当A向B发送一个数据包的时候，seq会叠加，每一个传输方在传送数据的时候都会带上这个信息，另一端能按照这个序号来排序收到信息的顺序，从未保证了信息的传递是有序的，也能通过它来确认有没有出现丢包的情况；另外要注意的是当有数据需要发送的时候，seq会随该序列号为原点，对自己将要发送的每个字节的数据进行编号，比如当前seq = 10，本次要发送的数据包大小是200字节，那么实际发送的时候会更新seq=210，以便保证传输的数据的顺序；\n\n3.acknowledge number，实际中使用的ACK，是另一端对对方seq的一个回应，一般会把对方给的seq+1然后下一次发包的时候带上，这样的话对方就知道我们是收到前面的消息的；\n\n4.windown代表的是滑动窗口，实际中用win来表示，win的大小很重要，win越大的传输越快，因为win的大小直接决定了某一端一次可以同时发送多少个数据包，而不用等待对方的应答ACK回来，但是win会随着每一个数据包的发送而变小(稍后解释)；\n\n5.reserved 是tcp传输很重要的角色，标志位，响应方会根据对方给的信号执行对应的操作，比如执行断开连接的时候一般都是使用FIN标志位；\n\n基础内容不做过多介绍，不懂的可以移步[这里]先看下概念，后面我们会结合实际来介绍(https://blog.csdn.net/jijianshuai/article/details/80883091)\n\n\n\n### 三次握手(敲黑板)\n<img src=\"https://i.loli.net/2019/06/20/5d0b002f1d28520287.png\">\n观察前几次传输，TLS类型的我们可以先忽略，它是处理ssl加密的内容，有兴趣的可以自己去google，重点看前三次的tcp，第一次是我们自己的ip向百度的服务器ip发了第一个包，seq=0，起始的数据信号是0，win=65535代表我这边的窗口大小是65535，len=0代表我这边希望接受的包的大小长度是0，mss代表我这边本次传输能接收的最大包的内容是1460(其余的我们暂时不用关心)。下面我们模拟一下对话内容：\n\nA：B，你好，我是A 请求建立连接，我的seq是0，我的win是65535，我希望本次回应我的内容长度len为0，我本次能接收的最大内容是1460，over；\nB：A，你也好，收到你的信息了，我是B，我本次的seq是0（注意，双方的序号是独立计算的，这里都从0开始的），我回应你的ack是1(A的seq+1，代表我收到你seq是0的消息了)，我的窗口大小是8192，我希望你回应我本次消息的len也是0，我这边能接收的最大回应大小是1452，over；\nA：好的，我收到你的回应了，我现在给你发送的seq是1(上一次是0，这次是1)，我回应你的ack是1(B的seq+1)，我当前的窗口大小是25984，我希望的回应长度是0；我们建立好连接了，over；\n\n到这里，完整的三次握手就结束了，后面就可以执行别的数据传输了，到这里，不知道有没有想过，为什么确定一次连接需要三次握手，不是1次，也不是2次，也不是4次，\n\n首先，1次肯定不行，1次的话 一方无法确认另一方的情况，所以最少都是2次起步，\n\n2次：\nA：喂喂喂，我是A，你听的到吗？\nB：在在在，我能听到，我是B，你能听到我吗?\nA：(听到了，老子不想理你)\nB：喂喂喂？听不听到？我X，对面死了，我挂了。。\n\n4次：\nA：喂喂喂，我是A，你听的到吗？\nB：在在在，我能听到，我是B，你能听到我吗?\nA：听到了，你呢？你能听到吗？\nB：？？你是智障？我不是说了我能听到吗，不想跟xx说话。。。\n\n所以最合理的还是3次：\n\nA：喂喂喂，我是A，你听的到吗？\nB：在在在，我能听到，我是B，你能听到我吗?\nA：听到了。我们今天去钓鱼吧。。balabala\n\nso，就是这样，其实不是不能更多，但是可靠的同时，还要考虑性能和时间问题，所以，目前公认的握手次数还是三次比较合理。\n\n\n### 四次挥手\n\n我们知道tcp的连接是全双工的，A和B是可以互相通信的，不理解的话，可以想想打电话（类比，不要当真），打电话的场景就是单双工的，因为同一时间只能一个人说话，另一个人听，如果2个人一起说话，那谁都听不清楚了，没有意义，但是tcp是全双工的，就是A 正在给 B发信息的同时，B也在给A发信息，所以当断开的时候，必须要求双方都得知道，如果只有一方知道，肯定不行，因此，断开的时候，就需要下面这样：\n\n<img src=\"http://hi.csdn.net/attachment/201108/7/0_1312718564tZXD.gif\"/>\n\nA：B，不好意思，我这边需要关闭连接了，你准备一下？(发了一个fin信号给B，等待回应)\nB：好的A，我收到你的关闭信号了，我还有数据没发好，你等我下（回应A，带回去ACK的最后一个信息，失败可以重发）\nB：A老弟，我好了，我可以关闭了，给你最后说一下，等下你回应我的话，我就直接关了；\nA：好的老哥，我回应你一下，你收到就关闭吧，不用理我(发完这条信息后，进入time_wait状态)\nB：(收到ack信息，直接就关闭了)，此过程不产生数据的交互，不算挥手次数\nA：等待2MSL(最大报文段生存时间)后，B没东西给过来，我也关了；\n\n到这里4次挥手就结束了，2个问题：\n\n1.为什么握手需要三次，而挥手却需要四次？\n\n握手的时候，A和B打个招呼，B可以直接把自己的SYN信息和对A的回应ACK信息一起带上，但是挥手的时候，A说我要断开了，B还没发完最后的数据，因此需要先回应一下A，我收到你的断开的请求了，但是你要等我把最后的内容给你，所以这里分开了2步：\n    （1）回应A；\n    （2）发送自己的最后一个数据\n\n2.为什么A进入TIME_WAIT需要等待最大报文段生存的时间后，才能关闭？\n\n原因是，担心网络不可靠而导致的丢包，最后一个回应B的ACK万一丢了怎么办，在这个时间内，A是可以重新发包的，但是超过了最大等待时间的话，就算收不到也没用了，所以就可以关闭了。\n\n\n### 如何理解滑动窗口的作用？\n从上面的内容，我们简单了解了三次握手和四次挥手的内容，然后也知道了一些报文字段的意义，但是网络本身是不稳定的，也就是说中间无法保证包一定会到对面，那么tcp是如何在尽可能少的时间内实现稳定和有序传输的？\n\n我们知道SYN信息中会带上自己的seq，序号，这样可以保证另一方接受到后知道如何排序，但是如果发送必须都是同步的，想象，A 给 B发送的时候，需要给B 1，2，3，4，5个包，发了1后，死等1的ack回来，再给2，死等2的ack回来，在linux下每个tcp的timeout最大是`2^5 - 1 = 63`s(默认的retrytime是5次)的时间，因为当发了一个包出去后，在一定时间内没收到ACK回应，为了确认不能丢包的问题，会启动重试机制，重试5次，它们的延迟分别是：1 秒、3 秒、7 秒、15 秒、31 秒，其中31s是前5次重试的时间1+2+4+8+16=31s，最后的32s是等待最后一次重试也超时(等待的时间是2的N次方秒)，所以一共就是63s，如果一个一个等，是不是有点太恐怖了，万一网络环境比较差，所以为了能在不丢包的情况下，尽量减少时间的损耗，引入了滑动窗口的概念，window\n\n由于窗口由16位bit所定义，所以接收端TCP，窗口能最大提供65535个字节的缓冲，其实这个滑动窗口主要就是做限流和缓冲用的，每一个tcp传输中的win提供的是对方的窗口大小，当A向B发数据的时候，超过B的win长度的数据会被丢掉，同时窗口还可以提高发送数据的效率，通过类似于并发的行为，如下图：\n<img src=\"https://i.loli.net/2019/06/20/5d0b002edb09192328.png\">\n\n可以看到A向B连续发了3条数据，但是回应B的ACK没有变，也就是说都是回应同一个B的同一个响应，但是A自己的seq更新了3次，先是1，然后是69最后是1521，说明这三个包是连续几乎同时发出去的，实际上只要当前数据包的大小不超过对方的window大小，就可以连续发的，接着看：\n\n<img src=\"https://i.loli.net/2019/06/20/5d0b002ee0eee77060.png\">\n这四个是B响应给A的数据包，可以看到都是在响应A给的数据包，注意看因为A连续发了好几条，B可能一下反应不过来，所以B会把这些信息放到缓冲区，但是放的数据越多，那么自己的缓冲区就越小，就是通过B自己的win来体现，我们可以看到B的win再连续变小，说明它还没处理好，到第4条信息的时候，我们看到B给了一个信息叫WINDOW UPDATE 然后发现B的win变大了，这就意味着它已经处理好A之前连续发的几个数据包了，然后就会重新更新自己的win的大小，要注意的是当tcp一端的win接近或者等于0的时候，传输将会停止，直到window update更新说buffer已经清空了，传输才会继续。\n\n\n### 丢包？\n看下面这个图\n<img src=\"https://i.loli.net/2019/06/20/5d0b11eb5c31665131.png\">\n明显能看到ACK是连续变大的，再一次链接中，不可能存在说先ACK=3922然后ACK=3913，这样的话另一端在收到3922的时候就认为之前的全部接收到了，实际上3913还没收到，所以，要注意SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包。那么，考虑以下情况，假如A给的分别是1，2，3，4到5 5个包，B这边收到1，2，Ack一个3（代表收到1，2了），然后3丢了，4和5收到了，能直接ACK = 6吗？当然不行，这样的话tcp就是不稳定的了，所以tcp会有超时重传，当1和2到了后，3没到，但是4和5到了，这个时候另一端回3，表示我这边只拿到1和2了，但是这种情况下有一个很严重的问题，就是其实4和5都到了，但是另一端没收到4和5的回应，会认为4和5也丢了，于是过了一会又开始重新传3，4，5，这样的话浪费了带宽，所以超时重传有2种方案：\n\n1.timeout后只重新传3；\n2.timeout后重新给3，4，5；\n\n2种方案有好有坏，第一种比较慢，第二种浪费带宽，所以tcp引入了一种快速超时重试机制(Fast Retransmit算法)，不以时间计算，而以数据做驱动重新传送，如果包没有连续到达，比如1到了，2没到，3，4，5也到了，这个时候，B始终返回ACK=2，代表只确认1，然后A就知道2没到，重新发2，但是B一旦收到2会直接ACK=6给A，这个的意思就是说2拿到后，345也收到了，直接给6就ok，如下图：\n\n<img src=\"https://coolshell.cn/wp-content/uploads/2014/05/FASTIncast021.png\" />\n\n上面说的只是一种特别简单的方案，目前，linux2.4之后，采用了一种更先进的方式，有想了解的可以走[这里](https://coolshell.cn/articles/11564.html)\n\n\n### 攻击\n典型的场景是DDOS攻击，也可以说是tcp的SYN Flood攻击，又叫洪水攻击；\n根据上面的分析，我们知道tcp的握手环节是比较耗时的，当client端发起连接请求的时候，server端会回应，然后等待client的最终确认信息，默认情况下的linux会等待1-63s这样，最长是63之后才会主动断开，之前这段时间内属于半连接的状态，服务器不会丢弃到，而是会等，试想如果有一个人突然想你的server瞬间之内发送了几千万个连接请求，但是对服务端的响应不做理睬，这样很容易就导致我们正常的tcp连接进不去，从而出现服务拒绝的情况，而他只需要一个简简单单的脚本去给你丢包就可以了，这种情况就会导致服务器对正常的客户端表现为宕机。。此种攻击的成本比较低，但是防护却特别麻烦，因为你必须要保证正常的不能因为访问次数的提高而出现拒绝。\n\n另外一个没有这个情况严重的攻击是[ACK Flood攻击](http://blog.51cto.com/changxy/751958),有兴趣的可以自行去查看。\n\n### TCP是个巨复杂的协议，我们今天通过一次抓包了解了三次握手，四次挥手，滑动窗口。超时重传机制和典型的tcp攻击方式，期待下次继续。。\n","slug":"关于tcp","published":1,"updated":"2019-06-20T04:57:32.675Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx4afn4g0002q67wfgt9ywur","content":"<blockquote>\n<p>经常在前端的面试群中发现有人会碰到面试官去询问tcp的握手和挥手问题，诸如你了解tcp吗，解释一下tcp的三次握手和四次挥手，倒不是说这些问题没用吧，但是感觉其实知道不知道这个，对前端的意义(纯属个人扯淡想法)不是特别的大，所以我认为如果只是简单的问这2个问题，是没有任何意义的(不如不问，哈哈哈)，but 记得在上家公司的时候有个老哥说过，网络通信其实还是蛮重要的，毕竟我们现在无论是工作还是生活基本都处于互联网之中，尤其作为开发者基本上每天都在和http请求打交道，so 了解网络传输的原理还是有必要的，下面我们稍微深入的来看下网络传输的内容。</p>\n</blockquote>\n<h3 id=\"base\"><a href=\"#base\" class=\"headerlink\" title=\"base\"></a>base</h3><p>OSI(Open Systems Interconncection，开放系统互联)网络分层</p>\n<p> 7.应用层(Application)<br> 6.表示层(Presentation)<br> 5.会话层(Session)<br> 4.传输层(Transport)<br> 3.网络层(Network)    – 路由器<br> 2.数据链路层(Data Link) – 交换机<br> 1.物理层(Physical) – 网卡、集线器（Hub） </p>\n<p>基础内容不做过多的讲解，有需要的可以<a href=\"https://juejin.im/post/5a98e1f7f265da237410694e\" target=\"_blank\" rel=\"noopener\">出门右转</a><br>ok 我们今天主要关注的是tcp层的内容，下面的内容，如果有兴趣建议大家按照步骤实际操作去看看，首先介绍一个工具wireshark，这个工具可以帮助我们抓到tcp以及更底层的包，下载到<a href=\"https://www.wireshark.org/\" target=\"_blank\" rel=\"noopener\">这里</a>,打开后有个download，下载自己系统能用的就好，一路安装到全部完成，接下来我们开始一次实战抓包。</p>\n<h3 id=\"抓包\"><a href=\"#抓包\" class=\"headerlink\" title=\"抓包\"></a>抓包</h3><p>我这里利用了<a href=\"https://www.baidu.com\" target=\"_blank\" rel=\"noopener\">百度的首页</a>做了一次抓包实验，首先要设置一个过滤<br><img src=\"https://i.loli.net/2019/06/20/5d0b002eb8a2045644.png\"><br>你可以选择http 和 tcp 或者 tcp only<br><img src=\"https://i.loli.net/2019/06/20/5d0b002ebd5ca21200.png\"><br>然后到控制台中去ping 一下百度首页的ip<br><img src=\"https://i.loli.net/2019/06/20/5d0b0fcfdbf5175380.png\"></p>\n<p>ok 看到ip是180.97.33.108</p>\n<p>然后我们到wireshark中设置一下查询的ip<br><img src=\"https://i.loli.net/2019/06/20/5d0b10272289a28985.png\"><br>到chrome中打开百度的首页，然后就能看到tcp的传输信息了<br><img src=\"https://i.loli.net/2019/06/20/5d0b002dea98659548.png\"><br>内容有点多，我们通过这个内容来观察一下tcp的传输过程</p>\n<h3 id=\"tcp-base\"><a href=\"#tcp-base\" class=\"headerlink\" title=\"tcp base\"></a>tcp base</h3><p>先看下tcp的头部报文结构<br><img src=\"https://i.loli.net/2019/06/20/5d0b10e34ba3c74469.png\"><br>1.tcp协议层是不关心ip的，具体ip的定位是由ip层来决定的，但是tcp层需要确定端口号，所以他会携带source 和 destination的port信息，以便能找到对应的端口号；</p>\n<p>2.sequence number 实际中使用的SEQ，也就是序号，这个序号起了很重要的作用，我们都知道tcp和udp最大的区别在于tcp是稳定并且有序的，其中seq就可以保证有序，当A向B发送一个数据包的时候，seq会叠加，每一个传输方在传送数据的时候都会带上这个信息，另一端能按照这个序号来排序收到信息的顺序，从未保证了信息的传递是有序的，也能通过它来确认有没有出现丢包的情况；另外要注意的是当有数据需要发送的时候，seq会随该序列号为原点，对自己将要发送的每个字节的数据进行编号，比如当前seq = 10，本次要发送的数据包大小是200字节，那么实际发送的时候会更新seq=210，以便保证传输的数据的顺序；</p>\n<p>3.acknowledge number，实际中使用的ACK，是另一端对对方seq的一个回应，一般会把对方给的seq+1然后下一次发包的时候带上，这样的话对方就知道我们是收到前面的消息的；</p>\n<p>4.windown代表的是滑动窗口，实际中用win来表示，win的大小很重要，win越大的传输越快，因为win的大小直接决定了某一端一次可以同时发送多少个数据包，而不用等待对方的应答ACK回来，但是win会随着每一个数据包的发送而变小(稍后解释)；</p>\n<p>5.reserved 是tcp传输很重要的角色，标志位，响应方会根据对方给的信号执行对应的操作，比如执行断开连接的时候一般都是使用FIN标志位；</p>\n<p>基础内容不做过多介绍，不懂的可以移步[这里]先看下概念，后面我们会结合实际来介绍(<a href=\"https://blog.csdn.net/jijianshuai/article/details/80883091\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/jijianshuai/article/details/80883091</a>)</p>\n<h3 id=\"三次握手-敲黑板\"><a href=\"#三次握手-敲黑板\" class=\"headerlink\" title=\"三次握手(敲黑板)\"></a>三次握手(敲黑板)</h3><img src=\"https://i.loli.net/2019/06/20/5d0b002f1d28520287.png\">\n观察前几次传输，TLS类型的我们可以先忽略，它是处理ssl加密的内容，有兴趣的可以自己去google，重点看前三次的tcp，第一次是我们自己的ip向百度的服务器ip发了第一个包，seq=0，起始的数据信号是0，win=65535代表我这边的窗口大小是65535，len=0代表我这边希望接受的包的大小长度是0，mss代表我这边本次传输能接收的最大包的内容是1460(其余的我们暂时不用关心)。下面我们模拟一下对话内容：\n\n<p>A：B，你好，我是A 请求建立连接，我的seq是0，我的win是65535，我希望本次回应我的内容长度len为0，我本次能接收的最大内容是1460，over；<br>B：A，你也好，收到你的信息了，我是B，我本次的seq是0（注意，双方的序号是独立计算的，这里都从0开始的），我回应你的ack是1(A的seq+1，代表我收到你seq是0的消息了)，我的窗口大小是8192，我希望你回应我本次消息的len也是0，我这边能接收的最大回应大小是1452，over；<br>A：好的，我收到你的回应了，我现在给你发送的seq是1(上一次是0，这次是1)，我回应你的ack是1(B的seq+1)，我当前的窗口大小是25984，我希望的回应长度是0；我们建立好连接了，over；</p>\n<p>到这里，完整的三次握手就结束了，后面就可以执行别的数据传输了，到这里，不知道有没有想过，为什么确定一次连接需要三次握手，不是1次，也不是2次，也不是4次，</p>\n<p>首先，1次肯定不行，1次的话 一方无法确认另一方的情况，所以最少都是2次起步，</p>\n<p>2次：<br>A：喂喂喂，我是A，你听的到吗？<br>B：在在在，我能听到，我是B，你能听到我吗?<br>A：(听到了，老子不想理你)<br>B：喂喂喂？听不听到？我X，对面死了，我挂了。。</p>\n<p>4次：<br>A：喂喂喂，我是A，你听的到吗？<br>B：在在在，我能听到，我是B，你能听到我吗?<br>A：听到了，你呢？你能听到吗？<br>B：？？你是智障？我不是说了我能听到吗，不想跟xx说话。。。</p>\n<p>所以最合理的还是3次：</p>\n<p>A：喂喂喂，我是A，你听的到吗？<br>B：在在在，我能听到，我是B，你能听到我吗?<br>A：听到了。我们今天去钓鱼吧。。balabala</p>\n<p>so，就是这样，其实不是不能更多，但是可靠的同时，还要考虑性能和时间问题，所以，目前公认的握手次数还是三次比较合理。</p>\n<h3 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h3><p>我们知道tcp的连接是全双工的，A和B是可以互相通信的，不理解的话，可以想想打电话（类比，不要当真），打电话的场景就是单双工的，因为同一时间只能一个人说话，另一个人听，如果2个人一起说话，那谁都听不清楚了，没有意义，但是tcp是全双工的，就是A 正在给 B发信息的同时，B也在给A发信息，所以当断开的时候，必须要求双方都得知道，如果只有一方知道，肯定不行，因此，断开的时候，就需要下面这样：</p>\n<img src=\"http://hi.csdn.net/attachment/201108/7/0_1312718564tZXD.gif\">\n\n<p>A：B，不好意思，我这边需要关闭连接了，你准备一下？(发了一个fin信号给B，等待回应)<br>B：好的A，我收到你的关闭信号了，我还有数据没发好，你等我下（回应A，带回去ACK的最后一个信息，失败可以重发）<br>B：A老弟，我好了，我可以关闭了，给你最后说一下，等下你回应我的话，我就直接关了；<br>A：好的老哥，我回应你一下，你收到就关闭吧，不用理我(发完这条信息后，进入time_wait状态)<br>B：(收到ack信息，直接就关闭了)，此过程不产生数据的交互，不算挥手次数<br>A：等待2MSL(最大报文段生存时间)后，B没东西给过来，我也关了；</p>\n<p>到这里4次挥手就结束了，2个问题：</p>\n<p>1.为什么握手需要三次，而挥手却需要四次？</p>\n<p>握手的时候，A和B打个招呼，B可以直接把自己的SYN信息和对A的回应ACK信息一起带上，但是挥手的时候，A说我要断开了，B还没发完最后的数据，因此需要先回应一下A，我收到你的断开的请求了，但是你要等我把最后的内容给你，所以这里分开了2步：<br>    （1）回应A；<br>    （2）发送自己的最后一个数据</p>\n<p>2.为什么A进入TIME_WAIT需要等待最大报文段生存的时间后，才能关闭？</p>\n<p>原因是，担心网络不可靠而导致的丢包，最后一个回应B的ACK万一丢了怎么办，在这个时间内，A是可以重新发包的，但是超过了最大等待时间的话，就算收不到也没用了，所以就可以关闭了。</p>\n<h3 id=\"如何理解滑动窗口的作用？\"><a href=\"#如何理解滑动窗口的作用？\" class=\"headerlink\" title=\"如何理解滑动窗口的作用？\"></a>如何理解滑动窗口的作用？</h3><p>从上面的内容，我们简单了解了三次握手和四次挥手的内容，然后也知道了一些报文字段的意义，但是网络本身是不稳定的，也就是说中间无法保证包一定会到对面，那么tcp是如何在尽可能少的时间内实现稳定和有序传输的？</p>\n<p>我们知道SYN信息中会带上自己的seq，序号，这样可以保证另一方接受到后知道如何排序，但是如果发送必须都是同步的，想象，A 给 B发送的时候，需要给B 1，2，3，4，5个包，发了1后，死等1的ack回来，再给2，死等2的ack回来，在linux下每个tcp的timeout最大是<code>2^5 - 1 = 63</code>s(默认的retrytime是5次)的时间，因为当发了一个包出去后，在一定时间内没收到ACK回应，为了确认不能丢包的问题，会启动重试机制，重试5次，它们的延迟分别是：1 秒、3 秒、7 秒、15 秒、31 秒，其中31s是前5次重试的时间1+2+4+8+16=31s，最后的32s是等待最后一次重试也超时(等待的时间是2的N次方秒)，所以一共就是63s，如果一个一个等，是不是有点太恐怖了，万一网络环境比较差，所以为了能在不丢包的情况下，尽量减少时间的损耗，引入了滑动窗口的概念，window</p>\n<p>由于窗口由16位bit所定义，所以接收端TCP，窗口能最大提供65535个字节的缓冲，其实这个滑动窗口主要就是做限流和缓冲用的，每一个tcp传输中的win提供的是对方的窗口大小，当A向B发数据的时候，超过B的win长度的数据会被丢掉，同时窗口还可以提高发送数据的效率，通过类似于并发的行为，如下图：<br><img src=\"https://i.loli.net/2019/06/20/5d0b002edb09192328.png\"></p>\n<p>可以看到A向B连续发了3条数据，但是回应B的ACK没有变，也就是说都是回应同一个B的同一个响应，但是A自己的seq更新了3次，先是1，然后是69最后是1521，说明这三个包是连续几乎同时发出去的，实际上只要当前数据包的大小不超过对方的window大小，就可以连续发的，接着看：</p>\n<img src=\"https://i.loli.net/2019/06/20/5d0b002ee0eee77060.png\">\n这四个是B响应给A的数据包，可以看到都是在响应A给的数据包，注意看因为A连续发了好几条，B可能一下反应不过来，所以B会把这些信息放到缓冲区，但是放的数据越多，那么自己的缓冲区就越小，就是通过B自己的win来体现，我们可以看到B的win再连续变小，说明它还没处理好，到第4条信息的时候，我们看到B给了一个信息叫WINDOW UPDATE 然后发现B的win变大了，这就意味着它已经处理好A之前连续发的几个数据包了，然后就会重新更新自己的win的大小，要注意的是当tcp一端的win接近或者等于0的时候，传输将会停止，直到window update更新说buffer已经清空了，传输才会继续。\n\n\n<h3 id=\"丢包？\"><a href=\"#丢包？\" class=\"headerlink\" title=\"丢包？\"></a>丢包？</h3><p>看下面这个图<br><img src=\"https://i.loli.net/2019/06/20/5d0b11eb5c31665131.png\"><br>明显能看到ACK是连续变大的，再一次链接中，不可能存在说先ACK=3922然后ACK=3913，这样的话另一端在收到3922的时候就认为之前的全部接收到了，实际上3913还没收到，所以，要注意SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包。那么，考虑以下情况，假如A给的分别是1，2，3，4到5 5个包，B这边收到1，2，Ack一个3（代表收到1，2了），然后3丢了，4和5收到了，能直接ACK = 6吗？当然不行，这样的话tcp就是不稳定的了，所以tcp会有超时重传，当1和2到了后，3没到，但是4和5到了，这个时候另一端回3，表示我这边只拿到1和2了，但是这种情况下有一个很严重的问题，就是其实4和5都到了，但是另一端没收到4和5的回应，会认为4和5也丢了，于是过了一会又开始重新传3，4，5，这样的话浪费了带宽，所以超时重传有2种方案：</p>\n<p>1.timeout后只重新传3；<br>2.timeout后重新给3，4，5；</p>\n<p>2种方案有好有坏，第一种比较慢，第二种浪费带宽，所以tcp引入了一种快速超时重试机制(Fast Retransmit算法)，不以时间计算，而以数据做驱动重新传送，如果包没有连续到达，比如1到了，2没到，3，4，5也到了，这个时候，B始终返回ACK=2，代表只确认1，然后A就知道2没到，重新发2，但是B一旦收到2会直接ACK=6给A，这个的意思就是说2拿到后，345也收到了，直接给6就ok，如下图：</p>\n<img src=\"https://coolshell.cn/wp-content/uploads/2014/05/FASTIncast021.png\">\n\n<p>上面说的只是一种特别简单的方案，目前，linux2.4之后，采用了一种更先进的方式，有想了解的可以走<a href=\"https://coolshell.cn/articles/11564.html\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h3 id=\"攻击\"><a href=\"#攻击\" class=\"headerlink\" title=\"攻击\"></a>攻击</h3><p>典型的场景是DDOS攻击，也可以说是tcp的SYN Flood攻击，又叫洪水攻击；<br>根据上面的分析，我们知道tcp的握手环节是比较耗时的，当client端发起连接请求的时候，server端会回应，然后等待client的最终确认信息，默认情况下的linux会等待1-63s这样，最长是63之后才会主动断开，之前这段时间内属于半连接的状态，服务器不会丢弃到，而是会等，试想如果有一个人突然想你的server瞬间之内发送了几千万个连接请求，但是对服务端的响应不做理睬，这样很容易就导致我们正常的tcp连接进不去，从而出现服务拒绝的情况，而他只需要一个简简单单的脚本去给你丢包就可以了，这种情况就会导致服务器对正常的客户端表现为宕机。。此种攻击的成本比较低，但是防护却特别麻烦，因为你必须要保证正常的不能因为访问次数的提高而出现拒绝。</p>\n<p>另外一个没有这个情况严重的攻击是<a href=\"http://blog.51cto.com/changxy/751958\" target=\"_blank\" rel=\"noopener\">ACK Flood攻击</a>,有兴趣的可以自行去查看。</p>\n<h3 id=\"TCP是个巨复杂的协议，我们今天通过一次抓包了解了三次握手，四次挥手，滑动窗口。超时重传机制和典型的tcp攻击方式，期待下次继续。。\"><a href=\"#TCP是个巨复杂的协议，我们今天通过一次抓包了解了三次握手，四次挥手，滑动窗口。超时重传机制和典型的tcp攻击方式，期待下次继续。。\" class=\"headerlink\" title=\"TCP是个巨复杂的协议，我们今天通过一次抓包了解了三次握手，四次挥手，滑动窗口。超时重传机制和典型的tcp攻击方式，期待下次继续。。\"></a>TCP是个巨复杂的协议，我们今天通过一次抓包了解了三次握手，四次挥手，滑动窗口。超时重传机制和典型的tcp攻击方式，期待下次继续。。</h3>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>经常在前端的面试群中发现有人会碰到面试官去询问tcp的握手和挥手问题，诸如你了解tcp吗，解释一下tcp的三次握手和四次挥手，倒不是说这些问题没用吧，但是感觉其实知道不知道这个，对前端的意义(纯属个人扯淡想法)不是特别的大，所以我认为如果只是简单的问这2个问题，是没有任何意义的(不如不问，哈哈哈)，but 记得在上家公司的时候有个老哥说过，网络通信其实还是蛮重要的，毕竟我们现在无论是工作还是生活基本都处于互联网之中，尤其作为开发者基本上每天都在和http请求打交道，so 了解网络传输的原理还是有必要的，下面我们稍微深入的来看下网络传输的内容。</p>\n</blockquote>\n<h3 id=\"base\"><a href=\"#base\" class=\"headerlink\" title=\"base\"></a>base</h3><p>OSI(Open Systems Interconncection，开放系统互联)网络分层</p>\n<p> 7.应用层(Application)<br> 6.表示层(Presentation)<br> 5.会话层(Session)<br> 4.传输层(Transport)<br> 3.网络层(Network)    – 路由器<br> 2.数据链路层(Data Link) – 交换机<br> 1.物理层(Physical) – 网卡、集线器（Hub） </p>\n<p>基础内容不做过多的讲解，有需要的可以<a href=\"https://juejin.im/post/5a98e1f7f265da237410694e\" target=\"_blank\" rel=\"noopener\">出门右转</a><br>ok 我们今天主要关注的是tcp层的内容，下面的内容，如果有兴趣建议大家按照步骤实际操作去看看，首先介绍一个工具wireshark，这个工具可以帮助我们抓到tcp以及更底层的包，下载到<a href=\"https://www.wireshark.org/\" target=\"_blank\" rel=\"noopener\">这里</a>,打开后有个download，下载自己系统能用的就好，一路安装到全部完成，接下来我们开始一次实战抓包。</p>\n<h3 id=\"抓包\"><a href=\"#抓包\" class=\"headerlink\" title=\"抓包\"></a>抓包</h3><p>我这里利用了<a href=\"https://www.baidu.com\" target=\"_blank\" rel=\"noopener\">百度的首页</a>做了一次抓包实验，首先要设置一个过滤<br><img src=\"https://i.loli.net/2019/06/20/5d0b002eb8a2045644.png\"><br>你可以选择http 和 tcp 或者 tcp only<br><img src=\"https://i.loli.net/2019/06/20/5d0b002ebd5ca21200.png\"><br>然后到控制台中去ping 一下百度首页的ip<br><img src=\"https://i.loli.net/2019/06/20/5d0b0fcfdbf5175380.png\"></p>\n<p>ok 看到ip是180.97.33.108</p>\n<p>然后我们到wireshark中设置一下查询的ip<br><img src=\"https://i.loli.net/2019/06/20/5d0b10272289a28985.png\"><br>到chrome中打开百度的首页，然后就能看到tcp的传输信息了<br><img src=\"https://i.loli.net/2019/06/20/5d0b002dea98659548.png\"><br>内容有点多，我们通过这个内容来观察一下tcp的传输过程</p>\n<h3 id=\"tcp-base\"><a href=\"#tcp-base\" class=\"headerlink\" title=\"tcp base\"></a>tcp base</h3><p>先看下tcp的头部报文结构<br><img src=\"https://i.loli.net/2019/06/20/5d0b10e34ba3c74469.png\"><br>1.tcp协议层是不关心ip的，具体ip的定位是由ip层来决定的，但是tcp层需要确定端口号，所以他会携带source 和 destination的port信息，以便能找到对应的端口号；</p>\n<p>2.sequence number 实际中使用的SEQ，也就是序号，这个序号起了很重要的作用，我们都知道tcp和udp最大的区别在于tcp是稳定并且有序的，其中seq就可以保证有序，当A向B发送一个数据包的时候，seq会叠加，每一个传输方在传送数据的时候都会带上这个信息，另一端能按照这个序号来排序收到信息的顺序，从未保证了信息的传递是有序的，也能通过它来确认有没有出现丢包的情况；另外要注意的是当有数据需要发送的时候，seq会随该序列号为原点，对自己将要发送的每个字节的数据进行编号，比如当前seq = 10，本次要发送的数据包大小是200字节，那么实际发送的时候会更新seq=210，以便保证传输的数据的顺序；</p>\n<p>3.acknowledge number，实际中使用的ACK，是另一端对对方seq的一个回应，一般会把对方给的seq+1然后下一次发包的时候带上，这样的话对方就知道我们是收到前面的消息的；</p>\n<p>4.windown代表的是滑动窗口，实际中用win来表示，win的大小很重要，win越大的传输越快，因为win的大小直接决定了某一端一次可以同时发送多少个数据包，而不用等待对方的应答ACK回来，但是win会随着每一个数据包的发送而变小(稍后解释)；</p>\n<p>5.reserved 是tcp传输很重要的角色，标志位，响应方会根据对方给的信号执行对应的操作，比如执行断开连接的时候一般都是使用FIN标志位；</p>\n<p>基础内容不做过多介绍，不懂的可以移步[这里]先看下概念，后面我们会结合实际来介绍(<a href=\"https://blog.csdn.net/jijianshuai/article/details/80883091\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/jijianshuai/article/details/80883091</a>)</p>\n<h3 id=\"三次握手-敲黑板\"><a href=\"#三次握手-敲黑板\" class=\"headerlink\" title=\"三次握手(敲黑板)\"></a>三次握手(敲黑板)</h3><img src=\"https://i.loli.net/2019/06/20/5d0b002f1d28520287.png\">\n观察前几次传输，TLS类型的我们可以先忽略，它是处理ssl加密的内容，有兴趣的可以自己去google，重点看前三次的tcp，第一次是我们自己的ip向百度的服务器ip发了第一个包，seq=0，起始的数据信号是0，win=65535代表我这边的窗口大小是65535，len=0代表我这边希望接受的包的大小长度是0，mss代表我这边本次传输能接收的最大包的内容是1460(其余的我们暂时不用关心)。下面我们模拟一下对话内容：\n\n<p>A：B，你好，我是A 请求建立连接，我的seq是0，我的win是65535，我希望本次回应我的内容长度len为0，我本次能接收的最大内容是1460，over；<br>B：A，你也好，收到你的信息了，我是B，我本次的seq是0（注意，双方的序号是独立计算的，这里都从0开始的），我回应你的ack是1(A的seq+1，代表我收到你seq是0的消息了)，我的窗口大小是8192，我希望你回应我本次消息的len也是0，我这边能接收的最大回应大小是1452，over；<br>A：好的，我收到你的回应了，我现在给你发送的seq是1(上一次是0，这次是1)，我回应你的ack是1(B的seq+1)，我当前的窗口大小是25984，我希望的回应长度是0；我们建立好连接了，over；</p>\n<p>到这里，完整的三次握手就结束了，后面就可以执行别的数据传输了，到这里，不知道有没有想过，为什么确定一次连接需要三次握手，不是1次，也不是2次，也不是4次，</p>\n<p>首先，1次肯定不行，1次的话 一方无法确认另一方的情况，所以最少都是2次起步，</p>\n<p>2次：<br>A：喂喂喂，我是A，你听的到吗？<br>B：在在在，我能听到，我是B，你能听到我吗?<br>A：(听到了，老子不想理你)<br>B：喂喂喂？听不听到？我X，对面死了，我挂了。。</p>\n<p>4次：<br>A：喂喂喂，我是A，你听的到吗？<br>B：在在在，我能听到，我是B，你能听到我吗?<br>A：听到了，你呢？你能听到吗？<br>B：？？你是智障？我不是说了我能听到吗，不想跟xx说话。。。</p>\n<p>所以最合理的还是3次：</p>\n<p>A：喂喂喂，我是A，你听的到吗？<br>B：在在在，我能听到，我是B，你能听到我吗?<br>A：听到了。我们今天去钓鱼吧。。balabala</p>\n<p>so，就是这样，其实不是不能更多，但是可靠的同时，还要考虑性能和时间问题，所以，目前公认的握手次数还是三次比较合理。</p>\n<h3 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h3><p>我们知道tcp的连接是全双工的，A和B是可以互相通信的，不理解的话，可以想想打电话（类比，不要当真），打电话的场景就是单双工的，因为同一时间只能一个人说话，另一个人听，如果2个人一起说话，那谁都听不清楚了，没有意义，但是tcp是全双工的，就是A 正在给 B发信息的同时，B也在给A发信息，所以当断开的时候，必须要求双方都得知道，如果只有一方知道，肯定不行，因此，断开的时候，就需要下面这样：</p>\n<img src=\"http://hi.csdn.net/attachment/201108/7/0_1312718564tZXD.gif\">\n\n<p>A：B，不好意思，我这边需要关闭连接了，你准备一下？(发了一个fin信号给B，等待回应)<br>B：好的A，我收到你的关闭信号了，我还有数据没发好，你等我下（回应A，带回去ACK的最后一个信息，失败可以重发）<br>B：A老弟，我好了，我可以关闭了，给你最后说一下，等下你回应我的话，我就直接关了；<br>A：好的老哥，我回应你一下，你收到就关闭吧，不用理我(发完这条信息后，进入time_wait状态)<br>B：(收到ack信息，直接就关闭了)，此过程不产生数据的交互，不算挥手次数<br>A：等待2MSL(最大报文段生存时间)后，B没东西给过来，我也关了；</p>\n<p>到这里4次挥手就结束了，2个问题：</p>\n<p>1.为什么握手需要三次，而挥手却需要四次？</p>\n<p>握手的时候，A和B打个招呼，B可以直接把自己的SYN信息和对A的回应ACK信息一起带上，但是挥手的时候，A说我要断开了，B还没发完最后的数据，因此需要先回应一下A，我收到你的断开的请求了，但是你要等我把最后的内容给你，所以这里分开了2步：<br>    （1）回应A；<br>    （2）发送自己的最后一个数据</p>\n<p>2.为什么A进入TIME_WAIT需要等待最大报文段生存的时间后，才能关闭？</p>\n<p>原因是，担心网络不可靠而导致的丢包，最后一个回应B的ACK万一丢了怎么办，在这个时间内，A是可以重新发包的，但是超过了最大等待时间的话，就算收不到也没用了，所以就可以关闭了。</p>\n<h3 id=\"如何理解滑动窗口的作用？\"><a href=\"#如何理解滑动窗口的作用？\" class=\"headerlink\" title=\"如何理解滑动窗口的作用？\"></a>如何理解滑动窗口的作用？</h3><p>从上面的内容，我们简单了解了三次握手和四次挥手的内容，然后也知道了一些报文字段的意义，但是网络本身是不稳定的，也就是说中间无法保证包一定会到对面，那么tcp是如何在尽可能少的时间内实现稳定和有序传输的？</p>\n<p>我们知道SYN信息中会带上自己的seq，序号，这样可以保证另一方接受到后知道如何排序，但是如果发送必须都是同步的，想象，A 给 B发送的时候，需要给B 1，2，3，4，5个包，发了1后，死等1的ack回来，再给2，死等2的ack回来，在linux下每个tcp的timeout最大是<code>2^5 - 1 = 63</code>s(默认的retrytime是5次)的时间，因为当发了一个包出去后，在一定时间内没收到ACK回应，为了确认不能丢包的问题，会启动重试机制，重试5次，它们的延迟分别是：1 秒、3 秒、7 秒、15 秒、31 秒，其中31s是前5次重试的时间1+2+4+8+16=31s，最后的32s是等待最后一次重试也超时(等待的时间是2的N次方秒)，所以一共就是63s，如果一个一个等，是不是有点太恐怖了，万一网络环境比较差，所以为了能在不丢包的情况下，尽量减少时间的损耗，引入了滑动窗口的概念，window</p>\n<p>由于窗口由16位bit所定义，所以接收端TCP，窗口能最大提供65535个字节的缓冲，其实这个滑动窗口主要就是做限流和缓冲用的，每一个tcp传输中的win提供的是对方的窗口大小，当A向B发数据的时候，超过B的win长度的数据会被丢掉，同时窗口还可以提高发送数据的效率，通过类似于并发的行为，如下图：<br><img src=\"https://i.loli.net/2019/06/20/5d0b002edb09192328.png\"></p>\n<p>可以看到A向B连续发了3条数据，但是回应B的ACK没有变，也就是说都是回应同一个B的同一个响应，但是A自己的seq更新了3次，先是1，然后是69最后是1521，说明这三个包是连续几乎同时发出去的，实际上只要当前数据包的大小不超过对方的window大小，就可以连续发的，接着看：</p>\n<img src=\"https://i.loli.net/2019/06/20/5d0b002ee0eee77060.png\">\n这四个是B响应给A的数据包，可以看到都是在响应A给的数据包，注意看因为A连续发了好几条，B可能一下反应不过来，所以B会把这些信息放到缓冲区，但是放的数据越多，那么自己的缓冲区就越小，就是通过B自己的win来体现，我们可以看到B的win再连续变小，说明它还没处理好，到第4条信息的时候，我们看到B给了一个信息叫WINDOW UPDATE 然后发现B的win变大了，这就意味着它已经处理好A之前连续发的几个数据包了，然后就会重新更新自己的win的大小，要注意的是当tcp一端的win接近或者等于0的时候，传输将会停止，直到window update更新说buffer已经清空了，传输才会继续。\n\n\n<h3 id=\"丢包？\"><a href=\"#丢包？\" class=\"headerlink\" title=\"丢包？\"></a>丢包？</h3><p>看下面这个图<br><img src=\"https://i.loli.net/2019/06/20/5d0b11eb5c31665131.png\"><br>明显能看到ACK是连续变大的，再一次链接中，不可能存在说先ACK=3922然后ACK=3913，这样的话另一端在收到3922的时候就认为之前的全部接收到了，实际上3913还没收到，所以，要注意SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包。那么，考虑以下情况，假如A给的分别是1，2，3，4到5 5个包，B这边收到1，2，Ack一个3（代表收到1，2了），然后3丢了，4和5收到了，能直接ACK = 6吗？当然不行，这样的话tcp就是不稳定的了，所以tcp会有超时重传，当1和2到了后，3没到，但是4和5到了，这个时候另一端回3，表示我这边只拿到1和2了，但是这种情况下有一个很严重的问题，就是其实4和5都到了，但是另一端没收到4和5的回应，会认为4和5也丢了，于是过了一会又开始重新传3，4，5，这样的话浪费了带宽，所以超时重传有2种方案：</p>\n<p>1.timeout后只重新传3；<br>2.timeout后重新给3，4，5；</p>\n<p>2种方案有好有坏，第一种比较慢，第二种浪费带宽，所以tcp引入了一种快速超时重试机制(Fast Retransmit算法)，不以时间计算，而以数据做驱动重新传送，如果包没有连续到达，比如1到了，2没到，3，4，5也到了，这个时候，B始终返回ACK=2，代表只确认1，然后A就知道2没到，重新发2，但是B一旦收到2会直接ACK=6给A，这个的意思就是说2拿到后，345也收到了，直接给6就ok，如下图：</p>\n<img src=\"https://coolshell.cn/wp-content/uploads/2014/05/FASTIncast021.png\">\n\n<p>上面说的只是一种特别简单的方案，目前，linux2.4之后，采用了一种更先进的方式，有想了解的可以走<a href=\"https://coolshell.cn/articles/11564.html\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h3 id=\"攻击\"><a href=\"#攻击\" class=\"headerlink\" title=\"攻击\"></a>攻击</h3><p>典型的场景是DDOS攻击，也可以说是tcp的SYN Flood攻击，又叫洪水攻击；<br>根据上面的分析，我们知道tcp的握手环节是比较耗时的，当client端发起连接请求的时候，server端会回应，然后等待client的最终确认信息，默认情况下的linux会等待1-63s这样，最长是63之后才会主动断开，之前这段时间内属于半连接的状态，服务器不会丢弃到，而是会等，试想如果有一个人突然想你的server瞬间之内发送了几千万个连接请求，但是对服务端的响应不做理睬，这样很容易就导致我们正常的tcp连接进不去，从而出现服务拒绝的情况，而他只需要一个简简单单的脚本去给你丢包就可以了，这种情况就会导致服务器对正常的客户端表现为宕机。。此种攻击的成本比较低，但是防护却特别麻烦，因为你必须要保证正常的不能因为访问次数的提高而出现拒绝。</p>\n<p>另外一个没有这个情况严重的攻击是<a href=\"http://blog.51cto.com/changxy/751958\" target=\"_blank\" rel=\"noopener\">ACK Flood攻击</a>,有兴趣的可以自行去查看。</p>\n<h3 id=\"TCP是个巨复杂的协议，我们今天通过一次抓包了解了三次握手，四次挥手，滑动窗口。超时重传机制和典型的tcp攻击方式，期待下次继续。。\"><a href=\"#TCP是个巨复杂的协议，我们今天通过一次抓包了解了三次握手，四次挥手，滑动窗口。超时重传机制和典型的tcp攻击方式，期待下次继续。。\" class=\"headerlink\" title=\"TCP是个巨复杂的协议，我们今天通过一次抓包了解了三次握手，四次挥手，滑动窗口。超时重传机制和典型的tcp攻击方式，期待下次继续。。\"></a>TCP是个巨复杂的协议，我们今天通过一次抓包了解了三次握手，四次挥手，滑动窗口。超时重传机制和典型的tcp攻击方式，期待下次继续。。</h3>"},{"title":"proxy 简介","date":"2019-06-06T06:23:42.000Z","_content":"\n## 什么是Proxy\n\nproxy翻译过来的意思就是”代理“，ES6对Proxy的定位就是target对象(原对象)的基础上通过handler增加一层”拦截“，返回一个新的代理对象，之后所有在Proxy中被拦截的属性，都可以定制化一些新的流程在上面，先看一个最简单的例子\n\n```javascript\nconst target = {}; // 要被代理的原对象\n// 用于描述代理过程的handler\nconst handler = {\n  get: function (target, key, receiver) {\n    console.log(`getting ${key}!`);\n    return Reflect.get(target, key, receiver);\n  },\n  set: function (target, key, value, receiver) {\n    console.log(`setting ${key}!`);\n    return Reflect.set(target, key, value, receiver);\n  }\n}\n// obj就是一个被新的代理对象\nconst obj = new Proxy(target, handler);\nobj.a = 1 // setting a!\nconsole.log(obj.a) // getting a!\n```\n\n上面的例子中我们在target对象上架设了一层handler，其中拦截了针对target的get和set，然后我们就可以在get和set中间做一些额外的操作了\n\n\n> 注意：对Proxy对象的赋值操作也会影响到原对象target，同时对target的操作也会影响Proxy，不过直接操作原对象的话不会触发拦截的内容~\n\n```javascript\nobj.a = 1; // setting a!\nconsole.log(target.a) // 1 不会打印\"getting a!\"\n```\n\n> 注意：如果handler中没有任何拦截上的处理，那么对代理对象的操作会直接通向原对象\n\n```javascript\nconst target = {};\nconst handler = {};\nconst obj = new Proxy(target, handler);\nobj.a = 1;\nconsole.log(target.a) // 1\n```\n\n> 既然proxy也是一个对象，那么它就可以做为原型对象，所以我们把obj的原型指向到proxy上后，发现对obj的操作会找到原型上的代理对象，如果obj自己有a属性，则不会触发proxy上的get，这个应该很好理解\n\n```javascript\nconst target = {};\nconst handler = {\n    get: function(target, key){\n\t\tconsole.log(`get ${key} from ${JSON.stringify(target)}`);\n\t\treturn Reflect.get(target, key);\n\t}\n}\nconst proxy = new Proxy(target, handler);\nconst obj = Object.setPrototypeOf(obj, proxy);\nproxy.a = 1;\nconsole.log(obj.a) // get a from {\"a\": 1}\n```\n\n\n## ES6的Proxy实现了对哪些属性的拦截？\n\n> 通过上面的例子了解了Proxy的原理后，我们来看下ES6目前实现了哪些属性的拦截，以及他们分别可以做什么？\n> 下面是 Proxy 支持的拦截操作一览，一共 13 种\n1. get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy['foo'];\n2. set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值;\n3. has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。\n4. deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值;\n5. ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性;\n6. getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象;\n7. defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值;\n8. preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值;\n9. getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象;\n10. isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值;\n11. setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截;\n12. apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...);\n13. construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args);\n\n以上是目前es6支持的proxy，具体的用法不做赘述，有兴趣的可以到[阮一峰老师的es6入门](http://es6.ruanyifeng.com/#docs/proxy)去研究每种的具体用法，其实思想都是一样的，只是每种对应了一些不同的功能~\n\n## 实际场景中 Proxy 可以做什么？\n\n### 实现私有变量\njs的语法中没有private这个关键字来修饰私有变量，所以基本上所有的class的属性都是可以被访问的，但是在有些场景下我们需要使用到私有变量，现在业界的一些做法都是使用”_变量名“来”约定“这是一个私有变量，但是如果哪天被别人从外部改掉的话，我们还是没有办法阻止的，然而，当Proxy出现后，我们可以用代理来处理这种场景，看代码：\n\n```javascript\nconst obj = {\n    _name: 'nanjin',\n    age: 19,\n    getName: () => {\n        return this._name;\n    },\n    setName: (newName) => {\n        this._name = newName;\n    }\n}\n\nconst proxyObj = obj => new Proxy(obj, {\n    get: (target, key) => {\n        if(key.startsWith('_')){\n            throw new Error(`${key} is private key, please use get${key}`)\n        }\n        return Reflect.get(target, key);\n    },\n    set: (target, key, newVal) => {\n        if(key.startsWith('_')){\n            throw new Error(`${key} is private key, please use set${key}`)\n        }\n        return Reflect.set(target, key, newVal);\n    }\n})\n\nconst newObj = proxyObj(obj);\nconsole.log(newObj._name) // Uncaught Error: _name is private key, please use get_name\nnewObj._name = 'newname'; // Uncaught Error: _name is private key, please use set_name\nconsole.log(newObj.age) // 19\nconsole.log(newObj.getName()) // nanjin\n```\n\n可见，通过proxyObj方法，我们可以实现把任何一个对象都过滤一次，然后返回新的代理对象，被处理的对象会把所有_开头的变量给拦截掉，更进一步，如果有用过mobx的同学会发现mobx里面的store中的对象都是类似于这样的\n\n<img src=\"https://user-gold-cdn.xitu.io/2019/6/6/16b2b95a4f3b0c99?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\">\n\n有handler 和 target，说明mobx本身也是用了代理模式，同时加上Decorator函数，在这里就相当于把proxyObj使用装饰器的方式来实现，Proxy + Decorator 就是mobx的核心原理啦~\n\n\n### 实现vue的双向绑定数据响应\n\nVUE的双向绑定涉及到模板编译，响应式数据，订阅者模式等等，有兴趣的可以看[这里](https://github.com/KieSun/Dream/issues/7)，因为这篇文章的主题是proxy，因此我们着重介绍一下数据响应式的过程。\n\n#### 2.x版本\n在当前的vue2.x的版本中，在data中声名一个obj后，vue会利用Object.defineProperty来递归的给data中的数据加上get和set，然后每次set的时候，加入额外的逻辑。来触发对应模板视图的更新，看下伪代码：\n\n```javascript\nconst defineReactiveData = data => {\n\tObject.keys(data).forEach(key => {\n\t\tlet value = data[key];\n\t\tObject.defineProperty(data, key, {\n         get : function(){\n            console.log(`getting ${key}`)\n            return value;\n         },\n         set : function(newValue){\n            console.log(`setting ${key}`)\n            notify() // 通知相关的模板进行编译\n            value = newValue;\n         },\n         enumerable : true,\n         configurable : true\n\t\t})\n\t})\n}\n```\n\n这个方法可以给data上面的所有属性都加上get和set，当然这只是伪代码，实际场景下我们还需要考虑如果某个属性还是对象我们应该递归下去，来试试：\n\n```javascript\nconst data = {\n\tname: 'nanjing',\n\tage: 19\n}\ndefineReactiveData(data)\ndata.name // getting name  'nanjing'\ndata.name = 'beijing';  // setting name\n```\n可以看到当我们get和set触发的时候，已经能够同时触发我们想要调用的函数拉，Vue双向绑定过程中，当改变this上的data的时候去更新模板的核心原理就是这个方法，通过它我们就能在data的某个属性被set的时候，去触发对应模板的更新。\n\n现在我们在来试试下面的代码：\n\n```javascript\nconst data = {\n    userIds: ['01','02','03','04','05']\n}\ndefineReactiveData(data);\ndata.userIds // getting userIds [\"01\", \"02\", \"03\", \"04\", \"05\"]\n// get 过程是没有问题的，现在我们尝试给数组中push一个数据\ndata.userIds.push('06') // getting userIds \n```\n\nwhat ? setting没有被触发，反而因为取了一次userIds所以触发了一次getting~，\n不仅如此，很多数组的方法都不会触发setting，比如：push,pop,shift,unshift,splice,sort,reverse这些方法都会改变数组，但是不会触发set，所以Vue为了解决这个问题，重新包装了这些函数，同时当这些方法被调用的时候，手动去触发notify()；看下源码：\n\n```javascript\n// 获得数组原型\nconst arrayProto = Array.prototype\nexport const arrayMethods = Object.create(arrayProto)\n// 重写以下函数\nconst methodsToPatch = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse',\n]\nmethodsToPatch.forEach(function(method) {\n  // 缓存原生函数\n  const original = arrayProto[method]\n  // 重写函数\n  def(arrayMethods, method, function mutator(...args) {\n    // 先调用原生函数获得结果\n    const result = original.apply(this, args)\n    const ob = this.__ob__\n    let inserted\n    // 调用以下几个函数时，监听新数据\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args\n        break\n      case 'splice':\n        inserted = args.slice(2)\n        break\n    }\n    if (inserted) ob.observeArray(inserted)\n    // 手动派发更新\n    ob.dep.notify()\n    return result\n  })\n})\n```\n\n上面是官方的源码，我们可以看下实现push的伪代码\n\n```javascript\nconst push = Array.prototype.push;\nArray.prototype.push = function(...args){\n\tconsole.log('push is happenning');\n\treturn push.apply(this, args);\n}\ndata.userIds.push('123') // push is happenning\n```\n通过这种方式，我们可以监听到这些的变化，但是vue官方文档中有这么一个[注意事项](https://cn.vuejs.org/v2/guide/list.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9)\n> 由于 JavaScript 的限制，Vue 不能检测以下变动的数组：\n> - 当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue\n> - 当你修改数组的长度时，例如：vm.items.length = newLength\n这个最根本的原因是因为这2种情况下，受制于js本身无法实现监听，所以官方建议用他们自己提供的内置api来实现，我们也可以理解到这里既不是defineProperty可以处理的，也是包一层函数就能解决的，这就是2.x版本现在的一个问题，下面我们回到这篇文章的主题，Proxy，vue官方会在3.x的版本中使用proxy来代替defineProperty处理响应式数据的过程，我们先来模拟一下实现，看看能否解决当前遇到的这些问题；\n\n#### 3.x版本\n\n我们先来通过proxy实现对data对象的get和set的劫持，并返回一个代理的对象，注意，我们只关注proxy本身，所有的实现都是伪代码，也不考虑递归的过程，有兴趣的同学可以自行完善\n\n```javascript\nconst defineReactiveProxyData = data => new Proxy(data, \n\t{\n        get: function(data, key){\n            console.log(`getting ${key}`)\n            return Reflect.get(data, key);\n        },\n        set: function(data, key, newVal){\n            console.log(`setting ${key}`)\n\t\t\tif(typeof newVal === 'object'){\n                // 如果不是基本数据类型，递归设置代理\n\t\t\t\treturn Reflect.set(data, key, defineReactiveProxyData(newVal));\n\t\t\t}\n            return Reflect.set(data, key, newVal);\n        }\n    })\nconst data = {\n    name: 'nanjing',\n    age: 19\n};\nconst vm = defineReactiveProxyData(data);\nvm.name // getting name  nanjing\nvm.age = 20; // setting age  20\n```\n\n看起来我们的代理已经起作用啦，之后只要在setting的时候加上notify()去通知模板进行编译就可以了，然后我们来尝试设置一个数组看看；\n\n```javascript\nvm.userIds = [1,2,3] //  setting userIds\nvm.userIds.push(1);\n// getting userIds 因为我们会先访问一次userids\n// getting push 调用了push方法，所以会访问一次push属性\n// getting length 数组push的时候 length会变，所以需要先访问原来的length\n// setting 3 通过下标设置的，所以set当前的index是3\n// setting length 改变了数组的长度，所以会set length\n// 4 返回新的数组的长度\n```\n\nok 2.x版本中遇到的第一个问题，需要重新包装Array.prototype上的一些方法，使用了proxy后不需要了，解决了~，继续看下一个问题\n\n```javascript\nvm.userIds.length = 2\n// getting userIds 先访问\n// setting length 在设置\nvm.userIds[1] = '123'\n// getting userIds 先访问\n// setting 1 设置index=1的item\n// \"123\"\n```\n\n从上面的例子中我们可以看到，不管是直接改变数组的length还是通过某一个下标改变数组的内容，proxy都能拦截到这次变化，这比defineProperty方便太多了，2.x版本中的第二个问题，在proxy中根本不会出现了。\n\n### 总结1\n\n通过上面的例子和代码，我们看到Vue的响应模式如果使用proxy会比现在的实现方式要简化和优化很多，很快在即将来临的3.0版本中，大家就可以体验到了。不过因为proxy本身是有兼容性的，比如ie浏览器，所以在低版本的场景下，vue会回退到现在的实现方式。\n\n### 总结2\n\n回归到proxy本身，设计模式中有一种典型的代理模式，proxy就是js的一种实现，它的好处在于，我可以在不污染本身对象的条件下，生成一个新的代理对象，所有的一些针对性逻辑放到代理对象上去实现，这样我可以由A对象，衍生出B,C,D...每个的处理过程都不一样，从而简化代码的复杂性，提升一定的可读性，比如用proxy实现数据库的ORM就是一种很好的应用，其实代码很简单，关键是要理解背后的思想，同时能够举一反三~\n\n\n### 扩展：\n\n1. Proxy.revocable()\n这个方法可以返回一个可取消的代理对象\n```javascript\nconst obj = {};\nconst handler = {};\nconst {proxy, revoke} = Proxy.revocable(obj, handler);\nproxy.a = 1\nproxy.a // 1\nrevoke();\nproxy.a // Uncaught TypeError: Cannot perform 'get' on a proxy that has been revoked\n```\n\n一旦代理被取消了，就不能再从代理对象访问了\n\n<img src=\"https://user-gold-cdn.xitu.io/2019/6/6/16b2b9693f300f3f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\">\n打印proxy 可以看到IsRevoked变为true了\n\n\n1. 代理对象的this问题\n因为new Proxy出来的是一个新的对象，所以在如果你在target中有使用this，被代理后的this将指向新的代理对象，而不是原来的对象，这个时候，如果有些函数是原对象独有的，就会出现this指向导致的问题，这种场景下，建议使用bind来强制绑定this\n\n看代码：\n```javascript\nconst target = new Date();\nconst handler = {};\nconst proxy = new Proxy(target, handler);\n\nproxy.getDate(); // Uncaught TypeError: this is not a Date object.\n```\n因为代理后的对象并不是一个Date类型的，不具有getDate方法的，所以我们需要在get的时候，绑定一下this的指向\n\n```javascript\nconst target = new Date();\nconst handler = {\n    get: function(target, key){\n        if(typeof target[key] === 'function'){\n            return target[key].bind(target) // 强制绑定\n            this到原对象\n        }\n        return Reflect.get(target, key)\n    }\n};\nconst proxy = new Proxy(target, handler);\n\nproxy.getDate(); // 6\n```\n这样就可以正常使用this啦，当然具体的使用还要看具体的场景，灵活运用吧！\n\n\n\n> 伪代码部分都是笔者揣摩写的，如有问题，欢迎指正~\n","source":"_posts/proxy.md","raw":"---\ntitle: proxy 简介\ndate: 2019-06-06 14:23:42\ntags: javascript\n---\n\n## 什么是Proxy\n\nproxy翻译过来的意思就是”代理“，ES6对Proxy的定位就是target对象(原对象)的基础上通过handler增加一层”拦截“，返回一个新的代理对象，之后所有在Proxy中被拦截的属性，都可以定制化一些新的流程在上面，先看一个最简单的例子\n\n```javascript\nconst target = {}; // 要被代理的原对象\n// 用于描述代理过程的handler\nconst handler = {\n  get: function (target, key, receiver) {\n    console.log(`getting ${key}!`);\n    return Reflect.get(target, key, receiver);\n  },\n  set: function (target, key, value, receiver) {\n    console.log(`setting ${key}!`);\n    return Reflect.set(target, key, value, receiver);\n  }\n}\n// obj就是一个被新的代理对象\nconst obj = new Proxy(target, handler);\nobj.a = 1 // setting a!\nconsole.log(obj.a) // getting a!\n```\n\n上面的例子中我们在target对象上架设了一层handler，其中拦截了针对target的get和set，然后我们就可以在get和set中间做一些额外的操作了\n\n\n> 注意：对Proxy对象的赋值操作也会影响到原对象target，同时对target的操作也会影响Proxy，不过直接操作原对象的话不会触发拦截的内容~\n\n```javascript\nobj.a = 1; // setting a!\nconsole.log(target.a) // 1 不会打印\"getting a!\"\n```\n\n> 注意：如果handler中没有任何拦截上的处理，那么对代理对象的操作会直接通向原对象\n\n```javascript\nconst target = {};\nconst handler = {};\nconst obj = new Proxy(target, handler);\nobj.a = 1;\nconsole.log(target.a) // 1\n```\n\n> 既然proxy也是一个对象，那么它就可以做为原型对象，所以我们把obj的原型指向到proxy上后，发现对obj的操作会找到原型上的代理对象，如果obj自己有a属性，则不会触发proxy上的get，这个应该很好理解\n\n```javascript\nconst target = {};\nconst handler = {\n    get: function(target, key){\n\t\tconsole.log(`get ${key} from ${JSON.stringify(target)}`);\n\t\treturn Reflect.get(target, key);\n\t}\n}\nconst proxy = new Proxy(target, handler);\nconst obj = Object.setPrototypeOf(obj, proxy);\nproxy.a = 1;\nconsole.log(obj.a) // get a from {\"a\": 1}\n```\n\n\n## ES6的Proxy实现了对哪些属性的拦截？\n\n> 通过上面的例子了解了Proxy的原理后，我们来看下ES6目前实现了哪些属性的拦截，以及他们分别可以做什么？\n> 下面是 Proxy 支持的拦截操作一览，一共 13 种\n1. get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy['foo'];\n2. set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值;\n3. has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。\n4. deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值;\n5. ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性;\n6. getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象;\n7. defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值;\n8. preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值;\n9. getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象;\n10. isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值;\n11. setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截;\n12. apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...);\n13. construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args);\n\n以上是目前es6支持的proxy，具体的用法不做赘述，有兴趣的可以到[阮一峰老师的es6入门](http://es6.ruanyifeng.com/#docs/proxy)去研究每种的具体用法，其实思想都是一样的，只是每种对应了一些不同的功能~\n\n## 实际场景中 Proxy 可以做什么？\n\n### 实现私有变量\njs的语法中没有private这个关键字来修饰私有变量，所以基本上所有的class的属性都是可以被访问的，但是在有些场景下我们需要使用到私有变量，现在业界的一些做法都是使用”_变量名“来”约定“这是一个私有变量，但是如果哪天被别人从外部改掉的话，我们还是没有办法阻止的，然而，当Proxy出现后，我们可以用代理来处理这种场景，看代码：\n\n```javascript\nconst obj = {\n    _name: 'nanjin',\n    age: 19,\n    getName: () => {\n        return this._name;\n    },\n    setName: (newName) => {\n        this._name = newName;\n    }\n}\n\nconst proxyObj = obj => new Proxy(obj, {\n    get: (target, key) => {\n        if(key.startsWith('_')){\n            throw new Error(`${key} is private key, please use get${key}`)\n        }\n        return Reflect.get(target, key);\n    },\n    set: (target, key, newVal) => {\n        if(key.startsWith('_')){\n            throw new Error(`${key} is private key, please use set${key}`)\n        }\n        return Reflect.set(target, key, newVal);\n    }\n})\n\nconst newObj = proxyObj(obj);\nconsole.log(newObj._name) // Uncaught Error: _name is private key, please use get_name\nnewObj._name = 'newname'; // Uncaught Error: _name is private key, please use set_name\nconsole.log(newObj.age) // 19\nconsole.log(newObj.getName()) // nanjin\n```\n\n可见，通过proxyObj方法，我们可以实现把任何一个对象都过滤一次，然后返回新的代理对象，被处理的对象会把所有_开头的变量给拦截掉，更进一步，如果有用过mobx的同学会发现mobx里面的store中的对象都是类似于这样的\n\n<img src=\"https://user-gold-cdn.xitu.io/2019/6/6/16b2b95a4f3b0c99?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\">\n\n有handler 和 target，说明mobx本身也是用了代理模式，同时加上Decorator函数，在这里就相当于把proxyObj使用装饰器的方式来实现，Proxy + Decorator 就是mobx的核心原理啦~\n\n\n### 实现vue的双向绑定数据响应\n\nVUE的双向绑定涉及到模板编译，响应式数据，订阅者模式等等，有兴趣的可以看[这里](https://github.com/KieSun/Dream/issues/7)，因为这篇文章的主题是proxy，因此我们着重介绍一下数据响应式的过程。\n\n#### 2.x版本\n在当前的vue2.x的版本中，在data中声名一个obj后，vue会利用Object.defineProperty来递归的给data中的数据加上get和set，然后每次set的时候，加入额外的逻辑。来触发对应模板视图的更新，看下伪代码：\n\n```javascript\nconst defineReactiveData = data => {\n\tObject.keys(data).forEach(key => {\n\t\tlet value = data[key];\n\t\tObject.defineProperty(data, key, {\n         get : function(){\n            console.log(`getting ${key}`)\n            return value;\n         },\n         set : function(newValue){\n            console.log(`setting ${key}`)\n            notify() // 通知相关的模板进行编译\n            value = newValue;\n         },\n         enumerable : true,\n         configurable : true\n\t\t})\n\t})\n}\n```\n\n这个方法可以给data上面的所有属性都加上get和set，当然这只是伪代码，实际场景下我们还需要考虑如果某个属性还是对象我们应该递归下去，来试试：\n\n```javascript\nconst data = {\n\tname: 'nanjing',\n\tage: 19\n}\ndefineReactiveData(data)\ndata.name // getting name  'nanjing'\ndata.name = 'beijing';  // setting name\n```\n可以看到当我们get和set触发的时候，已经能够同时触发我们想要调用的函数拉，Vue双向绑定过程中，当改变this上的data的时候去更新模板的核心原理就是这个方法，通过它我们就能在data的某个属性被set的时候，去触发对应模板的更新。\n\n现在我们在来试试下面的代码：\n\n```javascript\nconst data = {\n    userIds: ['01','02','03','04','05']\n}\ndefineReactiveData(data);\ndata.userIds // getting userIds [\"01\", \"02\", \"03\", \"04\", \"05\"]\n// get 过程是没有问题的，现在我们尝试给数组中push一个数据\ndata.userIds.push('06') // getting userIds \n```\n\nwhat ? setting没有被触发，反而因为取了一次userIds所以触发了一次getting~，\n不仅如此，很多数组的方法都不会触发setting，比如：push,pop,shift,unshift,splice,sort,reverse这些方法都会改变数组，但是不会触发set，所以Vue为了解决这个问题，重新包装了这些函数，同时当这些方法被调用的时候，手动去触发notify()；看下源码：\n\n```javascript\n// 获得数组原型\nconst arrayProto = Array.prototype\nexport const arrayMethods = Object.create(arrayProto)\n// 重写以下函数\nconst methodsToPatch = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse',\n]\nmethodsToPatch.forEach(function(method) {\n  // 缓存原生函数\n  const original = arrayProto[method]\n  // 重写函数\n  def(arrayMethods, method, function mutator(...args) {\n    // 先调用原生函数获得结果\n    const result = original.apply(this, args)\n    const ob = this.__ob__\n    let inserted\n    // 调用以下几个函数时，监听新数据\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args\n        break\n      case 'splice':\n        inserted = args.slice(2)\n        break\n    }\n    if (inserted) ob.observeArray(inserted)\n    // 手动派发更新\n    ob.dep.notify()\n    return result\n  })\n})\n```\n\n上面是官方的源码，我们可以看下实现push的伪代码\n\n```javascript\nconst push = Array.prototype.push;\nArray.prototype.push = function(...args){\n\tconsole.log('push is happenning');\n\treturn push.apply(this, args);\n}\ndata.userIds.push('123') // push is happenning\n```\n通过这种方式，我们可以监听到这些的变化，但是vue官方文档中有这么一个[注意事项](https://cn.vuejs.org/v2/guide/list.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9)\n> 由于 JavaScript 的限制，Vue 不能检测以下变动的数组：\n> - 当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue\n> - 当你修改数组的长度时，例如：vm.items.length = newLength\n这个最根本的原因是因为这2种情况下，受制于js本身无法实现监听，所以官方建议用他们自己提供的内置api来实现，我们也可以理解到这里既不是defineProperty可以处理的，也是包一层函数就能解决的，这就是2.x版本现在的一个问题，下面我们回到这篇文章的主题，Proxy，vue官方会在3.x的版本中使用proxy来代替defineProperty处理响应式数据的过程，我们先来模拟一下实现，看看能否解决当前遇到的这些问题；\n\n#### 3.x版本\n\n我们先来通过proxy实现对data对象的get和set的劫持，并返回一个代理的对象，注意，我们只关注proxy本身，所有的实现都是伪代码，也不考虑递归的过程，有兴趣的同学可以自行完善\n\n```javascript\nconst defineReactiveProxyData = data => new Proxy(data, \n\t{\n        get: function(data, key){\n            console.log(`getting ${key}`)\n            return Reflect.get(data, key);\n        },\n        set: function(data, key, newVal){\n            console.log(`setting ${key}`)\n\t\t\tif(typeof newVal === 'object'){\n                // 如果不是基本数据类型，递归设置代理\n\t\t\t\treturn Reflect.set(data, key, defineReactiveProxyData(newVal));\n\t\t\t}\n            return Reflect.set(data, key, newVal);\n        }\n    })\nconst data = {\n    name: 'nanjing',\n    age: 19\n};\nconst vm = defineReactiveProxyData(data);\nvm.name // getting name  nanjing\nvm.age = 20; // setting age  20\n```\n\n看起来我们的代理已经起作用啦，之后只要在setting的时候加上notify()去通知模板进行编译就可以了，然后我们来尝试设置一个数组看看；\n\n```javascript\nvm.userIds = [1,2,3] //  setting userIds\nvm.userIds.push(1);\n// getting userIds 因为我们会先访问一次userids\n// getting push 调用了push方法，所以会访问一次push属性\n// getting length 数组push的时候 length会变，所以需要先访问原来的length\n// setting 3 通过下标设置的，所以set当前的index是3\n// setting length 改变了数组的长度，所以会set length\n// 4 返回新的数组的长度\n```\n\nok 2.x版本中遇到的第一个问题，需要重新包装Array.prototype上的一些方法，使用了proxy后不需要了，解决了~，继续看下一个问题\n\n```javascript\nvm.userIds.length = 2\n// getting userIds 先访问\n// setting length 在设置\nvm.userIds[1] = '123'\n// getting userIds 先访问\n// setting 1 设置index=1的item\n// \"123\"\n```\n\n从上面的例子中我们可以看到，不管是直接改变数组的length还是通过某一个下标改变数组的内容，proxy都能拦截到这次变化，这比defineProperty方便太多了，2.x版本中的第二个问题，在proxy中根本不会出现了。\n\n### 总结1\n\n通过上面的例子和代码，我们看到Vue的响应模式如果使用proxy会比现在的实现方式要简化和优化很多，很快在即将来临的3.0版本中，大家就可以体验到了。不过因为proxy本身是有兼容性的，比如ie浏览器，所以在低版本的场景下，vue会回退到现在的实现方式。\n\n### 总结2\n\n回归到proxy本身，设计模式中有一种典型的代理模式，proxy就是js的一种实现，它的好处在于，我可以在不污染本身对象的条件下，生成一个新的代理对象，所有的一些针对性逻辑放到代理对象上去实现，这样我可以由A对象，衍生出B,C,D...每个的处理过程都不一样，从而简化代码的复杂性，提升一定的可读性，比如用proxy实现数据库的ORM就是一种很好的应用，其实代码很简单，关键是要理解背后的思想，同时能够举一反三~\n\n\n### 扩展：\n\n1. Proxy.revocable()\n这个方法可以返回一个可取消的代理对象\n```javascript\nconst obj = {};\nconst handler = {};\nconst {proxy, revoke} = Proxy.revocable(obj, handler);\nproxy.a = 1\nproxy.a // 1\nrevoke();\nproxy.a // Uncaught TypeError: Cannot perform 'get' on a proxy that has been revoked\n```\n\n一旦代理被取消了，就不能再从代理对象访问了\n\n<img src=\"https://user-gold-cdn.xitu.io/2019/6/6/16b2b9693f300f3f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\">\n打印proxy 可以看到IsRevoked变为true了\n\n\n1. 代理对象的this问题\n因为new Proxy出来的是一个新的对象，所以在如果你在target中有使用this，被代理后的this将指向新的代理对象，而不是原来的对象，这个时候，如果有些函数是原对象独有的，就会出现this指向导致的问题，这种场景下，建议使用bind来强制绑定this\n\n看代码：\n```javascript\nconst target = new Date();\nconst handler = {};\nconst proxy = new Proxy(target, handler);\n\nproxy.getDate(); // Uncaught TypeError: this is not a Date object.\n```\n因为代理后的对象并不是一个Date类型的，不具有getDate方法的，所以我们需要在get的时候，绑定一下this的指向\n\n```javascript\nconst target = new Date();\nconst handler = {\n    get: function(target, key){\n        if(typeof target[key] === 'function'){\n            return target[key].bind(target) // 强制绑定\n            this到原对象\n        }\n        return Reflect.get(target, key)\n    }\n};\nconst proxy = new Proxy(target, handler);\n\nproxy.getDate(); // 6\n```\n这样就可以正常使用this啦，当然具体的使用还要看具体的场景，灵活运用吧！\n\n\n\n> 伪代码部分都是笔者揣摩写的，如有问题，欢迎指正~\n","slug":"proxy","published":1,"updated":"2019-06-20T05:14:42.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx4afn4r0004q67wla83xqr7","content":"<h2 id=\"什么是Proxy\"><a href=\"#什么是Proxy\" class=\"headerlink\" title=\"什么是Proxy\"></a>什么是Proxy</h2><p>proxy翻译过来的意思就是”代理“，ES6对Proxy的定位就是target对象(原对象)的基础上通过handler增加一层”拦截“，返回一个新的代理对象，之后所有在Proxy中被拦截的属性，都可以定制化一些新的流程在上面，先看一个最简单的例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> target = &#123;&#125;; <span class=\"comment\">// 要被代理的原对象</span></span><br><span class=\"line\"><span class=\"comment\">// 用于描述代理过程的handler</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> handler = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>: function (target, key, receiver) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`getting <span class=\"subst\">$&#123;key&#125;</span>!`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, key, receiver);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"keyword\">set</span>: function (target, key, value, receiver) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`setting <span class=\"subst\">$&#123;key&#125;</span>!`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(target, key, value, receiver);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// obj就是一个被新的代理对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br><span class=\"line\">obj.a = <span class=\"number\">1</span> <span class=\"comment\">// setting a!</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.a) <span class=\"comment\">// getting a!</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的例子中我们在target对象上架设了一层handler，其中拦截了针对target的get和set，然后我们就可以在get和set中间做一些额外的操作了</p>\n<blockquote>\n<p>注意：对Proxy对象的赋值操作也会影响到原对象target，同时对target的操作也会影响Proxy，不过直接操作原对象的话不会触发拦截的内容~</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj.a = <span class=\"number\">1</span>; <span class=\"comment\">// setting a!</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(target.a) <span class=\"comment\">// 1 不会打印\"getting a!\"</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：如果handler中没有任何拦截上的处理，那么对代理对象的操作会直接通向原对象</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> target = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> handler = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br><span class=\"line\">obj.a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(target.a) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>既然proxy也是一个对象，那么它就可以做为原型对象，所以我们把obj的原型指向到proxy上后，发现对obj的操作会找到原型上的代理对象，如果obj自己有a属性，则不会触发proxy上的get，这个应该很好理解</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> target = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> handler = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span>: function(target, key)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">`get <span class=\"subst\">$&#123;key&#125;</span> from <span class=\"subst\">$&#123;<span class=\"built_in\">JSON</span>.stringify(target)&#125;</span>`</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, key);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"built_in\">Object</span>.setPrototypeOf(obj, proxy);</span><br><span class=\"line\">proxy.a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.a) <span class=\"comment\">// get a from &#123;\"a\": 1&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ES6的Proxy实现了对哪些属性的拦截？\"><a href=\"#ES6的Proxy实现了对哪些属性的拦截？\" class=\"headerlink\" title=\"ES6的Proxy实现了对哪些属性的拦截？\"></a>ES6的Proxy实现了对哪些属性的拦截？</h2><blockquote>\n<p>通过上面的例子了解了Proxy的原理后，我们来看下ES6目前实现了哪些属性的拦截，以及他们分别可以做什么？<br>下面是 Proxy 支持的拦截操作一览，一共 13 种</p>\n<ol>\n<li>get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’];</li>\n<li>set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值;</li>\n<li>has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。</li>\n<li>deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值;</li>\n<li>ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性;</li>\n<li>getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象;</li>\n<li>defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值;</li>\n<li>preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值;</li>\n<li>getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象;</li>\n<li>isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值;</li>\n<li>setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截;</li>\n<li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…);</li>\n<li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args);</li>\n</ol>\n</blockquote>\n<p>以上是目前es6支持的proxy，具体的用法不做赘述，有兴趣的可以到<a href=\"http://es6.ruanyifeng.com/#docs/proxy\" target=\"_blank\" rel=\"noopener\">阮一峰老师的es6入门</a>去研究每种的具体用法，其实思想都是一样的，只是每种对应了一些不同的功能~</p>\n<h2 id=\"实际场景中-Proxy-可以做什么？\"><a href=\"#实际场景中-Proxy-可以做什么？\" class=\"headerlink\" title=\"实际场景中 Proxy 可以做什么？\"></a>实际场景中 Proxy 可以做什么？</h2><h3 id=\"实现私有变量\"><a href=\"#实现私有变量\" class=\"headerlink\" title=\"实现私有变量\"></a>实现私有变量</h3><p>js的语法中没有private这个关键字来修饰私有变量，所以基本上所有的class的属性都是可以被访问的，但是在有些场景下我们需要使用到私有变量，现在业界的一些做法都是使用”_变量名“来”约定“这是一个私有变量，但是如果哪天被别人从外部改掉的话，我们还是没有办法阻止的，然而，当Proxy出现后，我们可以用代理来处理这种场景，看代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">    _name: <span class=\"string\">'nanjin'</span>,</span><br><span class=\"line\">    age: <span class=\"number\">19</span>,</span><br><span class=\"line\">    getName: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._name;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    setName: <span class=\"function\">(<span class=\"params\">newName</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._name = newName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> proxyObj = <span class=\"function\"><span class=\"params\">obj</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(obj, &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span>: (target, key) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(key.startsWith(<span class=\"string\">'_'</span>))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span> is private key, please use get<span class=\"subst\">$&#123;key&#125;</span>`</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, key);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">set</span>: (target, key, newVal) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(key.startsWith(<span class=\"string\">'_'</span>))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span> is private key, please use set<span class=\"subst\">$&#123;key&#125;</span>`</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(target, key, newVal);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> newObj = proxyObj(obj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj._name) <span class=\"comment\">// Uncaught Error: _name is private key, please use get_name</span></span><br><span class=\"line\">newObj._name = <span class=\"string\">'newname'</span>; <span class=\"comment\">// Uncaught Error: _name is private key, please use set_name</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.age) <span class=\"comment\">// 19</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.getName()) <span class=\"comment\">// nanjin</span></span><br></pre></td></tr></table></figure>\n\n<p>可见，通过proxyObj方法，我们可以实现把任何一个对象都过滤一次，然后返回新的代理对象，被处理的对象会把所有_开头的变量给拦截掉，更进一步，如果有用过mobx的同学会发现mobx里面的store中的对象都是类似于这样的</p>\n<img src=\"https://user-gold-cdn.xitu.io/2019/6/6/16b2b95a4f3b0c99?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\">\n\n<p>有handler 和 target，说明mobx本身也是用了代理模式，同时加上Decorator函数，在这里就相当于把proxyObj使用装饰器的方式来实现，Proxy + Decorator 就是mobx的核心原理啦~</p>\n<h3 id=\"实现vue的双向绑定数据响应\"><a href=\"#实现vue的双向绑定数据响应\" class=\"headerlink\" title=\"实现vue的双向绑定数据响应\"></a>实现vue的双向绑定数据响应</h3><p>VUE的双向绑定涉及到模板编译，响应式数据，订阅者模式等等，有兴趣的可以看<a href=\"https://github.com/KieSun/Dream/issues/7\" target=\"_blank\" rel=\"noopener\">这里</a>，因为这篇文章的主题是proxy，因此我们着重介绍一下数据响应式的过程。</p>\n<h4 id=\"2-x版本\"><a href=\"#2-x版本\" class=\"headerlink\" title=\"2.x版本\"></a>2.x版本</h4><p>在当前的vue2.x的版本中，在data中声名一个obj后，vue会利用Object.defineProperty来递归的给data中的数据加上get和set，然后每次set的时候，加入额外的逻辑。来触发对应模板视图的更新，看下伪代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> defineReactiveData = <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">Object</span>.keys(data).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">let</span> value = data[key];</span><br><span class=\"line\">\t\t<span class=\"built_in\">Object</span>.defineProperty(data, key, &#123;</span><br><span class=\"line\">         <span class=\"keyword\">get</span> : function()&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">`getting <span class=\"subst\">$&#123;key&#125;</span>`</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">         &#125;,</span><br><span class=\"line\">         <span class=\"keyword\">set</span> : function(newValue)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">`setting <span class=\"subst\">$&#123;key&#125;</span>`</span>)</span><br><span class=\"line\">            notify() <span class=\"comment\">// 通知相关的模板进行编译</span></span><br><span class=\"line\">            value = newValue;</span><br><span class=\"line\">         &#125;,</span><br><span class=\"line\">         enumerable : <span class=\"literal\">true</span>,</span><br><span class=\"line\">         configurable : <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法可以给data上面的所有属性都加上get和set，当然这只是伪代码，实际场景下我们还需要考虑如果某个属性还是对象我们应该递归下去，来试试：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> data = &#123;</span><br><span class=\"line\">\tname: <span class=\"string\">'nanjing'</span>,</span><br><span class=\"line\">\tage: <span class=\"number\">19</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">defineReactiveData(data)</span><br><span class=\"line\">data.name <span class=\"comment\">// getting name  'nanjing'</span></span><br><span class=\"line\">data.name = <span class=\"string\">'beijing'</span>;  <span class=\"comment\">// setting name</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到当我们get和set触发的时候，已经能够同时触发我们想要调用的函数拉，Vue双向绑定过程中，当改变this上的data的时候去更新模板的核心原理就是这个方法，通过它我们就能在data的某个属性被set的时候，去触发对应模板的更新。</p>\n<p>现在我们在来试试下面的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> data = &#123;</span><br><span class=\"line\">    userIds: [<span class=\"string\">'01'</span>,<span class=\"string\">'02'</span>,<span class=\"string\">'03'</span>,<span class=\"string\">'04'</span>,<span class=\"string\">'05'</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">defineReactiveData(data);</span><br><span class=\"line\">data.userIds <span class=\"comment\">// getting userIds [\"01\", \"02\", \"03\", \"04\", \"05\"]</span></span><br><span class=\"line\"><span class=\"comment\">// get 过程是没有问题的，现在我们尝试给数组中push一个数据</span></span><br><span class=\"line\">data.userIds.push(<span class=\"string\">'06'</span>) <span class=\"comment\">// getting userIds</span></span><br></pre></td></tr></table></figure>\n\n<p>what ? setting没有被触发，反而因为取了一次userIds所以触发了一次getting~，<br>不仅如此，很多数组的方法都不会触发setting，比如：push,pop,shift,unshift,splice,sort,reverse这些方法都会改变数组，但是不会触发set，所以Vue为了解决这个问题，重新包装了这些函数，同时当这些方法被调用的时候，手动去触发notify()；看下源码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获得数组原型</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arrayProto = <span class=\"built_in\">Array</span>.prototype</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> arrayMethods = <span class=\"built_in\">Object</span>.create(arrayProto)</span><br><span class=\"line\"><span class=\"comment\">// 重写以下函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> methodsToPatch = [</span><br><span class=\"line\">  <span class=\"string\">'push'</span>,</span><br><span class=\"line\">  <span class=\"string\">'pop'</span>,</span><br><span class=\"line\">  <span class=\"string\">'shift'</span>,</span><br><span class=\"line\">  <span class=\"string\">'unshift'</span>,</span><br><span class=\"line\">  <span class=\"string\">'splice'</span>,</span><br><span class=\"line\">  <span class=\"string\">'sort'</span>,</span><br><span class=\"line\">  <span class=\"string\">'reverse'</span>,</span><br><span class=\"line\">]</span><br><span class=\"line\">methodsToPatch.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">method</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 缓存原生函数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> original = arrayProto[method]</span><br><span class=\"line\">  <span class=\"comment\">// 重写函数</span></span><br><span class=\"line\">  def(arrayMethods, method, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mutator</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 先调用原生函数获得结果</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = original.apply(<span class=\"keyword\">this</span>, args)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> ob = <span class=\"keyword\">this</span>.__ob__</span><br><span class=\"line\">    <span class=\"keyword\">let</span> inserted</span><br><span class=\"line\">    <span class=\"comment\">// 调用以下几个函数时，监听新数据</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (method) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'push'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'unshift'</span>:</span><br><span class=\"line\">        inserted = args</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'splice'</span>:</span><br><span class=\"line\">        inserted = args.slice(<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inserted) ob.observeArray(inserted)</span><br><span class=\"line\">    <span class=\"comment\">// 手动派发更新</span></span><br><span class=\"line\">    ob.dep.notify()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>上面是官方的源码，我们可以看下实现push的伪代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> push = <span class=\"built_in\">Array</span>.prototype.push;</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.push = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'push is happenning'</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> push.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">data.userIds.push(<span class=\"string\">'123'</span>) <span class=\"comment\">// push is happenning</span></span><br></pre></td></tr></table></figure>\n\n<p>通过这种方式，我们可以监听到这些的变化，但是vue官方文档中有这么一个<a href=\"https://cn.vuejs.org/v2/guide/list.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\" target=\"_blank\" rel=\"noopener\">注意事项</a></p>\n<blockquote>\n<p>由于 JavaScript 的限制，Vue 不能检测以下变动的数组：</p>\n<ul>\n<li>当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue</li>\n<li>当你修改数组的长度时，例如：vm.items.length = newLength<br>这个最根本的原因是因为这2种情况下，受制于js本身无法实现监听，所以官方建议用他们自己提供的内置api来实现，我们也可以理解到这里既不是defineProperty可以处理的，也是包一层函数就能解决的，这就是2.x版本现在的一个问题，下面我们回到这篇文章的主题，Proxy，vue官方会在3.x的版本中使用proxy来代替defineProperty处理响应式数据的过程，我们先来模拟一下实现，看看能否解决当前遇到的这些问题；</li>\n</ul>\n</blockquote>\n<h4 id=\"3-x版本\"><a href=\"#3-x版本\" class=\"headerlink\" title=\"3.x版本\"></a>3.x版本</h4><p>我们先来通过proxy实现对data对象的get和set的劫持，并返回一个代理的对象，注意，我们只关注proxy本身，所有的实现都是伪代码，也不考虑递归的过程，有兴趣的同学可以自行完善</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> defineReactiveProxyData = <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(data, </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span>: function(data, key)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">`getting <span class=\"subst\">$&#123;key&#125;</span>`</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(data, key);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"keyword\">set</span>: function(data, key, newVal)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">`setting <span class=\"subst\">$&#123;key&#125;</span>`</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> newVal === <span class=\"string\">'object'</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果不是基本数据类型，递归设置代理</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(data, key, defineReactiveProxyData(newVal));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(data, key, newVal);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"><span class=\"keyword\">const</span> data = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'nanjing'</span>,</span><br><span class=\"line\">    age: <span class=\"number\">19</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> vm = defineReactiveProxyData(data);</span><br><span class=\"line\">vm.name <span class=\"comment\">// getting name  nanjing</span></span><br><span class=\"line\">vm.age = <span class=\"number\">20</span>; <span class=\"comment\">// setting age  20</span></span><br></pre></td></tr></table></figure>\n\n<p>看起来我们的代理已经起作用啦，之后只要在setting的时候加上notify()去通知模板进行编译就可以了，然后我们来尝试设置一个数组看看；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.userIds = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] <span class=\"comment\">//  setting userIds</span></span><br><span class=\"line\">vm.userIds.push(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// getting userIds 因为我们会先访问一次userids</span></span><br><span class=\"line\"><span class=\"comment\">// getting push 调用了push方法，所以会访问一次push属性</span></span><br><span class=\"line\"><span class=\"comment\">// getting length 数组push的时候 length会变，所以需要先访问原来的length</span></span><br><span class=\"line\"><span class=\"comment\">// setting 3 通过下标设置的，所以set当前的index是3</span></span><br><span class=\"line\"><span class=\"comment\">// setting length 改变了数组的长度，所以会set length</span></span><br><span class=\"line\"><span class=\"comment\">// 4 返回新的数组的长度</span></span><br></pre></td></tr></table></figure>\n\n<p>ok 2.x版本中遇到的第一个问题，需要重新包装Array.prototype上的一些方法，使用了proxy后不需要了，解决了~，继续看下一个问题</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.userIds.length = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"comment\">// getting userIds 先访问</span></span><br><span class=\"line\"><span class=\"comment\">// setting length 在设置</span></span><br><span class=\"line\">vm.userIds[<span class=\"number\">1</span>] = <span class=\"string\">'123'</span></span><br><span class=\"line\"><span class=\"comment\">// getting userIds 先访问</span></span><br><span class=\"line\"><span class=\"comment\">// setting 1 设置index=1的item</span></span><br><span class=\"line\"><span class=\"comment\">// \"123\"</span></span><br></pre></td></tr></table></figure>\n\n<p>从上面的例子中我们可以看到，不管是直接改变数组的length还是通过某一个下标改变数组的内容，proxy都能拦截到这次变化，这比defineProperty方便太多了，2.x版本中的第二个问题，在proxy中根本不会出现了。</p>\n<h3 id=\"总结1\"><a href=\"#总结1\" class=\"headerlink\" title=\"总结1\"></a>总结1</h3><p>通过上面的例子和代码，我们看到Vue的响应模式如果使用proxy会比现在的实现方式要简化和优化很多，很快在即将来临的3.0版本中，大家就可以体验到了。不过因为proxy本身是有兼容性的，比如ie浏览器，所以在低版本的场景下，vue会回退到现在的实现方式。</p>\n<h3 id=\"总结2\"><a href=\"#总结2\" class=\"headerlink\" title=\"总结2\"></a>总结2</h3><p>回归到proxy本身，设计模式中有一种典型的代理模式，proxy就是js的一种实现，它的好处在于，我可以在不污染本身对象的条件下，生成一个新的代理对象，所有的一些针对性逻辑放到代理对象上去实现，这样我可以由A对象，衍生出B,C,D…每个的处理过程都不一样，从而简化代码的复杂性，提升一定的可读性，比如用proxy实现数据库的ORM就是一种很好的应用，其实代码很简单，关键是要理解背后的思想，同时能够举一反三~</p>\n<h3 id=\"扩展：\"><a href=\"#扩展：\" class=\"headerlink\" title=\"扩展：\"></a>扩展：</h3><ol>\n<li>Proxy.revocable()<br>这个方法可以返回一个可取消的代理对象<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> handler = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123;proxy, revoke&#125; = <span class=\"built_in\">Proxy</span>.revocable(obj, handler);</span><br><span class=\"line\">proxy.a = <span class=\"number\">1</span></span><br><span class=\"line\">proxy.a <span class=\"comment\">// 1</span></span><br><span class=\"line\">revoke();</span><br><span class=\"line\">proxy.a <span class=\"comment\">// Uncaught TypeError: Cannot perform 'get' on a proxy that has been revoked</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>一旦代理被取消了，就不能再从代理对象访问了</p>\n<img src=\"https://user-gold-cdn.xitu.io/2019/6/6/16b2b9693f300f3f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\">\n打印proxy 可以看到IsRevoked变为true了\n\n\n<ol>\n<li>代理对象的this问题<br>因为new Proxy出来的是一个新的对象，所以在如果你在target中有使用this，被代理后的this将指向新的代理对象，而不是原来的对象，这个时候，如果有些函数是原对象独有的，就会出现this指向导致的问题，这种场景下，建议使用bind来强制绑定this</li>\n</ol>\n<p>看代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> target = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> handler = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br><span class=\"line\"></span><br><span class=\"line\">proxy.getDate(); <span class=\"comment\">// Uncaught TypeError: this is not a Date object.</span></span><br></pre></td></tr></table></figure>\n\n<p>因为代理后的对象并不是一个Date类型的，不具有getDate方法的，所以我们需要在get的时候，绑定一下this的指向</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> target = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> handler = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span>: function(target, key)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> target[key] === <span class=\"string\">'function'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> target[key].bind(target) <span class=\"comment\">// 强制绑定</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>到原对象</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br><span class=\"line\"></span><br><span class=\"line\">proxy.getDate(); <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n\n<p>这样就可以正常使用this啦，当然具体的使用还要看具体的场景，灵活运用吧！</p>\n<blockquote>\n<p>伪代码部分都是笔者揣摩写的，如有问题，欢迎指正~</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是Proxy\"><a href=\"#什么是Proxy\" class=\"headerlink\" title=\"什么是Proxy\"></a>什么是Proxy</h2><p>proxy翻译过来的意思就是”代理“，ES6对Proxy的定位就是target对象(原对象)的基础上通过handler增加一层”拦截“，返回一个新的代理对象，之后所有在Proxy中被拦截的属性，都可以定制化一些新的流程在上面，先看一个最简单的例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> target = &#123;&#125;; <span class=\"comment\">// 要被代理的原对象</span></span><br><span class=\"line\"><span class=\"comment\">// 用于描述代理过程的handler</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> handler = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>: function (target, key, receiver) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`getting <span class=\"subst\">$&#123;key&#125;</span>!`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, key, receiver);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"keyword\">set</span>: function (target, key, value, receiver) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`setting <span class=\"subst\">$&#123;key&#125;</span>!`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(target, key, value, receiver);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// obj就是一个被新的代理对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br><span class=\"line\">obj.a = <span class=\"number\">1</span> <span class=\"comment\">// setting a!</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.a) <span class=\"comment\">// getting a!</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的例子中我们在target对象上架设了一层handler，其中拦截了针对target的get和set，然后我们就可以在get和set中间做一些额外的操作了</p>\n<blockquote>\n<p>注意：对Proxy对象的赋值操作也会影响到原对象target，同时对target的操作也会影响Proxy，不过直接操作原对象的话不会触发拦截的内容~</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj.a = <span class=\"number\">1</span>; <span class=\"comment\">// setting a!</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(target.a) <span class=\"comment\">// 1 不会打印\"getting a!\"</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：如果handler中没有任何拦截上的处理，那么对代理对象的操作会直接通向原对象</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> target = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> handler = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br><span class=\"line\">obj.a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(target.a) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>既然proxy也是一个对象，那么它就可以做为原型对象，所以我们把obj的原型指向到proxy上后，发现对obj的操作会找到原型上的代理对象，如果obj自己有a属性，则不会触发proxy上的get，这个应该很好理解</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> target = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> handler = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span>: function(target, key)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">`get <span class=\"subst\">$&#123;key&#125;</span> from <span class=\"subst\">$&#123;<span class=\"built_in\">JSON</span>.stringify(target)&#125;</span>`</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, key);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"built_in\">Object</span>.setPrototypeOf(obj, proxy);</span><br><span class=\"line\">proxy.a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.a) <span class=\"comment\">// get a from &#123;\"a\": 1&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ES6的Proxy实现了对哪些属性的拦截？\"><a href=\"#ES6的Proxy实现了对哪些属性的拦截？\" class=\"headerlink\" title=\"ES6的Proxy实现了对哪些属性的拦截？\"></a>ES6的Proxy实现了对哪些属性的拦截？</h2><blockquote>\n<p>通过上面的例子了解了Proxy的原理后，我们来看下ES6目前实现了哪些属性的拦截，以及他们分别可以做什么？<br>下面是 Proxy 支持的拦截操作一览，一共 13 种</p>\n<ol>\n<li>get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’];</li>\n<li>set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值;</li>\n<li>has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。</li>\n<li>deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值;</li>\n<li>ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性;</li>\n<li>getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象;</li>\n<li>defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值;</li>\n<li>preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值;</li>\n<li>getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象;</li>\n<li>isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值;</li>\n<li>setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截;</li>\n<li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…);</li>\n<li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args);</li>\n</ol>\n</blockquote>\n<p>以上是目前es6支持的proxy，具体的用法不做赘述，有兴趣的可以到<a href=\"http://es6.ruanyifeng.com/#docs/proxy\" target=\"_blank\" rel=\"noopener\">阮一峰老师的es6入门</a>去研究每种的具体用法，其实思想都是一样的，只是每种对应了一些不同的功能~</p>\n<h2 id=\"实际场景中-Proxy-可以做什么？\"><a href=\"#实际场景中-Proxy-可以做什么？\" class=\"headerlink\" title=\"实际场景中 Proxy 可以做什么？\"></a>实际场景中 Proxy 可以做什么？</h2><h3 id=\"实现私有变量\"><a href=\"#实现私有变量\" class=\"headerlink\" title=\"实现私有变量\"></a>实现私有变量</h3><p>js的语法中没有private这个关键字来修饰私有变量，所以基本上所有的class的属性都是可以被访问的，但是在有些场景下我们需要使用到私有变量，现在业界的一些做法都是使用”_变量名“来”约定“这是一个私有变量，但是如果哪天被别人从外部改掉的话，我们还是没有办法阻止的，然而，当Proxy出现后，我们可以用代理来处理这种场景，看代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">    _name: <span class=\"string\">'nanjin'</span>,</span><br><span class=\"line\">    age: <span class=\"number\">19</span>,</span><br><span class=\"line\">    getName: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._name;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    setName: <span class=\"function\">(<span class=\"params\">newName</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._name = newName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> proxyObj = <span class=\"function\"><span class=\"params\">obj</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(obj, &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span>: (target, key) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(key.startsWith(<span class=\"string\">'_'</span>))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span> is private key, please use get<span class=\"subst\">$&#123;key&#125;</span>`</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, key);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">set</span>: (target, key, newVal) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(key.startsWith(<span class=\"string\">'_'</span>))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span> is private key, please use set<span class=\"subst\">$&#123;key&#125;</span>`</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(target, key, newVal);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> newObj = proxyObj(obj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj._name) <span class=\"comment\">// Uncaught Error: _name is private key, please use get_name</span></span><br><span class=\"line\">newObj._name = <span class=\"string\">'newname'</span>; <span class=\"comment\">// Uncaught Error: _name is private key, please use set_name</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.age) <span class=\"comment\">// 19</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newObj.getName()) <span class=\"comment\">// nanjin</span></span><br></pre></td></tr></table></figure>\n\n<p>可见，通过proxyObj方法，我们可以实现把任何一个对象都过滤一次，然后返回新的代理对象，被处理的对象会把所有_开头的变量给拦截掉，更进一步，如果有用过mobx的同学会发现mobx里面的store中的对象都是类似于这样的</p>\n<img src=\"https://user-gold-cdn.xitu.io/2019/6/6/16b2b95a4f3b0c99?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\">\n\n<p>有handler 和 target，说明mobx本身也是用了代理模式，同时加上Decorator函数，在这里就相当于把proxyObj使用装饰器的方式来实现，Proxy + Decorator 就是mobx的核心原理啦~</p>\n<h3 id=\"实现vue的双向绑定数据响应\"><a href=\"#实现vue的双向绑定数据响应\" class=\"headerlink\" title=\"实现vue的双向绑定数据响应\"></a>实现vue的双向绑定数据响应</h3><p>VUE的双向绑定涉及到模板编译，响应式数据，订阅者模式等等，有兴趣的可以看<a href=\"https://github.com/KieSun/Dream/issues/7\" target=\"_blank\" rel=\"noopener\">这里</a>，因为这篇文章的主题是proxy，因此我们着重介绍一下数据响应式的过程。</p>\n<h4 id=\"2-x版本\"><a href=\"#2-x版本\" class=\"headerlink\" title=\"2.x版本\"></a>2.x版本</h4><p>在当前的vue2.x的版本中，在data中声名一个obj后，vue会利用Object.defineProperty来递归的给data中的数据加上get和set，然后每次set的时候，加入额外的逻辑。来触发对应模板视图的更新，看下伪代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> defineReactiveData = <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">Object</span>.keys(data).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">let</span> value = data[key];</span><br><span class=\"line\">\t\t<span class=\"built_in\">Object</span>.defineProperty(data, key, &#123;</span><br><span class=\"line\">         <span class=\"keyword\">get</span> : function()&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">`getting <span class=\"subst\">$&#123;key&#125;</span>`</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">         &#125;,</span><br><span class=\"line\">         <span class=\"keyword\">set</span> : function(newValue)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">`setting <span class=\"subst\">$&#123;key&#125;</span>`</span>)</span><br><span class=\"line\">            notify() <span class=\"comment\">// 通知相关的模板进行编译</span></span><br><span class=\"line\">            value = newValue;</span><br><span class=\"line\">         &#125;,</span><br><span class=\"line\">         enumerable : <span class=\"literal\">true</span>,</span><br><span class=\"line\">         configurable : <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法可以给data上面的所有属性都加上get和set，当然这只是伪代码，实际场景下我们还需要考虑如果某个属性还是对象我们应该递归下去，来试试：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> data = &#123;</span><br><span class=\"line\">\tname: <span class=\"string\">'nanjing'</span>,</span><br><span class=\"line\">\tage: <span class=\"number\">19</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">defineReactiveData(data)</span><br><span class=\"line\">data.name <span class=\"comment\">// getting name  'nanjing'</span></span><br><span class=\"line\">data.name = <span class=\"string\">'beijing'</span>;  <span class=\"comment\">// setting name</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到当我们get和set触发的时候，已经能够同时触发我们想要调用的函数拉，Vue双向绑定过程中，当改变this上的data的时候去更新模板的核心原理就是这个方法，通过它我们就能在data的某个属性被set的时候，去触发对应模板的更新。</p>\n<p>现在我们在来试试下面的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> data = &#123;</span><br><span class=\"line\">    userIds: [<span class=\"string\">'01'</span>,<span class=\"string\">'02'</span>,<span class=\"string\">'03'</span>,<span class=\"string\">'04'</span>,<span class=\"string\">'05'</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">defineReactiveData(data);</span><br><span class=\"line\">data.userIds <span class=\"comment\">// getting userIds [\"01\", \"02\", \"03\", \"04\", \"05\"]</span></span><br><span class=\"line\"><span class=\"comment\">// get 过程是没有问题的，现在我们尝试给数组中push一个数据</span></span><br><span class=\"line\">data.userIds.push(<span class=\"string\">'06'</span>) <span class=\"comment\">// getting userIds</span></span><br></pre></td></tr></table></figure>\n\n<p>what ? setting没有被触发，反而因为取了一次userIds所以触发了一次getting~，<br>不仅如此，很多数组的方法都不会触发setting，比如：push,pop,shift,unshift,splice,sort,reverse这些方法都会改变数组，但是不会触发set，所以Vue为了解决这个问题，重新包装了这些函数，同时当这些方法被调用的时候，手动去触发notify()；看下源码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获得数组原型</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arrayProto = <span class=\"built_in\">Array</span>.prototype</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> arrayMethods = <span class=\"built_in\">Object</span>.create(arrayProto)</span><br><span class=\"line\"><span class=\"comment\">// 重写以下函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> methodsToPatch = [</span><br><span class=\"line\">  <span class=\"string\">'push'</span>,</span><br><span class=\"line\">  <span class=\"string\">'pop'</span>,</span><br><span class=\"line\">  <span class=\"string\">'shift'</span>,</span><br><span class=\"line\">  <span class=\"string\">'unshift'</span>,</span><br><span class=\"line\">  <span class=\"string\">'splice'</span>,</span><br><span class=\"line\">  <span class=\"string\">'sort'</span>,</span><br><span class=\"line\">  <span class=\"string\">'reverse'</span>,</span><br><span class=\"line\">]</span><br><span class=\"line\">methodsToPatch.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">method</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 缓存原生函数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> original = arrayProto[method]</span><br><span class=\"line\">  <span class=\"comment\">// 重写函数</span></span><br><span class=\"line\">  def(arrayMethods, method, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mutator</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 先调用原生函数获得结果</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = original.apply(<span class=\"keyword\">this</span>, args)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> ob = <span class=\"keyword\">this</span>.__ob__</span><br><span class=\"line\">    <span class=\"keyword\">let</span> inserted</span><br><span class=\"line\">    <span class=\"comment\">// 调用以下几个函数时，监听新数据</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (method) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'push'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'unshift'</span>:</span><br><span class=\"line\">        inserted = args</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'splice'</span>:</span><br><span class=\"line\">        inserted = args.slice(<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inserted) ob.observeArray(inserted)</span><br><span class=\"line\">    <span class=\"comment\">// 手动派发更新</span></span><br><span class=\"line\">    ob.dep.notify()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>上面是官方的源码，我们可以看下实现push的伪代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> push = <span class=\"built_in\">Array</span>.prototype.push;</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.push = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'push is happenning'</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> push.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">data.userIds.push(<span class=\"string\">'123'</span>) <span class=\"comment\">// push is happenning</span></span><br></pre></td></tr></table></figure>\n\n<p>通过这种方式，我们可以监听到这些的变化，但是vue官方文档中有这么一个<a href=\"https://cn.vuejs.org/v2/guide/list.html#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\" target=\"_blank\" rel=\"noopener\">注意事项</a></p>\n<blockquote>\n<p>由于 JavaScript 的限制，Vue 不能检测以下变动的数组：</p>\n<ul>\n<li>当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue</li>\n<li>当你修改数组的长度时，例如：vm.items.length = newLength<br>这个最根本的原因是因为这2种情况下，受制于js本身无法实现监听，所以官方建议用他们自己提供的内置api来实现，我们也可以理解到这里既不是defineProperty可以处理的，也是包一层函数就能解决的，这就是2.x版本现在的一个问题，下面我们回到这篇文章的主题，Proxy，vue官方会在3.x的版本中使用proxy来代替defineProperty处理响应式数据的过程，我们先来模拟一下实现，看看能否解决当前遇到的这些问题；</li>\n</ul>\n</blockquote>\n<h4 id=\"3-x版本\"><a href=\"#3-x版本\" class=\"headerlink\" title=\"3.x版本\"></a>3.x版本</h4><p>我们先来通过proxy实现对data对象的get和set的劫持，并返回一个代理的对象，注意，我们只关注proxy本身，所有的实现都是伪代码，也不考虑递归的过程，有兴趣的同学可以自行完善</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> defineReactiveProxyData = <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(data, </span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span>: function(data, key)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">`getting <span class=\"subst\">$&#123;key&#125;</span>`</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(data, key);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"keyword\">set</span>: function(data, key, newVal)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">`setting <span class=\"subst\">$&#123;key&#125;</span>`</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> newVal === <span class=\"string\">'object'</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果不是基本数据类型，递归设置代理</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(data, key, defineReactiveProxyData(newVal));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(data, key, newVal);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"><span class=\"keyword\">const</span> data = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'nanjing'</span>,</span><br><span class=\"line\">    age: <span class=\"number\">19</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> vm = defineReactiveProxyData(data);</span><br><span class=\"line\">vm.name <span class=\"comment\">// getting name  nanjing</span></span><br><span class=\"line\">vm.age = <span class=\"number\">20</span>; <span class=\"comment\">// setting age  20</span></span><br></pre></td></tr></table></figure>\n\n<p>看起来我们的代理已经起作用啦，之后只要在setting的时候加上notify()去通知模板进行编译就可以了，然后我们来尝试设置一个数组看看；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.userIds = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] <span class=\"comment\">//  setting userIds</span></span><br><span class=\"line\">vm.userIds.push(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// getting userIds 因为我们会先访问一次userids</span></span><br><span class=\"line\"><span class=\"comment\">// getting push 调用了push方法，所以会访问一次push属性</span></span><br><span class=\"line\"><span class=\"comment\">// getting length 数组push的时候 length会变，所以需要先访问原来的length</span></span><br><span class=\"line\"><span class=\"comment\">// setting 3 通过下标设置的，所以set当前的index是3</span></span><br><span class=\"line\"><span class=\"comment\">// setting length 改变了数组的长度，所以会set length</span></span><br><span class=\"line\"><span class=\"comment\">// 4 返回新的数组的长度</span></span><br></pre></td></tr></table></figure>\n\n<p>ok 2.x版本中遇到的第一个问题，需要重新包装Array.prototype上的一些方法，使用了proxy后不需要了，解决了~，继续看下一个问题</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.userIds.length = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"comment\">// getting userIds 先访问</span></span><br><span class=\"line\"><span class=\"comment\">// setting length 在设置</span></span><br><span class=\"line\">vm.userIds[<span class=\"number\">1</span>] = <span class=\"string\">'123'</span></span><br><span class=\"line\"><span class=\"comment\">// getting userIds 先访问</span></span><br><span class=\"line\"><span class=\"comment\">// setting 1 设置index=1的item</span></span><br><span class=\"line\"><span class=\"comment\">// \"123\"</span></span><br></pre></td></tr></table></figure>\n\n<p>从上面的例子中我们可以看到，不管是直接改变数组的length还是通过某一个下标改变数组的内容，proxy都能拦截到这次变化，这比defineProperty方便太多了，2.x版本中的第二个问题，在proxy中根本不会出现了。</p>\n<h3 id=\"总结1\"><a href=\"#总结1\" class=\"headerlink\" title=\"总结1\"></a>总结1</h3><p>通过上面的例子和代码，我们看到Vue的响应模式如果使用proxy会比现在的实现方式要简化和优化很多，很快在即将来临的3.0版本中，大家就可以体验到了。不过因为proxy本身是有兼容性的，比如ie浏览器，所以在低版本的场景下，vue会回退到现在的实现方式。</p>\n<h3 id=\"总结2\"><a href=\"#总结2\" class=\"headerlink\" title=\"总结2\"></a>总结2</h3><p>回归到proxy本身，设计模式中有一种典型的代理模式，proxy就是js的一种实现，它的好处在于，我可以在不污染本身对象的条件下，生成一个新的代理对象，所有的一些针对性逻辑放到代理对象上去实现，这样我可以由A对象，衍生出B,C,D…每个的处理过程都不一样，从而简化代码的复杂性，提升一定的可读性，比如用proxy实现数据库的ORM就是一种很好的应用，其实代码很简单，关键是要理解背后的思想，同时能够举一反三~</p>\n<h3 id=\"扩展：\"><a href=\"#扩展：\" class=\"headerlink\" title=\"扩展：\"></a>扩展：</h3><ol>\n<li>Proxy.revocable()<br>这个方法可以返回一个可取消的代理对象<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> handler = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123;proxy, revoke&#125; = <span class=\"built_in\">Proxy</span>.revocable(obj, handler);</span><br><span class=\"line\">proxy.a = <span class=\"number\">1</span></span><br><span class=\"line\">proxy.a <span class=\"comment\">// 1</span></span><br><span class=\"line\">revoke();</span><br><span class=\"line\">proxy.a <span class=\"comment\">// Uncaught TypeError: Cannot perform 'get' on a proxy that has been revoked</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>一旦代理被取消了，就不能再从代理对象访问了</p>\n<img src=\"https://user-gold-cdn.xitu.io/2019/6/6/16b2b9693f300f3f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\">\n打印proxy 可以看到IsRevoked变为true了\n\n\n<ol>\n<li>代理对象的this问题<br>因为new Proxy出来的是一个新的对象，所以在如果你在target中有使用this，被代理后的this将指向新的代理对象，而不是原来的对象，这个时候，如果有些函数是原对象独有的，就会出现this指向导致的问题，这种场景下，建议使用bind来强制绑定this</li>\n</ol>\n<p>看代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> target = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> handler = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br><span class=\"line\"></span><br><span class=\"line\">proxy.getDate(); <span class=\"comment\">// Uncaught TypeError: this is not a Date object.</span></span><br></pre></td></tr></table></figure>\n\n<p>因为代理后的对象并不是一个Date类型的，不具有getDate方法的，所以我们需要在get的时候，绑定一下this的指向</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> target = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> handler = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span>: function(target, key)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> target[key] === <span class=\"string\">'function'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> target[key].bind(target) <span class=\"comment\">// 强制绑定</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>到原对象</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br><span class=\"line\"></span><br><span class=\"line\">proxy.getDate(); <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n\n<p>这样就可以正常使用this啦，当然具体的使用还要看具体的场景，灵活运用吧！</p>\n<blockquote>\n<p>伪代码部分都是笔者揣摩写的，如有问题，欢迎指正~</p>\n</blockquote>\n"},{"title":"前端框架的趋势-hook入门","date":"2019-06-13T03:17:10.000Z","_content":"\n<img src=\"https://user-gold-cdn.xitu.io/2019/6/13/16b4e61bb6d37766?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\">\n\n## 背景\n\n很荣幸在6月8号那天参加了在上海举办的vueconf，其中尤大本人讲解的vue3.0的介绍中，见识到了vue3.0的一些新特性，其中最重要的一项RFC就是 [Vue Function-based API RFC](https://zhuanlan.zhihu.com/p/68477600)，很巧的在不久前正好研究了一下[react hook](https://react.docschina.org/docs/hooks-intro.html)，感觉2者的在思想上有着异曲同工之妙，所以有了一个想总结一下关于hook的想法，同时看到很多人关于hook的介绍都是分开讲的，当然可能和vue3.0对于这个特性的说明刚刚问世也有一定的关系，so，lets begin~\n\n## 什么是hook\n\n首先我们需要了解什么是hook，拿react的介绍来看，它的定义是：\n> 它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性\n\n在16.8以前的版本中，我们在写react组件的时候，大部分都都是class component，因为基于class的组件react提供了更多的可操作性，比如拥有自己的state，以及一些生命周期的实现，对于复杂的逻辑来讲class的支持程度是更高的：\n\n```javascript\nclass Hello extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  componentDidMount() { // do sth... }\n\n  componentWillUnmount() { // do sth... }\n  \n  // other methods or lifecycle...\n  \n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n```\n\n同时，对于function component来说，react也是支持的，但是function component只能拥有props，不能拥有state，也就是只能实现stateless component：\n\n```javascript\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n```\n\nreact 并没有提供在函数组件中设置state以及生命周期的一些操作方法，所以那个时候，极少的场景下适合采用函数组件，但是16.8版本出现hook以后情况得到了改变，hook的目标就是--**让你在不编写 class 的情况下使用 state 以及其他的 React 特性**，来看个例子：\n\n```javascript\nimport React, { useState } from 'react';\n\nfunction Example() {\n  // 声明一个新的叫做 “count” 的 state 变量\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\nuseState就是react提供的一个Hook，通过它我们就可以在function组件中设置自己想要的state了，不仅可以使用还可以很方便的去通过setState(注意不是class中的setState，这里指的是上述例子中的setCount)更改，当然，react提供了很多hook来支持不同的行为和操作，下面我们还会再简单介绍，我们在看下vue hook，这是尤大在vueconf上分享的一段代码：\n\n```javascript\nimport { value, computed, watch, onMounted } from 'vue'\n\nconst App = {\n  template: `\n    <div>\n      <span>count is {{ count }}</span>\n      <span>plusOne is {{ plusOne }}</span>\n      <button @click=\"increment\">count++</button>\n    </div>\n  `,\n  setup() {\n    // reactive state\n    const count = value(0)\n    // computed state\n    const plusOne = computed(() => count.value + 1)\n    // method\n    const increment = () => { count.value++ }\n    // watch\n    watch(() => count.value * 2, val => {\n      console.log(`count * 2 is ${val}`)\n    })\n    // lifecycle\n    onMounted(() => {\n      console.log(`mounted`)\n    })\n    // expose bindings on render context\n    return {\n      count,\n      plusOne,\n      increment\n    }\n  }\n}\n```\n从上面的例子中不难看出，和react hook的用法非常相似，并且尤大也有说这个RFC是借鉴了react hook的想法，但是规避了一些react的问题，然后这里解释一下为什么我把vue的这个RFC也称为是hook，因为在react hook的介绍中有这么一句话，什么是hook--Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数，那么vue提供的这些API的作用也是类似的--可以让你在函数组件里“钩入” value(2.x中的data) 及生命周期等特性的函数，所以，暂且就叫vue-hook吧~\n\n\n## hook的时代意义\n\n那么，hook的时代意义是什么？我们从头来说，框架是服务于业务的，业务中很难避免的一个问题就是-- 逻辑复用，同样的功能，同样的组件，在不一样的场合下，我们有时候不得不去写2+次，为了避免耦合，后来各大框架纷纷想出了一些办法：\n- mixin\n- HOC\n- slot\n\n各大框架的使用情况：\n- react 和 vue都曾用过mixin(react 目前已经废弃),\n- Higher-Order-Components(HOC) react中用的相对多一点，vue的话，嵌套template有点。。别扭,\n- slot vue中用的多一些，react基本不需要slot这种用法,\n\n上述这些方法都可以实现逻辑上的复用，但是都有一些额外的问题:\n\n- mixin的问题：\n    - 可能会相互依赖，相互耦合，不利于代码维护；\n    - 不同的mixin中的方法可能会相互冲突;\n    - mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理，\n这样会给代码造成滚雪球式的复杂性\n\n- HOC的问题：\n    - 需要在原组件上进行包裹或者嵌套，如果大量使用HOC，\n将会产生非常多的嵌套，这让调试变得非常困难；\n    - HOC可以劫持props，在不遵守约定的情况下也可能造成冲突\n    - props 也可能造成命名的冲突\n    - wrapper hell\n\n**有没有见过这样的dom结构？**\n\n<img src=\"https://user-gold-cdn.xitu.io/2019/6/12/16b4a8f77e88d56f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"/>\n\n\n这就是wrapper hell的典型代表~\n\n所以，hook的出现是划时代的，它通过function抽离的方式，实现了复杂逻辑的内部封装，根据上述我们提出的问题总结了hook的一些优点：\n\n1. 逻辑代码的复用\n2. 减小了代码体积\n3. 没有this的烦恼\n\n带着这些思想，我们一起看下react和vue分别的实现：\n\n\n## react hook简介\n\n> Dan 讲解hook的视频在[这里](https://www.youtube.com/watch?v=dpw9EHDh2bM&feature=youtu.be)，如果你看不了这个，可以尝试看[官网介绍](https://react.docschina.org/docs/hooks-intro.html)\n\n我们用同样功能的代码来看react hook，实现一个监听鼠标变化，并实时查看位置的功能，同时我们把位置信息挂到title上面，用class component我们要这样写：\n\n```javascript\nimport React, { Component } from 'react';\n\nexport default class MyClassApp extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            x: 0,\n            y: 0\n        };\n        this.handleUpdate = this.handleUpdate.bind(this);\n    }\n    componentDidMount() {\n        document.addEventListener('mousemove', this.handleUpdate);\n    }\n    componentDidUpdate() {\n        const { x, y } = this.state;\n        document.title = `(${x},${y})`;\n    }\n    componentWillUnmount() {\n        window.removeEventListener('mousemove', this.handleUpdate);\n    }\n    handleUpdate(e) {\n        this.setState({\n            x: e.clientX,\n            y: e.clientY\n        });\n    }\n    render() {\n        return (\n            <div>\n                current position x:{this.state.x}, y:{this.state.y}\n            </div>\n        );\n    }\n}\n\n```\n在线代码演示在[这里](https://codesandbox.io/s/xenodochial-butterfly-gzflh)\n\n\n同样的逻辑我们换用hook来实现\n\n```javascript\nimport React, { useState, useEffect } from 'react';\n\n// 自定义hook useMousePostion\nconst useMousePostion = () => {\n    // 使用hookuseState初始化一个state\n    const [postion, setPostion] = useState({ x: 0, y: 0 });\n    function handleMove(e) {\n        setPostion({ x: e.clientX, y: e.clientY });\n    }\n    // 使用useEffect处理class中生命周期可以做到的事情\n    // 注：效果一样，但是实际的原理并不同，有兴趣可以去官网仔细研究\n    useEffect(() => {\n        // 同时可以处理 componentDidMount 以及 componentDidUpdate 中的事情\n        window.addEventListener('mousemove', handleMove);\n        document.title = `(${postion.x},${postion.y})`;\n        return () => {\n            // return的function 可以相当于在组件被卸载的时候执行 类似于 componentWillUnmount\n            window.removeEventListener('mousemove', handleMove);\n        };\n        // [] 是参数，代表deps，也就是说react触发这个hook的时机会和传入的deps有关，内部利用object.is实现\n        // 默认不给参数会在每次render的时候调用，给空数组会导致每次比较是一样的，只执行一次，这里正确的应该是给postion\n    }, [postion]);\n    // postion 可以被直接return，这样达到了逻辑的复用~，哪里需要哪里调用就可以了。\n    return postion;\n};\n\nexport default function App() {\n    const { x, y } = useMousePostion(); // 内部维护自己的postion相关的逻辑\n    return (\n        <div>\n            current position x: {x}, y: {y}\n        </div>\n    );\n}\n\n```\n\n在线代码演示在[这里](https://codesandbox.io/s/hookdemo-8zxh2)\n\n可以看出用了hook之后，我们把关于position的逻辑都放到一个自定义的hook--useMousePostion 中，之后复用是很方便的，而且可以在内部进行维护postion独有的逻辑而不影响外部内容，比起class组件，抽象能力更强。\n\n当然，react hook 想要用好不可能这么简单，讲解的文章也很多，这篇文章不深入太多，只是一个抛砖引玉，下面给大家安利几个不错的资源：\n\n入门：\n- [官网传送门](https://react.docschina.org/docs/hooks-overview.html)\n\n深入：\n- [Dan自己写的关于hook的文章，写的很好强烈安利，深入内部实现](https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/#tldr)\n\n\n另外放一个笔者自己关于用hook实现redux的[**最佳实践**](https://codesandbox.io/s/react-hook-redux-zvx57)，注意是笔者自己这么认为的，欢迎大佬们指出问题，参考的[这个文章](https://www.robinwieruch.de/react-hooks-fetch-data/)\n\n## vue hook简介\n\n> 尤大讲解的视频在[这里](https://mp.weixin.qq.com/s/hBqu1A3gIwMVglb-ZWp8oA)\n\n代码因为vue3.0尚未发布，我们还是看尤大给的demo代码：\n\n```javascript\nimport { value, computed, watch, onMounted } from 'vue'\n\nfunction useMouse() {\n  const x = value(0)\n  const y = value(0)\n  const update = e => {\n    x.value = e.pageX\n    y.value = e.pageY\n  }\n  onMounted(() => {\n    window.addEventListener('mousemove', update)\n  })\n  onUnmounted(() => {\n    window.removeEventListener('mousemove', update)\n  })\n  return { x, y }\n}\n\n// 在组件中使用该函数\nconst Component = {\n  setup() {\n    const { x, y } = useMouse()\n    // 与其它函数配合使用\n    const { z } = useOtherLogic()\n    return { x, y, z }\n  },\n  template: `<div>{{ x }} {{ y }} {{ z }}</div>`\n}\n```\n可以看出来同样我们可以抽离一些需要复用的逻辑到一个单独的函数useMouse中，然后在这个函数里面定义的一些生命周期和value的内容会随着setup函数的调用被“钩入(hook)”到组件上，并且这个函数return出来的数据可以直接被用在模板上，更具体的玩法我们坐等3.0的出现吧。\n\n基础内容不过多介绍，毕竟真实的api还没发布，想了解具体内容的可以来看尤大的[讲解](https://zhuanlan.zhihu.com/p/68477600)\n\n## same & diff Point\n\n看完了2个框架关于hook的实现，我们来做个简单的对比\n\n1. Same Point:\n - 出现的背景，解决的问题是一样的，2个框架都是为了解决逻辑复用过乱，代码体积过大等一些问题，包括this问题，使用function函数我们很少会和this去打交道了。\n - 使用方式类似，都是把可以复用的一些单独的逻辑抽离到一个单独的函数中去，同时返回组件中需要用到的数据，并且内部会自我维护数据的更新，从而触发视图的更新\n\n2. Diff Point:\n\n**实现原理不同**\nreact hook底层是基于链表实现，调用的条件是每次组件被render的时候都会顺序执行所有的hooks，所以下面的代码会报错\n```javascript\nfunction App(){\n    const [name, setName] = useState('demo');\n    if(condition){\n        const [val, setVal] = useState('');\n    }\n}\n```\n因为底层是链表，每一个hook的next是指向下一个hook的，if会导致顺序不正确，从而导致报错，所以react是不允许这样使用hook的。\n\nvue hook只会在setup函数被调用的时候被注册一次，react数据更改的时候，会导致重新render，重新render又会重新把hooks重新注册一次，所以react的上手难度更高一些，而vue之所以能避开这些麻烦的问题，根本原因在于它对数据的响应是基于proxy的，这种场景下，只要任何一个更改data的地方，相关的function或者template都会被重新计算，因此避开了react可能遇到的性能上的问题\n\n当然react对这些都有解决方案，想了解的同学可以去看官网有介绍，比如useCallback，useMemo等hook的作用，我们看下尤大对vue和react hook的总结对比：\n\n> 1.整体上更符合 JavaScript 的直觉；\n\n> 2.不受调用顺序的限制，可以有条件地被调用；\n\n> 3.不会在后续更新时不断产生大量的内联函数而影响引擎优化或是导致 GC 压力；\n\n> 4.不需要总是使用 useCallback 来缓存传给子组件的回调以防止过度更新；\n\n> 5.不需要担心传了错误的依赖数组给 useEffect/useMemo/useCallback 从而导致回调中使用了过期的值 —— Vue 的依赖追踪是全自动的。\n\n不得不说，青出于蓝而胜于蓝，vue虽然借鉴了react，但是天然的响应式数据，完美的避开了一些react hook遇到的短板~\n\n\n## 总结\n\n1. function component 将会是接下来各大框架发展的一个方向，function天然对TS的友好也是一个重要的影响;\n2. react hook的上手成本相对于vue会难一些，vue天生规避了一些react中比较难处理的地方;\n3. hook一定是大前端的一个趋势，现在才是刚刚开始的阶段：[SwiftUI-Hooks](https://github.com/unixzii/SwiftUI-Hooks), [flutter_hooks](https://github.com/rrousselGit/flutter_hooks)...\n\n> 因为vue3.0的源码尚未发布，有很多实现是猜测的，欢迎提出问题，一起探讨！\n","source":"_posts/前端框架的趋势-hook入门.md","raw":"---\ntitle: 前端框架的趋势-hook入门\ndate: 2019-06-13 11:17:10\ntags: javascript\n---\n\n<img src=\"https://user-gold-cdn.xitu.io/2019/6/13/16b4e61bb6d37766?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\">\n\n## 背景\n\n很荣幸在6月8号那天参加了在上海举办的vueconf，其中尤大本人讲解的vue3.0的介绍中，见识到了vue3.0的一些新特性，其中最重要的一项RFC就是 [Vue Function-based API RFC](https://zhuanlan.zhihu.com/p/68477600)，很巧的在不久前正好研究了一下[react hook](https://react.docschina.org/docs/hooks-intro.html)，感觉2者的在思想上有着异曲同工之妙，所以有了一个想总结一下关于hook的想法，同时看到很多人关于hook的介绍都是分开讲的，当然可能和vue3.0对于这个特性的说明刚刚问世也有一定的关系，so，lets begin~\n\n## 什么是hook\n\n首先我们需要了解什么是hook，拿react的介绍来看，它的定义是：\n> 它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性\n\n在16.8以前的版本中，我们在写react组件的时候，大部分都都是class component，因为基于class的组件react提供了更多的可操作性，比如拥有自己的state，以及一些生命周期的实现，对于复杂的逻辑来讲class的支持程度是更高的：\n\n```javascript\nclass Hello extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  componentDidMount() { // do sth... }\n\n  componentWillUnmount() { // do sth... }\n  \n  // other methods or lifecycle...\n  \n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n```\n\n同时，对于function component来说，react也是支持的，但是function component只能拥有props，不能拥有state，也就是只能实现stateless component：\n\n```javascript\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n```\n\nreact 并没有提供在函数组件中设置state以及生命周期的一些操作方法，所以那个时候，极少的场景下适合采用函数组件，但是16.8版本出现hook以后情况得到了改变，hook的目标就是--**让你在不编写 class 的情况下使用 state 以及其他的 React 特性**，来看个例子：\n\n```javascript\nimport React, { useState } from 'react';\n\nfunction Example() {\n  // 声明一个新的叫做 “count” 的 state 变量\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n\nuseState就是react提供的一个Hook，通过它我们就可以在function组件中设置自己想要的state了，不仅可以使用还可以很方便的去通过setState(注意不是class中的setState，这里指的是上述例子中的setCount)更改，当然，react提供了很多hook来支持不同的行为和操作，下面我们还会再简单介绍，我们在看下vue hook，这是尤大在vueconf上分享的一段代码：\n\n```javascript\nimport { value, computed, watch, onMounted } from 'vue'\n\nconst App = {\n  template: `\n    <div>\n      <span>count is {{ count }}</span>\n      <span>plusOne is {{ plusOne }}</span>\n      <button @click=\"increment\">count++</button>\n    </div>\n  `,\n  setup() {\n    // reactive state\n    const count = value(0)\n    // computed state\n    const plusOne = computed(() => count.value + 1)\n    // method\n    const increment = () => { count.value++ }\n    // watch\n    watch(() => count.value * 2, val => {\n      console.log(`count * 2 is ${val}`)\n    })\n    // lifecycle\n    onMounted(() => {\n      console.log(`mounted`)\n    })\n    // expose bindings on render context\n    return {\n      count,\n      plusOne,\n      increment\n    }\n  }\n}\n```\n从上面的例子中不难看出，和react hook的用法非常相似，并且尤大也有说这个RFC是借鉴了react hook的想法，但是规避了一些react的问题，然后这里解释一下为什么我把vue的这个RFC也称为是hook，因为在react hook的介绍中有这么一句话，什么是hook--Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数，那么vue提供的这些API的作用也是类似的--可以让你在函数组件里“钩入” value(2.x中的data) 及生命周期等特性的函数，所以，暂且就叫vue-hook吧~\n\n\n## hook的时代意义\n\n那么，hook的时代意义是什么？我们从头来说，框架是服务于业务的，业务中很难避免的一个问题就是-- 逻辑复用，同样的功能，同样的组件，在不一样的场合下，我们有时候不得不去写2+次，为了避免耦合，后来各大框架纷纷想出了一些办法：\n- mixin\n- HOC\n- slot\n\n各大框架的使用情况：\n- react 和 vue都曾用过mixin(react 目前已经废弃),\n- Higher-Order-Components(HOC) react中用的相对多一点，vue的话，嵌套template有点。。别扭,\n- slot vue中用的多一些，react基本不需要slot这种用法,\n\n上述这些方法都可以实现逻辑上的复用，但是都有一些额外的问题:\n\n- mixin的问题：\n    - 可能会相互依赖，相互耦合，不利于代码维护；\n    - 不同的mixin中的方法可能会相互冲突;\n    - mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理，\n这样会给代码造成滚雪球式的复杂性\n\n- HOC的问题：\n    - 需要在原组件上进行包裹或者嵌套，如果大量使用HOC，\n将会产生非常多的嵌套，这让调试变得非常困难；\n    - HOC可以劫持props，在不遵守约定的情况下也可能造成冲突\n    - props 也可能造成命名的冲突\n    - wrapper hell\n\n**有没有见过这样的dom结构？**\n\n<img src=\"https://user-gold-cdn.xitu.io/2019/6/12/16b4a8f77e88d56f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"/>\n\n\n这就是wrapper hell的典型代表~\n\n所以，hook的出现是划时代的，它通过function抽离的方式，实现了复杂逻辑的内部封装，根据上述我们提出的问题总结了hook的一些优点：\n\n1. 逻辑代码的复用\n2. 减小了代码体积\n3. 没有this的烦恼\n\n带着这些思想，我们一起看下react和vue分别的实现：\n\n\n## react hook简介\n\n> Dan 讲解hook的视频在[这里](https://www.youtube.com/watch?v=dpw9EHDh2bM&feature=youtu.be)，如果你看不了这个，可以尝试看[官网介绍](https://react.docschina.org/docs/hooks-intro.html)\n\n我们用同样功能的代码来看react hook，实现一个监听鼠标变化，并实时查看位置的功能，同时我们把位置信息挂到title上面，用class component我们要这样写：\n\n```javascript\nimport React, { Component } from 'react';\n\nexport default class MyClassApp extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            x: 0,\n            y: 0\n        };\n        this.handleUpdate = this.handleUpdate.bind(this);\n    }\n    componentDidMount() {\n        document.addEventListener('mousemove', this.handleUpdate);\n    }\n    componentDidUpdate() {\n        const { x, y } = this.state;\n        document.title = `(${x},${y})`;\n    }\n    componentWillUnmount() {\n        window.removeEventListener('mousemove', this.handleUpdate);\n    }\n    handleUpdate(e) {\n        this.setState({\n            x: e.clientX,\n            y: e.clientY\n        });\n    }\n    render() {\n        return (\n            <div>\n                current position x:{this.state.x}, y:{this.state.y}\n            </div>\n        );\n    }\n}\n\n```\n在线代码演示在[这里](https://codesandbox.io/s/xenodochial-butterfly-gzflh)\n\n\n同样的逻辑我们换用hook来实现\n\n```javascript\nimport React, { useState, useEffect } from 'react';\n\n// 自定义hook useMousePostion\nconst useMousePostion = () => {\n    // 使用hookuseState初始化一个state\n    const [postion, setPostion] = useState({ x: 0, y: 0 });\n    function handleMove(e) {\n        setPostion({ x: e.clientX, y: e.clientY });\n    }\n    // 使用useEffect处理class中生命周期可以做到的事情\n    // 注：效果一样，但是实际的原理并不同，有兴趣可以去官网仔细研究\n    useEffect(() => {\n        // 同时可以处理 componentDidMount 以及 componentDidUpdate 中的事情\n        window.addEventListener('mousemove', handleMove);\n        document.title = `(${postion.x},${postion.y})`;\n        return () => {\n            // return的function 可以相当于在组件被卸载的时候执行 类似于 componentWillUnmount\n            window.removeEventListener('mousemove', handleMove);\n        };\n        // [] 是参数，代表deps，也就是说react触发这个hook的时机会和传入的deps有关，内部利用object.is实现\n        // 默认不给参数会在每次render的时候调用，给空数组会导致每次比较是一样的，只执行一次，这里正确的应该是给postion\n    }, [postion]);\n    // postion 可以被直接return，这样达到了逻辑的复用~，哪里需要哪里调用就可以了。\n    return postion;\n};\n\nexport default function App() {\n    const { x, y } = useMousePostion(); // 内部维护自己的postion相关的逻辑\n    return (\n        <div>\n            current position x: {x}, y: {y}\n        </div>\n    );\n}\n\n```\n\n在线代码演示在[这里](https://codesandbox.io/s/hookdemo-8zxh2)\n\n可以看出用了hook之后，我们把关于position的逻辑都放到一个自定义的hook--useMousePostion 中，之后复用是很方便的，而且可以在内部进行维护postion独有的逻辑而不影响外部内容，比起class组件，抽象能力更强。\n\n当然，react hook 想要用好不可能这么简单，讲解的文章也很多，这篇文章不深入太多，只是一个抛砖引玉，下面给大家安利几个不错的资源：\n\n入门：\n- [官网传送门](https://react.docschina.org/docs/hooks-overview.html)\n\n深入：\n- [Dan自己写的关于hook的文章，写的很好强烈安利，深入内部实现](https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/#tldr)\n\n\n另外放一个笔者自己关于用hook实现redux的[**最佳实践**](https://codesandbox.io/s/react-hook-redux-zvx57)，注意是笔者自己这么认为的，欢迎大佬们指出问题，参考的[这个文章](https://www.robinwieruch.de/react-hooks-fetch-data/)\n\n## vue hook简介\n\n> 尤大讲解的视频在[这里](https://mp.weixin.qq.com/s/hBqu1A3gIwMVglb-ZWp8oA)\n\n代码因为vue3.0尚未发布，我们还是看尤大给的demo代码：\n\n```javascript\nimport { value, computed, watch, onMounted } from 'vue'\n\nfunction useMouse() {\n  const x = value(0)\n  const y = value(0)\n  const update = e => {\n    x.value = e.pageX\n    y.value = e.pageY\n  }\n  onMounted(() => {\n    window.addEventListener('mousemove', update)\n  })\n  onUnmounted(() => {\n    window.removeEventListener('mousemove', update)\n  })\n  return { x, y }\n}\n\n// 在组件中使用该函数\nconst Component = {\n  setup() {\n    const { x, y } = useMouse()\n    // 与其它函数配合使用\n    const { z } = useOtherLogic()\n    return { x, y, z }\n  },\n  template: `<div>{{ x }} {{ y }} {{ z }}</div>`\n}\n```\n可以看出来同样我们可以抽离一些需要复用的逻辑到一个单独的函数useMouse中，然后在这个函数里面定义的一些生命周期和value的内容会随着setup函数的调用被“钩入(hook)”到组件上，并且这个函数return出来的数据可以直接被用在模板上，更具体的玩法我们坐等3.0的出现吧。\n\n基础内容不过多介绍，毕竟真实的api还没发布，想了解具体内容的可以来看尤大的[讲解](https://zhuanlan.zhihu.com/p/68477600)\n\n## same & diff Point\n\n看完了2个框架关于hook的实现，我们来做个简单的对比\n\n1. Same Point:\n - 出现的背景，解决的问题是一样的，2个框架都是为了解决逻辑复用过乱，代码体积过大等一些问题，包括this问题，使用function函数我们很少会和this去打交道了。\n - 使用方式类似，都是把可以复用的一些单独的逻辑抽离到一个单独的函数中去，同时返回组件中需要用到的数据，并且内部会自我维护数据的更新，从而触发视图的更新\n\n2. Diff Point:\n\n**实现原理不同**\nreact hook底层是基于链表实现，调用的条件是每次组件被render的时候都会顺序执行所有的hooks，所以下面的代码会报错\n```javascript\nfunction App(){\n    const [name, setName] = useState('demo');\n    if(condition){\n        const [val, setVal] = useState('');\n    }\n}\n```\n因为底层是链表，每一个hook的next是指向下一个hook的，if会导致顺序不正确，从而导致报错，所以react是不允许这样使用hook的。\n\nvue hook只会在setup函数被调用的时候被注册一次，react数据更改的时候，会导致重新render，重新render又会重新把hooks重新注册一次，所以react的上手难度更高一些，而vue之所以能避开这些麻烦的问题，根本原因在于它对数据的响应是基于proxy的，这种场景下，只要任何一个更改data的地方，相关的function或者template都会被重新计算，因此避开了react可能遇到的性能上的问题\n\n当然react对这些都有解决方案，想了解的同学可以去看官网有介绍，比如useCallback，useMemo等hook的作用，我们看下尤大对vue和react hook的总结对比：\n\n> 1.整体上更符合 JavaScript 的直觉；\n\n> 2.不受调用顺序的限制，可以有条件地被调用；\n\n> 3.不会在后续更新时不断产生大量的内联函数而影响引擎优化或是导致 GC 压力；\n\n> 4.不需要总是使用 useCallback 来缓存传给子组件的回调以防止过度更新；\n\n> 5.不需要担心传了错误的依赖数组给 useEffect/useMemo/useCallback 从而导致回调中使用了过期的值 —— Vue 的依赖追踪是全自动的。\n\n不得不说，青出于蓝而胜于蓝，vue虽然借鉴了react，但是天然的响应式数据，完美的避开了一些react hook遇到的短板~\n\n\n## 总结\n\n1. function component 将会是接下来各大框架发展的一个方向，function天然对TS的友好也是一个重要的影响;\n2. react hook的上手成本相对于vue会难一些，vue天生规避了一些react中比较难处理的地方;\n3. hook一定是大前端的一个趋势，现在才是刚刚开始的阶段：[SwiftUI-Hooks](https://github.com/unixzii/SwiftUI-Hooks), [flutter_hooks](https://github.com/rrousselGit/flutter_hooks)...\n\n> 因为vue3.0的源码尚未发布，有很多实现是猜测的，欢迎提出问题，一起探讨！\n","slug":"前端框架的趋势-hook入门","published":1,"updated":"2019-06-20T03:26:35.518Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx4afn4w0005q67wvt5ksm9w","content":"<img src=\"https://user-gold-cdn.xitu.io/2019/6/13/16b4e61bb6d37766?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\">\n\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>很荣幸在6月8号那天参加了在上海举办的vueconf，其中尤大本人讲解的vue3.0的介绍中，见识到了vue3.0的一些新特性，其中最重要的一项RFC就是 <a href=\"https://zhuanlan.zhihu.com/p/68477600\" target=\"_blank\" rel=\"noopener\">Vue Function-based API RFC</a>，很巧的在不久前正好研究了一下<a href=\"https://react.docschina.org/docs/hooks-intro.html\" target=\"_blank\" rel=\"noopener\">react hook</a>，感觉2者的在思想上有着异曲同工之妙，所以有了一个想总结一下关于hook的想法，同时看到很多人关于hook的介绍都是分开讲的，当然可能和vue3.0对于这个特性的说明刚刚问世也有一定的关系，so，lets begin~</p>\n<h2 id=\"什么是hook\"><a href=\"#什么是hook\" class=\"headerlink\" title=\"什么是hook\"></a>什么是hook</h2><p>首先我们需要了解什么是hook，拿react的介绍来看，它的定义是：</p>\n<blockquote>\n<p>它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性</p>\n</blockquote>\n<p>在16.8以前的版本中，我们在写react组件的时候，大部分都都是class component，因为基于class的组件react提供了更多的可操作性，比如拥有自己的state，以及一些生命周期的实现，对于复杂的逻辑来讲class的支持程度是更高的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">date</span>: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123; <span class=\"comment\">// do sth... &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  componentWillUnmount() &#123; <span class=\"comment\">// do sth... &#125;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// other methods or lifecycle...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class=\"line\">        &lt;h2&gt;It is &#123;<span class=\"keyword\">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时，对于function component来说，react也是支持的，但是function component只能拥有props，不能拥有state，也就是只能实现stateless component：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>react 并没有提供在函数组件中设置state以及生命周期的一些操作方法，所以那个时候，极少的场景下适合采用函数组件，但是16.8版本出现hook以后情况得到了改变，hook的目标就是–<strong>让你在不编写 class 的情况下使用 state 以及其他的 React 特性</strong>，来看个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 声明一个新的叫做 “count” 的 state 变量</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        Click me</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>button&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>useState就是react提供的一个Hook，通过它我们就可以在function组件中设置自己想要的state了，不仅可以使用还可以很方便的去通过setState(注意不是class中的setState，这里指的是上述例子中的setCount)更改，当然，react提供了很多hook来支持不同的行为和操作，下面我们还会再简单介绍，我们在看下vue hook，这是尤大在vueconf上分享的一段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; value, computed, watch, onMounted &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> App = &#123;</span><br><span class=\"line\">  template: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;span&gt;count is &#123;&#123; count &#125;&#125;&lt;/span&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;span&gt;plusOne is &#123;&#123; plusOne &#125;&#125;&lt;/span&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;button @click=\"increment\"&gt;count++&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">  `</span>,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// reactive state</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> count = value(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">// computed state</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> plusOne = computed(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> count.value + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"comment\">// method</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> increment = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; count.value++ &#125;</span><br><span class=\"line\">    <span class=\"comment\">// watch</span></span><br><span class=\"line\">    watch(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> count.value * <span class=\"number\">2</span>, val =&gt; &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`count * 2 is <span class=\"subst\">$&#123;val&#125;</span>`</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">// lifecycle</span></span><br><span class=\"line\">    onMounted(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`mounted`</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">// expose bindings on render context</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      count,</span><br><span class=\"line\">      plusOne,</span><br><span class=\"line\">      increment</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上面的例子中不难看出，和react hook的用法非常相似，并且尤大也有说这个RFC是借鉴了react hook的想法，但是规避了一些react的问题，然后这里解释一下为什么我把vue的这个RFC也称为是hook，因为在react hook的介绍中有这么一句话，什么是hook–Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数，那么vue提供的这些API的作用也是类似的–可以让你在函数组件里“钩入” value(2.x中的data) 及生命周期等特性的函数，所以，暂且就叫vue-hook吧~</p>\n<h2 id=\"hook的时代意义\"><a href=\"#hook的时代意义\" class=\"headerlink\" title=\"hook的时代意义\"></a>hook的时代意义</h2><p>那么，hook的时代意义是什么？我们从头来说，框架是服务于业务的，业务中很难避免的一个问题就是– 逻辑复用，同样的功能，同样的组件，在不一样的场合下，我们有时候不得不去写2+次，为了避免耦合，后来各大框架纷纷想出了一些办法：</p>\n<ul>\n<li>mixin</li>\n<li>HOC</li>\n<li>slot</li>\n</ul>\n<p>各大框架的使用情况：</p>\n<ul>\n<li>react 和 vue都曾用过mixin(react 目前已经废弃),</li>\n<li>Higher-Order-Components(HOC) react中用的相对多一点，vue的话，嵌套template有点。。别扭,</li>\n<li>slot vue中用的多一些，react基本不需要slot这种用法,</li>\n</ul>\n<p>上述这些方法都可以实现逻辑上的复用，但是都有一些额外的问题:</p>\n<ul>\n<li><p>mixin的问题：</p>\n<ul>\n<li>可能会相互依赖，相互耦合，不利于代码维护；</li>\n<li>不同的mixin中的方法可能会相互冲突;</li>\n<li>mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理，<br>这样会给代码造成滚雪球式的复杂性</li>\n</ul>\n</li>\n<li><p>HOC的问题：</p>\n<ul>\n<li>需要在原组件上进行包裹或者嵌套，如果大量使用HOC，<br>将会产生非常多的嵌套，这让调试变得非常困难；</li>\n<li>HOC可以劫持props，在不遵守约定的情况下也可能造成冲突</li>\n<li>props 也可能造成命名的冲突</li>\n<li>wrapper hell</li>\n</ul>\n</li>\n</ul>\n<p><strong>有没有见过这样的dom结构？</strong></p>\n<img src=\"https://user-gold-cdn.xitu.io/2019/6/12/16b4a8f77e88d56f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\">\n\n\n<p>这就是wrapper hell的典型代表~</p>\n<p>所以，hook的出现是划时代的，它通过function抽离的方式，实现了复杂逻辑的内部封装，根据上述我们提出的问题总结了hook的一些优点：</p>\n<ol>\n<li>逻辑代码的复用</li>\n<li>减小了代码体积</li>\n<li>没有this的烦恼</li>\n</ol>\n<p>带着这些思想，我们一起看下react和vue分别的实现：</p>\n<h2 id=\"react-hook简介\"><a href=\"#react-hook简介\" class=\"headerlink\" title=\"react hook简介\"></a>react hook简介</h2><blockquote>\n<p>Dan 讲解hook的视频在<a href=\"https://www.youtube.com/watch?v=dpw9EHDh2bM&feature=youtu.be\" target=\"_blank\" rel=\"noopener\">这里</a>，如果你看不了这个，可以尝试看<a href=\"https://react.docschina.org/docs/hooks-intro.html\" target=\"_blank\" rel=\"noopener\">官网介绍</a></p>\n</blockquote>\n<p>我们用同样功能的代码来看react hook，实现一个监听鼠标变化，并实时查看位置的功能，同时我们把位置信息挂到title上面，用class component我们要这样写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClassApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">            x: <span class=\"number\">0</span>,</span><br><span class=\"line\">            y: <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handleUpdate = <span class=\"keyword\">this</span>.handleUpdate.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'mousemove'</span>, <span class=\"keyword\">this</span>.handleUpdate);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentDidUpdate() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123; x, y &#125; = <span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.title = <span class=\"string\">`(<span class=\"subst\">$&#123;x&#125;</span>,<span class=\"subst\">$&#123;y&#125;</span>)`</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentWillUnmount() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.removeEventListener(<span class=\"string\">'mousemove'</span>, <span class=\"keyword\">this</span>.handleUpdate);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    handleUpdate(e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">            x: e.clientX,</span><br><span class=\"line\">            y: e.clientY</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                current position x:&#123;<span class=\"keyword\">this</span>.state.x&#125;, <span class=\"attr\">y</span>:&#123;<span class=\"keyword\">this</span>.state.y&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>在线代码演示在<a href=\"https://codesandbox.io/s/xenodochial-butterfly-gzflh\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<p>同样的逻辑我们换用hook来实现</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState, useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自定义hook useMousePostion</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> useMousePostion = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用hookuseState初始化一个state</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> [postion, setPostion] = useState(&#123; <span class=\"attr\">x</span>: <span class=\"number\">0</span>, <span class=\"attr\">y</span>: <span class=\"number\">0</span> &#125;);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleMove</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        setPostion(&#123; <span class=\"attr\">x</span>: e.clientX, <span class=\"attr\">y</span>: e.clientY &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 使用useEffect处理class中生命周期可以做到的事情</span></span><br><span class=\"line\">    <span class=\"comment\">// 注：效果一样，但是实际的原理并不同，有兴趣可以去官网仔细研究</span></span><br><span class=\"line\">    useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 同时可以处理 componentDidMount 以及 componentDidUpdate 中的事情</span></span><br><span class=\"line\">        <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'mousemove'</span>, handleMove);</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.title = <span class=\"string\">`(<span class=\"subst\">$&#123;postion.x&#125;</span>,<span class=\"subst\">$&#123;postion.y&#125;</span>)`</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// return的function 可以相当于在组件被卸载的时候执行 类似于 componentWillUnmount</span></span><br><span class=\"line\">            <span class=\"built_in\">window</span>.removeEventListener(<span class=\"string\">'mousemove'</span>, handleMove);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">// [] 是参数，代表deps，也就是说react触发这个hook的时机会和传入的deps有关，内部利用object.is实现</span></span><br><span class=\"line\">        <span class=\"comment\">// 默认不给参数会在每次render的时候调用，给空数组会导致每次比较是一样的，只执行一次，这里正确的应该是给postion</span></span><br><span class=\"line\">    &#125;, [postion]);</span><br><span class=\"line\">    <span class=\"comment\">// postion 可以被直接return，这样达到了逻辑的复用~，哪里需要哪里调用就可以了。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> postion;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">App</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; x, y &#125; = useMousePostion(); <span class=\"comment\">// 内部维护自己的postion相关的逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            current position x: &#123;x&#125;, <span class=\"attr\">y</span>: &#123;y&#125;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>在线代码演示在<a href=\"https://codesandbox.io/s/hookdemo-8zxh2\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<p>可以看出用了hook之后，我们把关于position的逻辑都放到一个自定义的hook–useMousePostion 中，之后复用是很方便的，而且可以在内部进行维护postion独有的逻辑而不影响外部内容，比起class组件，抽象能力更强。</p>\n<p>当然，react hook 想要用好不可能这么简单，讲解的文章也很多，这篇文章不深入太多，只是一个抛砖引玉，下面给大家安利几个不错的资源：</p>\n<p>入门：</p>\n<ul>\n<li><a href=\"https://react.docschina.org/docs/hooks-overview.html\" target=\"_blank\" rel=\"noopener\">官网传送门</a></li>\n</ul>\n<p>深入：</p>\n<ul>\n<li><a href=\"https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/#tldr\" target=\"_blank\" rel=\"noopener\">Dan自己写的关于hook的文章，写的很好强烈安利，深入内部实现</a></li>\n</ul>\n<p>另外放一个笔者自己关于用hook实现redux的<a href=\"https://codesandbox.io/s/react-hook-redux-zvx57\" target=\"_blank\" rel=\"noopener\"><strong>最佳实践</strong></a>，注意是笔者自己这么认为的，欢迎大佬们指出问题，参考的<a href=\"https://www.robinwieruch.de/react-hooks-fetch-data/\" target=\"_blank\" rel=\"noopener\">这个文章</a></p>\n<h2 id=\"vue-hook简介\"><a href=\"#vue-hook简介\" class=\"headerlink\" title=\"vue hook简介\"></a>vue hook简介</h2><blockquote>\n<p>尤大讲解的视频在<a href=\"https://mp.weixin.qq.com/s/hBqu1A3gIwMVglb-ZWp8oA\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n</blockquote>\n<p>代码因为vue3.0尚未发布，我们还是看尤大给的demo代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; value, computed, watch, onMounted &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useMouse</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> x = value(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> y = value(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> update = <span class=\"function\"><span class=\"params\">e</span> =&gt;</span> &#123;</span><br><span class=\"line\">    x.value = e.pageX</span><br><span class=\"line\">    y.value = e.pageY</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  onMounted(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'mousemove'</span>, update)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  onUnmounted(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.removeEventListener(<span class=\"string\">'mousemove'</span>, update)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; x, y &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在组件中使用该函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Component = &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; x, y &#125; = useMouse()</span><br><span class=\"line\">    <span class=\"comment\">// 与其它函数配合使用</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; z &#125; = useOtherLogic()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; x, y, z &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  template: <span class=\"string\">`&lt;div&gt;&#123;&#123; x &#125;&#125; &#123;&#123; y &#125;&#125; &#123;&#123; z &#125;&#125;&lt;/div&gt;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看出来同样我们可以抽离一些需要复用的逻辑到一个单独的函数useMouse中，然后在这个函数里面定义的一些生命周期和value的内容会随着setup函数的调用被“钩入(hook)”到组件上，并且这个函数return出来的数据可以直接被用在模板上，更具体的玩法我们坐等3.0的出现吧。</p>\n<p>基础内容不过多介绍，毕竟真实的api还没发布，想了解具体内容的可以来看尤大的<a href=\"https://zhuanlan.zhihu.com/p/68477600\" target=\"_blank\" rel=\"noopener\">讲解</a></p>\n<h2 id=\"same-amp-diff-Point\"><a href=\"#same-amp-diff-Point\" class=\"headerlink\" title=\"same &amp; diff Point\"></a>same &amp; diff Point</h2><p>看完了2个框架关于hook的实现，我们来做个简单的对比</p>\n<ol>\n<li><p>Same Point:</p>\n<ul>\n<li>出现的背景，解决的问题是一样的，2个框架都是为了解决逻辑复用过乱，代码体积过大等一些问题，包括this问题，使用function函数我们很少会和this去打交道了。</li>\n<li>使用方式类似，都是把可以复用的一些单独的逻辑抽离到一个单独的函数中去，同时返回组件中需要用到的数据，并且内部会自我维护数据的更新，从而触发视图的更新</li>\n</ul>\n</li>\n<li><p>Diff Point:</p>\n</li>\n</ol>\n<p><strong>实现原理不同</strong><br>react hook底层是基于链表实现，调用的条件是每次组件被render的时候都会顺序执行所有的hooks，所以下面的代码会报错</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">App</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [name, setName] = useState(<span class=\"string\">'demo'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(condition)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> [val, setVal] = useState(<span class=\"string\">''</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为底层是链表，每一个hook的next是指向下一个hook的，if会导致顺序不正确，从而导致报错，所以react是不允许这样使用hook的。</p>\n<p>vue hook只会在setup函数被调用的时候被注册一次，react数据更改的时候，会导致重新render，重新render又会重新把hooks重新注册一次，所以react的上手难度更高一些，而vue之所以能避开这些麻烦的问题，根本原因在于它对数据的响应是基于proxy的，这种场景下，只要任何一个更改data的地方，相关的function或者template都会被重新计算，因此避开了react可能遇到的性能上的问题</p>\n<p>当然react对这些都有解决方案，想了解的同学可以去看官网有介绍，比如useCallback，useMemo等hook的作用，我们看下尤大对vue和react hook的总结对比：</p>\n<blockquote>\n<p>1.整体上更符合 JavaScript 的直觉；</p>\n</blockquote>\n<blockquote>\n<p>2.不受调用顺序的限制，可以有条件地被调用；</p>\n</blockquote>\n<blockquote>\n<p>3.不会在后续更新时不断产生大量的内联函数而影响引擎优化或是导致 GC 压力；</p>\n</blockquote>\n<blockquote>\n<p>4.不需要总是使用 useCallback 来缓存传给子组件的回调以防止过度更新；</p>\n</blockquote>\n<blockquote>\n<p>5.不需要担心传了错误的依赖数组给 useEffect/useMemo/useCallback 从而导致回调中使用了过期的值 —— Vue 的依赖追踪是全自动的。</p>\n</blockquote>\n<p>不得不说，青出于蓝而胜于蓝，vue虽然借鉴了react，但是天然的响应式数据，完美的避开了一些react hook遇到的短板~</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>function component 将会是接下来各大框架发展的一个方向，function天然对TS的友好也是一个重要的影响;</li>\n<li>react hook的上手成本相对于vue会难一些，vue天生规避了一些react中比较难处理的地方;</li>\n<li>hook一定是大前端的一个趋势，现在才是刚刚开始的阶段：<a href=\"https://github.com/unixzii/SwiftUI-Hooks\" target=\"_blank\" rel=\"noopener\">SwiftUI-Hooks</a>, <a href=\"https://github.com/rrousselGit/flutter_hooks\" target=\"_blank\" rel=\"noopener\">flutter_hooks</a>…</li>\n</ol>\n<blockquote>\n<p>因为vue3.0的源码尚未发布，有很多实现是猜测的，欢迎提出问题，一起探讨！</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<img src=\"https://user-gold-cdn.xitu.io/2019/6/13/16b4e61bb6d37766?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\">\n\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>很荣幸在6月8号那天参加了在上海举办的vueconf，其中尤大本人讲解的vue3.0的介绍中，见识到了vue3.0的一些新特性，其中最重要的一项RFC就是 <a href=\"https://zhuanlan.zhihu.com/p/68477600\" target=\"_blank\" rel=\"noopener\">Vue Function-based API RFC</a>，很巧的在不久前正好研究了一下<a href=\"https://react.docschina.org/docs/hooks-intro.html\" target=\"_blank\" rel=\"noopener\">react hook</a>，感觉2者的在思想上有着异曲同工之妙，所以有了一个想总结一下关于hook的想法，同时看到很多人关于hook的介绍都是分开讲的，当然可能和vue3.0对于这个特性的说明刚刚问世也有一定的关系，so，lets begin~</p>\n<h2 id=\"什么是hook\"><a href=\"#什么是hook\" class=\"headerlink\" title=\"什么是hook\"></a>什么是hook</h2><p>首先我们需要了解什么是hook，拿react的介绍来看，它的定义是：</p>\n<blockquote>\n<p>它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性</p>\n</blockquote>\n<p>在16.8以前的版本中，我们在写react组件的时候，大部分都都是class component，因为基于class的组件react提供了更多的可操作性，比如拥有自己的state，以及一些生命周期的实现，对于复杂的逻辑来讲class的支持程度是更高的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">date</span>: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123; <span class=\"comment\">// do sth... &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  componentWillUnmount() &#123; <span class=\"comment\">// do sth... &#125;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// other methods or lifecycle...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class=\"line\">        &lt;h2&gt;It is &#123;<span class=\"keyword\">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class=\"regexp\">/h2&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时，对于function component来说，react也是支持的，但是function component只能拥有props，不能拥有state，也就是只能实现stateless component：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Welcome</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>react 并没有提供在函数组件中设置state以及生命周期的一些操作方法，所以那个时候，极少的场景下适合采用函数组件，但是16.8版本出现hook以后情况得到了改变，hook的目标就是–<strong>让你在不编写 class 的情况下使用 state 以及其他的 React 特性</strong>，来看个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 声明一个新的叫做 “count” 的 state 变量</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        Click me</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>button&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>useState就是react提供的一个Hook，通过它我们就可以在function组件中设置自己想要的state了，不仅可以使用还可以很方便的去通过setState(注意不是class中的setState，这里指的是上述例子中的setCount)更改，当然，react提供了很多hook来支持不同的行为和操作，下面我们还会再简单介绍，我们在看下vue hook，这是尤大在vueconf上分享的一段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; value, computed, watch, onMounted &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> App = &#123;</span><br><span class=\"line\">  template: <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;span&gt;count is &#123;&#123; count &#125;&#125;&lt;/span&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;span&gt;plusOne is &#123;&#123; plusOne &#125;&#125;&lt;/span&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;button @click=\"increment\"&gt;count++&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">  `</span>,</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// reactive state</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> count = value(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">// computed state</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> plusOne = computed(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> count.value + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"comment\">// method</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> increment = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; count.value++ &#125;</span><br><span class=\"line\">    <span class=\"comment\">// watch</span></span><br><span class=\"line\">    watch(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> count.value * <span class=\"number\">2</span>, val =&gt; &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`count * 2 is <span class=\"subst\">$&#123;val&#125;</span>`</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">// lifecycle</span></span><br><span class=\"line\">    onMounted(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`mounted`</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">// expose bindings on render context</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      count,</span><br><span class=\"line\">      plusOne,</span><br><span class=\"line\">      increment</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上面的例子中不难看出，和react hook的用法非常相似，并且尤大也有说这个RFC是借鉴了react hook的想法，但是规避了一些react的问题，然后这里解释一下为什么我把vue的这个RFC也称为是hook，因为在react hook的介绍中有这么一句话，什么是hook–Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数，那么vue提供的这些API的作用也是类似的–可以让你在函数组件里“钩入” value(2.x中的data) 及生命周期等特性的函数，所以，暂且就叫vue-hook吧~</p>\n<h2 id=\"hook的时代意义\"><a href=\"#hook的时代意义\" class=\"headerlink\" title=\"hook的时代意义\"></a>hook的时代意义</h2><p>那么，hook的时代意义是什么？我们从头来说，框架是服务于业务的，业务中很难避免的一个问题就是– 逻辑复用，同样的功能，同样的组件，在不一样的场合下，我们有时候不得不去写2+次，为了避免耦合，后来各大框架纷纷想出了一些办法：</p>\n<ul>\n<li>mixin</li>\n<li>HOC</li>\n<li>slot</li>\n</ul>\n<p>各大框架的使用情况：</p>\n<ul>\n<li>react 和 vue都曾用过mixin(react 目前已经废弃),</li>\n<li>Higher-Order-Components(HOC) react中用的相对多一点，vue的话，嵌套template有点。。别扭,</li>\n<li>slot vue中用的多一些，react基本不需要slot这种用法,</li>\n</ul>\n<p>上述这些方法都可以实现逻辑上的复用，但是都有一些额外的问题:</p>\n<ul>\n<li><p>mixin的问题：</p>\n<ul>\n<li>可能会相互依赖，相互耦合，不利于代码维护；</li>\n<li>不同的mixin中的方法可能会相互冲突;</li>\n<li>mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理，<br>这样会给代码造成滚雪球式的复杂性</li>\n</ul>\n</li>\n<li><p>HOC的问题：</p>\n<ul>\n<li>需要在原组件上进行包裹或者嵌套，如果大量使用HOC，<br>将会产生非常多的嵌套，这让调试变得非常困难；</li>\n<li>HOC可以劫持props，在不遵守约定的情况下也可能造成冲突</li>\n<li>props 也可能造成命名的冲突</li>\n<li>wrapper hell</li>\n</ul>\n</li>\n</ul>\n<p><strong>有没有见过这样的dom结构？</strong></p>\n<img src=\"https://user-gold-cdn.xitu.io/2019/6/12/16b4a8f77e88d56f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\">\n\n\n<p>这就是wrapper hell的典型代表~</p>\n<p>所以，hook的出现是划时代的，它通过function抽离的方式，实现了复杂逻辑的内部封装，根据上述我们提出的问题总结了hook的一些优点：</p>\n<ol>\n<li>逻辑代码的复用</li>\n<li>减小了代码体积</li>\n<li>没有this的烦恼</li>\n</ol>\n<p>带着这些思想，我们一起看下react和vue分别的实现：</p>\n<h2 id=\"react-hook简介\"><a href=\"#react-hook简介\" class=\"headerlink\" title=\"react hook简介\"></a>react hook简介</h2><blockquote>\n<p>Dan 讲解hook的视频在<a href=\"https://www.youtube.com/watch?v=dpw9EHDh2bM&feature=youtu.be\" target=\"_blank\" rel=\"noopener\">这里</a>，如果你看不了这个，可以尝试看<a href=\"https://react.docschina.org/docs/hooks-intro.html\" target=\"_blank\" rel=\"noopener\">官网介绍</a></p>\n</blockquote>\n<p>我们用同样功能的代码来看react hook，实现一个监听鼠标变化，并实时查看位置的功能，同时我们把位置信息挂到title上面，用class component我们要这样写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClassApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">            x: <span class=\"number\">0</span>,</span><br><span class=\"line\">            y: <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handleUpdate = <span class=\"keyword\">this</span>.handleUpdate.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'mousemove'</span>, <span class=\"keyword\">this</span>.handleUpdate);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentDidUpdate() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123; x, y &#125; = <span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.title = <span class=\"string\">`(<span class=\"subst\">$&#123;x&#125;</span>,<span class=\"subst\">$&#123;y&#125;</span>)`</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentWillUnmount() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.removeEventListener(<span class=\"string\">'mousemove'</span>, <span class=\"keyword\">this</span>.handleUpdate);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    handleUpdate(e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">            x: e.clientX,</span><br><span class=\"line\">            y: e.clientY</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                current position x:&#123;<span class=\"keyword\">this</span>.state.x&#125;, <span class=\"attr\">y</span>:&#123;<span class=\"keyword\">this</span>.state.y&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        );</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>在线代码演示在<a href=\"https://codesandbox.io/s/xenodochial-butterfly-gzflh\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<p>同样的逻辑我们换用hook来实现</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState, useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自定义hook useMousePostion</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> useMousePostion = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用hookuseState初始化一个state</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> [postion, setPostion] = useState(&#123; <span class=\"attr\">x</span>: <span class=\"number\">0</span>, <span class=\"attr\">y</span>: <span class=\"number\">0</span> &#125;);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleMove</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        setPostion(&#123; <span class=\"attr\">x</span>: e.clientX, <span class=\"attr\">y</span>: e.clientY &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 使用useEffect处理class中生命周期可以做到的事情</span></span><br><span class=\"line\">    <span class=\"comment\">// 注：效果一样，但是实际的原理并不同，有兴趣可以去官网仔细研究</span></span><br><span class=\"line\">    useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 同时可以处理 componentDidMount 以及 componentDidUpdate 中的事情</span></span><br><span class=\"line\">        <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'mousemove'</span>, handleMove);</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.title = <span class=\"string\">`(<span class=\"subst\">$&#123;postion.x&#125;</span>,<span class=\"subst\">$&#123;postion.y&#125;</span>)`</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// return的function 可以相当于在组件被卸载的时候执行 类似于 componentWillUnmount</span></span><br><span class=\"line\">            <span class=\"built_in\">window</span>.removeEventListener(<span class=\"string\">'mousemove'</span>, handleMove);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">// [] 是参数，代表deps，也就是说react触发这个hook的时机会和传入的deps有关，内部利用object.is实现</span></span><br><span class=\"line\">        <span class=\"comment\">// 默认不给参数会在每次render的时候调用，给空数组会导致每次比较是一样的，只执行一次，这里正确的应该是给postion</span></span><br><span class=\"line\">    &#125;, [postion]);</span><br><span class=\"line\">    <span class=\"comment\">// postion 可以被直接return，这样达到了逻辑的复用~，哪里需要哪里调用就可以了。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> postion;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">App</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; x, y &#125; = useMousePostion(); <span class=\"comment\">// 内部维护自己的postion相关的逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            current position x: &#123;x&#125;, <span class=\"attr\">y</span>: &#123;y&#125;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>在线代码演示在<a href=\"https://codesandbox.io/s/hookdemo-8zxh2\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<p>可以看出用了hook之后，我们把关于position的逻辑都放到一个自定义的hook–useMousePostion 中，之后复用是很方便的，而且可以在内部进行维护postion独有的逻辑而不影响外部内容，比起class组件，抽象能力更强。</p>\n<p>当然，react hook 想要用好不可能这么简单，讲解的文章也很多，这篇文章不深入太多，只是一个抛砖引玉，下面给大家安利几个不错的资源：</p>\n<p>入门：</p>\n<ul>\n<li><a href=\"https://react.docschina.org/docs/hooks-overview.html\" target=\"_blank\" rel=\"noopener\">官网传送门</a></li>\n</ul>\n<p>深入：</p>\n<ul>\n<li><a href=\"https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/#tldr\" target=\"_blank\" rel=\"noopener\">Dan自己写的关于hook的文章，写的很好强烈安利，深入内部实现</a></li>\n</ul>\n<p>另外放一个笔者自己关于用hook实现redux的<a href=\"https://codesandbox.io/s/react-hook-redux-zvx57\" target=\"_blank\" rel=\"noopener\"><strong>最佳实践</strong></a>，注意是笔者自己这么认为的，欢迎大佬们指出问题，参考的<a href=\"https://www.robinwieruch.de/react-hooks-fetch-data/\" target=\"_blank\" rel=\"noopener\">这个文章</a></p>\n<h2 id=\"vue-hook简介\"><a href=\"#vue-hook简介\" class=\"headerlink\" title=\"vue hook简介\"></a>vue hook简介</h2><blockquote>\n<p>尤大讲解的视频在<a href=\"https://mp.weixin.qq.com/s/hBqu1A3gIwMVglb-ZWp8oA\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n</blockquote>\n<p>代码因为vue3.0尚未发布，我们还是看尤大给的demo代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; value, computed, watch, onMounted &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useMouse</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> x = value(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> y = value(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> update = <span class=\"function\"><span class=\"params\">e</span> =&gt;</span> &#123;</span><br><span class=\"line\">    x.value = e.pageX</span><br><span class=\"line\">    y.value = e.pageY</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  onMounted(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'mousemove'</span>, update)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  onUnmounted(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.removeEventListener(<span class=\"string\">'mousemove'</span>, update)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; x, y &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在组件中使用该函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Component = &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; x, y &#125; = useMouse()</span><br><span class=\"line\">    <span class=\"comment\">// 与其它函数配合使用</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; z &#125; = useOtherLogic()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; x, y, z &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  template: <span class=\"string\">`&lt;div&gt;&#123;&#123; x &#125;&#125; &#123;&#123; y &#125;&#125; &#123;&#123; z &#125;&#125;&lt;/div&gt;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看出来同样我们可以抽离一些需要复用的逻辑到一个单独的函数useMouse中，然后在这个函数里面定义的一些生命周期和value的内容会随着setup函数的调用被“钩入(hook)”到组件上，并且这个函数return出来的数据可以直接被用在模板上，更具体的玩法我们坐等3.0的出现吧。</p>\n<p>基础内容不过多介绍，毕竟真实的api还没发布，想了解具体内容的可以来看尤大的<a href=\"https://zhuanlan.zhihu.com/p/68477600\" target=\"_blank\" rel=\"noopener\">讲解</a></p>\n<h2 id=\"same-amp-diff-Point\"><a href=\"#same-amp-diff-Point\" class=\"headerlink\" title=\"same &amp; diff Point\"></a>same &amp; diff Point</h2><p>看完了2个框架关于hook的实现，我们来做个简单的对比</p>\n<ol>\n<li><p>Same Point:</p>\n<ul>\n<li>出现的背景，解决的问题是一样的，2个框架都是为了解决逻辑复用过乱，代码体积过大等一些问题，包括this问题，使用function函数我们很少会和this去打交道了。</li>\n<li>使用方式类似，都是把可以复用的一些单独的逻辑抽离到一个单独的函数中去，同时返回组件中需要用到的数据，并且内部会自我维护数据的更新，从而触发视图的更新</li>\n</ul>\n</li>\n<li><p>Diff Point:</p>\n</li>\n</ol>\n<p><strong>实现原理不同</strong><br>react hook底层是基于链表实现，调用的条件是每次组件被render的时候都会顺序执行所有的hooks，所以下面的代码会报错</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">App</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [name, setName] = useState(<span class=\"string\">'demo'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(condition)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> [val, setVal] = useState(<span class=\"string\">''</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为底层是链表，每一个hook的next是指向下一个hook的，if会导致顺序不正确，从而导致报错，所以react是不允许这样使用hook的。</p>\n<p>vue hook只会在setup函数被调用的时候被注册一次，react数据更改的时候，会导致重新render，重新render又会重新把hooks重新注册一次，所以react的上手难度更高一些，而vue之所以能避开这些麻烦的问题，根本原因在于它对数据的响应是基于proxy的，这种场景下，只要任何一个更改data的地方，相关的function或者template都会被重新计算，因此避开了react可能遇到的性能上的问题</p>\n<p>当然react对这些都有解决方案，想了解的同学可以去看官网有介绍，比如useCallback，useMemo等hook的作用，我们看下尤大对vue和react hook的总结对比：</p>\n<blockquote>\n<p>1.整体上更符合 JavaScript 的直觉；</p>\n</blockquote>\n<blockquote>\n<p>2.不受调用顺序的限制，可以有条件地被调用；</p>\n</blockquote>\n<blockquote>\n<p>3.不会在后续更新时不断产生大量的内联函数而影响引擎优化或是导致 GC 压力；</p>\n</blockquote>\n<blockquote>\n<p>4.不需要总是使用 useCallback 来缓存传给子组件的回调以防止过度更新；</p>\n</blockquote>\n<blockquote>\n<p>5.不需要担心传了错误的依赖数组给 useEffect/useMemo/useCallback 从而导致回调中使用了过期的值 —— Vue 的依赖追踪是全自动的。</p>\n</blockquote>\n<p>不得不说，青出于蓝而胜于蓝，vue虽然借鉴了react，但是天然的响应式数据，完美的避开了一些react hook遇到的短板~</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>function component 将会是接下来各大框架发展的一个方向，function天然对TS的友好也是一个重要的影响;</li>\n<li>react hook的上手成本相对于vue会难一些，vue天生规避了一些react中比较难处理的地方;</li>\n<li>hook一定是大前端的一个趋势，现在才是刚刚开始的阶段：<a href=\"https://github.com/unixzii/SwiftUI-Hooks\" target=\"_blank\" rel=\"noopener\">SwiftUI-Hooks</a>, <a href=\"https://github.com/rrousselGit/flutter_hooks\" target=\"_blank\" rel=\"noopener\">flutter_hooks</a>…</li>\n</ol>\n<blockquote>\n<p>因为vue3.0的源码尚未发布，有很多实现是猜测的，欢迎提出问题，一起探讨！</p>\n</blockquote>\n"},{"title":"常见网络攻击","date":"2019-05-18T10:09:30.000Z","_content":"\n## XSS 攻击\n> xss【cross site script】跨站脚本攻击，因为缩写和css相同，因此别名叫xss攻击\n- 非持久性攻击\n    通过发送带恶意脚本参数的url给用户，诱骗用户进行点击，从而获取到用户的信息，特点是：难发现，即时性，需要进行诱点\n\n- 持久性攻击\n    通过提交表单事件的时候，把恶意代码送入数据库，当前端读取的时候，从数据库中拿到并渲染执行，特点是：持久性，危害面广\n    防御方式：前后端在涉及到提交内容和直接渲染数据库内容的时候务必转义\n\n## CSRF 攻击\n> csrf【cross-site request forgery】跨站请求伪造攻击\n- 具体流程：如果A网站没有做任何对于csrf的防御工作，当用户登录A网站后，产生了cookie，cookie携带了一些私密的用户信息，然后用户点击了服务器B给的一个url，从而带上了cookie到B服务器中，B拿到之后就可以模拟用户的行为来操作实际用户的账户了。\n- 防御方式：用户登录后为用户生成一个单独的csrftoken，每次到服务器之后验证这个token，这个token不会被浏览器的cookie携带，因此不存在泄露的风险，同时只有cookie的情况下请求无法得到验证\n- 题外话：既然已经有了浏览器的同源策略，为什么还需要防止csrf，其实最根本的原因是当你用户domain A下的cookie的时候，即便你在domain B下，你给domain A发送请求的时候，浏览器还是会自动带上domain A下的所有cookie的。\n\n## SQL 注入\n> sql 注入是一种比较流行的攻击方式，比如当用户提交账号密码进行登录的时候，后端拿到这个username后直接去拼接了一段sql来执行，如下，我们期望的sql是这样的：\n```sql\nSELECT * FROM user WHERE username='zoumiaojiang' AND psw='mypassword'\n```\n但是实际运行的时候，用户在username那里输入了一点别的东西，使得sql变成了:\n```sql\nSELECT * FROM user WHERE username='zoumiaojiang' OR 1 = 1 --' AND psw='xxxx'\n```\n-- 在sql中是注释的意思，因此实际运行的sql变为了\n```sql\nSELECT * FROM user WHERE username='zoumiaojiang' OR 1 = 1\n```\n1 = 1永远为真，因此攻击者绕过了密码就进入了这个用户的账户，后面可以做的事情就更多了，后果是非常严重的\n\n- 如何预防：\n    - 对所有提交到sql的内容进行转义\n    - 严格限制Web应用的数据库的操作权限\n    - 后端代码检查输入的数据是否符合预期\n    - 对进入数据库的特殊字符（'，\"，\\，<，>，&，*，; 等）进行转义处理，或编码转换\n    - 所有的查询语句建议使用数据库提供的参数化查询接口\n    - 在应用发布之前建议使用专业的 SQL 注入检测工具进行检测\n    - 避免网站打印出 SQL 错误信息\n    - 不要过于细化返回的错误信息\n\n## 命令行注入\n\n> 在代码中设定了一段shell脚本，并且其中的一部分内容是用户输入的内容，比如下面这个：\n```javascript\n// 以 Node.js 为例，假如在接口中需要从 github 下载用户指定的 repo\nconst exec = require('mz/child_process').exec;\nlet params = {/* 用户输入的参数 */};\n\nexec(`git clone ${params.repo} /some/path`);\n```\n\n如果正常的设置repo是没问题的，但是当用户这样给入的时候\n```shell\nhttps://github.com/xx/xx.git && rm -rf /* &&\n```\n碰巧你还是sudo权限执行的话，后果不堪设想~\n\n- 预防方式：\n    - 后端对前端提交内容需要完全选择不相信，并且对其进行规则限制（比如正则表达式）。\n    - 在调用系统命令前对所有传入参数进行命令行参数转义过滤。\n    - 不要直接拼接命令语句，借助一些工具做拼接、转义预处理，例如 Node.js 的 shell-escape npm 包。\n\n## DDOS 攻击\n\n### ddos【Distributed Denial of Service】分布式拒绝服务\n> 核心原理就是利用大量的请求造成服务器资源过载，服务不可用，比如我们某个服务器的最大承载流量是400的qps，那么当有人用qps500的频率来攻击我们服务器的时候，服务器就会因为qps太高导致挂掉，然后服务就没法用了，这个东西不算是安全问题，是一种流氓攻击。\n\n除了通过请求的方式攻击，ddos最常见的还是网络层面的攻击，比如 SYN Flood、ACK Flood、UDP Flood、ICMP Flood 等；\n\n- syn flood：我们知道tcp的三次握手是需要时间的，当服务器进入握手的第一个环节，需要将syn+ask返回去来询问是否可以正常连接，但是这个时候因为攻击者的ip是假的，随机模拟的，导致一直无法响应，服务器对无法响应的ip会不停的重试，以防止丢包问题，因此这里链接一直被占用，并且无法得到释放，就会导致服务器资源吃紧，然后挂掉。\n\n- ack flood：在 TCP 连接建立之后，所有的数据传输 TCP 报文都是带有 ACK 标志位的，主机在接收到一个带有 ACK 标志位的数据包的时候，需要检查该数据包所表示的连接四元组是否存在，如果存在则检查该数据包所表示的状态是否合法，然后再向应用层传递该数据包。如果在检查中发现该数据包不合法，例如该数据包所指向的目的端口在本机并未开放，则主机操作系统协议栈会回应 RST 包告诉对方此端口不存在。\n\n- udp flood：由于 UDP 是一种无连接的协议，因此攻击者可以伪造大量的源 IP 地址去发送 UDP 包，此种攻击属于大流量攻击。正常应用情况下，UDP 包双向流量会基本相等，因此发起这种攻击的攻击者在消耗对方资源的时候也在消耗自己的资源。\n\n- ICMP Flood：ICMP Flood 攻击属于大流量攻击，其原理就是不断发送不正常的 ICMP 包（所谓不正常就是 ICMP 包内容很大），导致目标带宽被占用，但其本身资源也会被消耗。目前很多服务器都是禁 ping 的（在防火墙在可以屏蔽 ICMP 包），因此这种攻击方式已经落伍。\n\n防御方式：\n    - 负载均衡\n    - 抗ddos设备，增加流量清洗\n    - 限制ip访问频率，拉黑ip\n\n\n## 流量劫持\n\n> 流量劫持就是当用户在访问A地址的时候，给用户呈现的不是全部的A，其中加载了一些广告或者别的东西等等内容\n\n- DNS 劫持\n    也叫域名劫持，当用户打开baidu.com的时候，实际的DNS解析地址的IP是123，如果DNS解析服务器上被恶意处理了，很有可能查到的IP变成了456，从而把用户引导到了新的服务器上，返回一个类似的页面，再让用户输入账号密码，轻松获取账号信息，因为一般的域名解析服务器都是在运营商的手里，所以劫持都需要运营商参与的，运营商与黑产机构勾结下的产物。\n    \n- HTTP 劫持\n    由于http本身在网络中是明文传递的，因此不法运营商和黑产勾结可以修改http返回的页面，在其中插入一点别的内容，比如广告内容，然后再丢给用户，这样的话用户就不得不一直看一些没有用的广告，更狠一点可以直接把整个页面篡改掉，如果想要屏蔽这种现象的话可以使用https，因为https在传输过程中是加密的，无法被篡改\n","source":"_posts/常见网络攻击.md","raw":"---\ntitle: 常见网络攻击\ndate: 2019-05-18 18:09:30\ntags: 网络\n---\n\n## XSS 攻击\n> xss【cross site script】跨站脚本攻击，因为缩写和css相同，因此别名叫xss攻击\n- 非持久性攻击\n    通过发送带恶意脚本参数的url给用户，诱骗用户进行点击，从而获取到用户的信息，特点是：难发现，即时性，需要进行诱点\n\n- 持久性攻击\n    通过提交表单事件的时候，把恶意代码送入数据库，当前端读取的时候，从数据库中拿到并渲染执行，特点是：持久性，危害面广\n    防御方式：前后端在涉及到提交内容和直接渲染数据库内容的时候务必转义\n\n## CSRF 攻击\n> csrf【cross-site request forgery】跨站请求伪造攻击\n- 具体流程：如果A网站没有做任何对于csrf的防御工作，当用户登录A网站后，产生了cookie，cookie携带了一些私密的用户信息，然后用户点击了服务器B给的一个url，从而带上了cookie到B服务器中，B拿到之后就可以模拟用户的行为来操作实际用户的账户了。\n- 防御方式：用户登录后为用户生成一个单独的csrftoken，每次到服务器之后验证这个token，这个token不会被浏览器的cookie携带，因此不存在泄露的风险，同时只有cookie的情况下请求无法得到验证\n- 题外话：既然已经有了浏览器的同源策略，为什么还需要防止csrf，其实最根本的原因是当你用户domain A下的cookie的时候，即便你在domain B下，你给domain A发送请求的时候，浏览器还是会自动带上domain A下的所有cookie的。\n\n## SQL 注入\n> sql 注入是一种比较流行的攻击方式，比如当用户提交账号密码进行登录的时候，后端拿到这个username后直接去拼接了一段sql来执行，如下，我们期望的sql是这样的：\n```sql\nSELECT * FROM user WHERE username='zoumiaojiang' AND psw='mypassword'\n```\n但是实际运行的时候，用户在username那里输入了一点别的东西，使得sql变成了:\n```sql\nSELECT * FROM user WHERE username='zoumiaojiang' OR 1 = 1 --' AND psw='xxxx'\n```\n-- 在sql中是注释的意思，因此实际运行的sql变为了\n```sql\nSELECT * FROM user WHERE username='zoumiaojiang' OR 1 = 1\n```\n1 = 1永远为真，因此攻击者绕过了密码就进入了这个用户的账户，后面可以做的事情就更多了，后果是非常严重的\n\n- 如何预防：\n    - 对所有提交到sql的内容进行转义\n    - 严格限制Web应用的数据库的操作权限\n    - 后端代码检查输入的数据是否符合预期\n    - 对进入数据库的特殊字符（'，\"，\\，<，>，&，*，; 等）进行转义处理，或编码转换\n    - 所有的查询语句建议使用数据库提供的参数化查询接口\n    - 在应用发布之前建议使用专业的 SQL 注入检测工具进行检测\n    - 避免网站打印出 SQL 错误信息\n    - 不要过于细化返回的错误信息\n\n## 命令行注入\n\n> 在代码中设定了一段shell脚本，并且其中的一部分内容是用户输入的内容，比如下面这个：\n```javascript\n// 以 Node.js 为例，假如在接口中需要从 github 下载用户指定的 repo\nconst exec = require('mz/child_process').exec;\nlet params = {/* 用户输入的参数 */};\n\nexec(`git clone ${params.repo} /some/path`);\n```\n\n如果正常的设置repo是没问题的，但是当用户这样给入的时候\n```shell\nhttps://github.com/xx/xx.git && rm -rf /* &&\n```\n碰巧你还是sudo权限执行的话，后果不堪设想~\n\n- 预防方式：\n    - 后端对前端提交内容需要完全选择不相信，并且对其进行规则限制（比如正则表达式）。\n    - 在调用系统命令前对所有传入参数进行命令行参数转义过滤。\n    - 不要直接拼接命令语句，借助一些工具做拼接、转义预处理，例如 Node.js 的 shell-escape npm 包。\n\n## DDOS 攻击\n\n### ddos【Distributed Denial of Service】分布式拒绝服务\n> 核心原理就是利用大量的请求造成服务器资源过载，服务不可用，比如我们某个服务器的最大承载流量是400的qps，那么当有人用qps500的频率来攻击我们服务器的时候，服务器就会因为qps太高导致挂掉，然后服务就没法用了，这个东西不算是安全问题，是一种流氓攻击。\n\n除了通过请求的方式攻击，ddos最常见的还是网络层面的攻击，比如 SYN Flood、ACK Flood、UDP Flood、ICMP Flood 等；\n\n- syn flood：我们知道tcp的三次握手是需要时间的，当服务器进入握手的第一个环节，需要将syn+ask返回去来询问是否可以正常连接，但是这个时候因为攻击者的ip是假的，随机模拟的，导致一直无法响应，服务器对无法响应的ip会不停的重试，以防止丢包问题，因此这里链接一直被占用，并且无法得到释放，就会导致服务器资源吃紧，然后挂掉。\n\n- ack flood：在 TCP 连接建立之后，所有的数据传输 TCP 报文都是带有 ACK 标志位的，主机在接收到一个带有 ACK 标志位的数据包的时候，需要检查该数据包所表示的连接四元组是否存在，如果存在则检查该数据包所表示的状态是否合法，然后再向应用层传递该数据包。如果在检查中发现该数据包不合法，例如该数据包所指向的目的端口在本机并未开放，则主机操作系统协议栈会回应 RST 包告诉对方此端口不存在。\n\n- udp flood：由于 UDP 是一种无连接的协议，因此攻击者可以伪造大量的源 IP 地址去发送 UDP 包，此种攻击属于大流量攻击。正常应用情况下，UDP 包双向流量会基本相等，因此发起这种攻击的攻击者在消耗对方资源的时候也在消耗自己的资源。\n\n- ICMP Flood：ICMP Flood 攻击属于大流量攻击，其原理就是不断发送不正常的 ICMP 包（所谓不正常就是 ICMP 包内容很大），导致目标带宽被占用，但其本身资源也会被消耗。目前很多服务器都是禁 ping 的（在防火墙在可以屏蔽 ICMP 包），因此这种攻击方式已经落伍。\n\n防御方式：\n    - 负载均衡\n    - 抗ddos设备，增加流量清洗\n    - 限制ip访问频率，拉黑ip\n\n\n## 流量劫持\n\n> 流量劫持就是当用户在访问A地址的时候，给用户呈现的不是全部的A，其中加载了一些广告或者别的东西等等内容\n\n- DNS 劫持\n    也叫域名劫持，当用户打开baidu.com的时候，实际的DNS解析地址的IP是123，如果DNS解析服务器上被恶意处理了，很有可能查到的IP变成了456，从而把用户引导到了新的服务器上，返回一个类似的页面，再让用户输入账号密码，轻松获取账号信息，因为一般的域名解析服务器都是在运营商的手里，所以劫持都需要运营商参与的，运营商与黑产机构勾结下的产物。\n    \n- HTTP 劫持\n    由于http本身在网络中是明文传递的，因此不法运营商和黑产勾结可以修改http返回的页面，在其中插入一点别的内容，比如广告内容，然后再丢给用户，这样的话用户就不得不一直看一些没有用的广告，更狠一点可以直接把整个页面篡改掉，如果想要屏蔽这种现象的话可以使用https，因为https在传输过程中是加密的，无法被篡改\n","slug":"常见网络攻击","published":1,"updated":"2019-06-20T03:12:43.096Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx4afn510006q67widw3q4xa","content":"<h2 id=\"XSS-攻击\"><a href=\"#XSS-攻击\" class=\"headerlink\" title=\"XSS 攻击\"></a>XSS 攻击</h2><blockquote>\n<p>xss【cross site script】跨站脚本攻击，因为缩写和css相同，因此别名叫xss攻击</p>\n<ul>\n<li>非持久性攻击<br>  通过发送带恶意脚本参数的url给用户，诱骗用户进行点击，从而获取到用户的信息，特点是：难发现，即时性，需要进行诱点</li>\n</ul>\n</blockquote>\n<ul>\n<li>持久性攻击<br>  通过提交表单事件的时候，把恶意代码送入数据库，当前端读取的时候，从数据库中拿到并渲染执行，特点是：持久性，危害面广<br>  防御方式：前后端在涉及到提交内容和直接渲染数据库内容的时候务必转义</li>\n</ul>\n<h2 id=\"CSRF-攻击\"><a href=\"#CSRF-攻击\" class=\"headerlink\" title=\"CSRF 攻击\"></a>CSRF 攻击</h2><blockquote>\n<p>csrf【cross-site request forgery】跨站请求伪造攻击</p>\n<ul>\n<li>具体流程：如果A网站没有做任何对于csrf的防御工作，当用户登录A网站后，产生了cookie，cookie携带了一些私密的用户信息，然后用户点击了服务器B给的一个url，从而带上了cookie到B服务器中，B拿到之后就可以模拟用户的行为来操作实际用户的账户了。</li>\n<li>防御方式：用户登录后为用户生成一个单独的csrftoken，每次到服务器之后验证这个token，这个token不会被浏览器的cookie携带，因此不存在泄露的风险，同时只有cookie的情况下请求无法得到验证</li>\n<li>题外话：既然已经有了浏览器的同源策略，为什么还需要防止csrf，其实最根本的原因是当你用户domain A下的cookie的时候，即便你在domain B下，你给domain A发送请求的时候，浏览器还是会自动带上domain A下的所有cookie的。</li>\n</ul>\n</blockquote>\n<h2 id=\"SQL-注入\"><a href=\"#SQL-注入\" class=\"headerlink\" title=\"SQL 注入\"></a>SQL 注入</h2><blockquote>\n<p>sql 注入是一种比较流行的攻击方式，比如当用户提交账号密码进行登录的时候，后端拿到这个username后直接去拼接了一段sql来执行，如下，我们期望的sql是这样的：</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> username=<span class=\"string\">'zoumiaojiang'</span> <span class=\"keyword\">AND</span> psw=<span class=\"string\">'mypassword'</span></span><br></pre></td></tr></table></figure>\n\n<p>但是实际运行的时候，用户在username那里输入了一点别的东西，使得sql变成了:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> username=<span class=\"string\">'zoumiaojiang'</span> <span class=\"keyword\">OR</span> <span class=\"number\">1</span> = <span class=\"number\">1</span> <span class=\"comment\">--' AND psw='xxxx'</span></span><br></pre></td></tr></table></figure>\n\n<p>– 在sql中是注释的意思，因此实际运行的sql变为了</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> username=<span class=\"string\">'zoumiaojiang'</span> <span class=\"keyword\">OR</span> <span class=\"number\">1</span> = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>1 = 1永远为真，因此攻击者绕过了密码就进入了这个用户的账户，后面可以做的事情就更多了，后果是非常严重的</p>\n<ul>\n<li>如何预防：<ul>\n<li>对所有提交到sql的内容进行转义</li>\n<li>严格限制Web应用的数据库的操作权限</li>\n<li>后端代码检查输入的数据是否符合预期</li>\n<li>对进入数据库的特殊字符（’，”，\\，&lt;，&gt;，&amp;，*，; 等）进行转义处理，或编码转换</li>\n<li>所有的查询语句建议使用数据库提供的参数化查询接口</li>\n<li>在应用发布之前建议使用专业的 SQL 注入检测工具进行检测</li>\n<li>避免网站打印出 SQL 错误信息</li>\n<li>不要过于细化返回的错误信息</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"命令行注入\"><a href=\"#命令行注入\" class=\"headerlink\" title=\"命令行注入\"></a>命令行注入</h2><blockquote>\n<p>在代码中设定了一段shell脚本，并且其中的一部分内容是用户输入的内容，比如下面这个：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 以 Node.js 为例，假如在接口中需要从 github 下载用户指定的 repo</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> exec = <span class=\"built_in\">require</span>(<span class=\"string\">'mz/child_process'</span>).exec;</span><br><span class=\"line\"><span class=\"keyword\">let</span> params = &#123;<span class=\"comment\">/* 用户输入的参数 */</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">exec(<span class=\"string\">`git clone <span class=\"subst\">$&#123;params.repo&#125;</span> /some/path`</span>);</span><br></pre></td></tr></table></figure>\n\n<p>如果正常的设置repo是没问题的，但是当用户这样给入的时候</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://github.com/xx/xx.git &amp;&amp; rm -rf /* &amp;&amp;</span><br></pre></td></tr></table></figure>\n\n<p>碰巧你还是sudo权限执行的话，后果不堪设想~</p>\n<ul>\n<li>预防方式：<ul>\n<li>后端对前端提交内容需要完全选择不相信，并且对其进行规则限制（比如正则表达式）。</li>\n<li>在调用系统命令前对所有传入参数进行命令行参数转义过滤。</li>\n<li>不要直接拼接命令语句，借助一些工具做拼接、转义预处理，例如 Node.js 的 shell-escape npm 包。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"DDOS-攻击\"><a href=\"#DDOS-攻击\" class=\"headerlink\" title=\"DDOS 攻击\"></a>DDOS 攻击</h2><h3 id=\"ddos【Distributed-Denial-of-Service】分布式拒绝服务\"><a href=\"#ddos【Distributed-Denial-of-Service】分布式拒绝服务\" class=\"headerlink\" title=\"ddos【Distributed Denial of Service】分布式拒绝服务\"></a>ddos【Distributed Denial of Service】分布式拒绝服务</h3><blockquote>\n<p>核心原理就是利用大量的请求造成服务器资源过载，服务不可用，比如我们某个服务器的最大承载流量是400的qps，那么当有人用qps500的频率来攻击我们服务器的时候，服务器就会因为qps太高导致挂掉，然后服务就没法用了，这个东西不算是安全问题，是一种流氓攻击。</p>\n</blockquote>\n<p>除了通过请求的方式攻击，ddos最常见的还是网络层面的攻击，比如 SYN Flood、ACK Flood、UDP Flood、ICMP Flood 等；</p>\n<ul>\n<li><p>syn flood：我们知道tcp的三次握手是需要时间的，当服务器进入握手的第一个环节，需要将syn+ask返回去来询问是否可以正常连接，但是这个时候因为攻击者的ip是假的，随机模拟的，导致一直无法响应，服务器对无法响应的ip会不停的重试，以防止丢包问题，因此这里链接一直被占用，并且无法得到释放，就会导致服务器资源吃紧，然后挂掉。</p>\n</li>\n<li><p>ack flood：在 TCP 连接建立之后，所有的数据传输 TCP 报文都是带有 ACK 标志位的，主机在接收到一个带有 ACK 标志位的数据包的时候，需要检查该数据包所表示的连接四元组是否存在，如果存在则检查该数据包所表示的状态是否合法，然后再向应用层传递该数据包。如果在检查中发现该数据包不合法，例如该数据包所指向的目的端口在本机并未开放，则主机操作系统协议栈会回应 RST 包告诉对方此端口不存在。</p>\n</li>\n<li><p>udp flood：由于 UDP 是一种无连接的协议，因此攻击者可以伪造大量的源 IP 地址去发送 UDP 包，此种攻击属于大流量攻击。正常应用情况下，UDP 包双向流量会基本相等，因此发起这种攻击的攻击者在消耗对方资源的时候也在消耗自己的资源。</p>\n</li>\n<li><p>ICMP Flood：ICMP Flood 攻击属于大流量攻击，其原理就是不断发送不正常的 ICMP 包（所谓不正常就是 ICMP 包内容很大），导致目标带宽被占用，但其本身资源也会被消耗。目前很多服务器都是禁 ping 的（在防火墙在可以屏蔽 ICMP 包），因此这种攻击方式已经落伍。</p>\n</li>\n</ul>\n<p>防御方式：<br>    - 负载均衡<br>    - 抗ddos设备，增加流量清洗<br>    - 限制ip访问频率，拉黑ip</p>\n<h2 id=\"流量劫持\"><a href=\"#流量劫持\" class=\"headerlink\" title=\"流量劫持\"></a>流量劫持</h2><blockquote>\n<p>流量劫持就是当用户在访问A地址的时候，给用户呈现的不是全部的A，其中加载了一些广告或者别的东西等等内容</p>\n</blockquote>\n<ul>\n<li><p>DNS 劫持<br>  也叫域名劫持，当用户打开baidu.com的时候，实际的DNS解析地址的IP是123，如果DNS解析服务器上被恶意处理了，很有可能查到的IP变成了456，从而把用户引导到了新的服务器上，返回一个类似的页面，再让用户输入账号密码，轻松获取账号信息，因为一般的域名解析服务器都是在运营商的手里，所以劫持都需要运营商参与的，运营商与黑产机构勾结下的产物。</p>\n</li>\n<li><p>HTTP 劫持<br>  由于http本身在网络中是明文传递的，因此不法运营商和黑产勾结可以修改http返回的页面，在其中插入一点别的内容，比如广告内容，然后再丢给用户，这样的话用户就不得不一直看一些没有用的广告，更狠一点可以直接把整个页面篡改掉，如果想要屏蔽这种现象的话可以使用https，因为https在传输过程中是加密的，无法被篡改</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"XSS-攻击\"><a href=\"#XSS-攻击\" class=\"headerlink\" title=\"XSS 攻击\"></a>XSS 攻击</h2><blockquote>\n<p>xss【cross site script】跨站脚本攻击，因为缩写和css相同，因此别名叫xss攻击</p>\n<ul>\n<li>非持久性攻击<br>  通过发送带恶意脚本参数的url给用户，诱骗用户进行点击，从而获取到用户的信息，特点是：难发现，即时性，需要进行诱点</li>\n</ul>\n</blockquote>\n<ul>\n<li>持久性攻击<br>  通过提交表单事件的时候，把恶意代码送入数据库，当前端读取的时候，从数据库中拿到并渲染执行，特点是：持久性，危害面广<br>  防御方式：前后端在涉及到提交内容和直接渲染数据库内容的时候务必转义</li>\n</ul>\n<h2 id=\"CSRF-攻击\"><a href=\"#CSRF-攻击\" class=\"headerlink\" title=\"CSRF 攻击\"></a>CSRF 攻击</h2><blockquote>\n<p>csrf【cross-site request forgery】跨站请求伪造攻击</p>\n<ul>\n<li>具体流程：如果A网站没有做任何对于csrf的防御工作，当用户登录A网站后，产生了cookie，cookie携带了一些私密的用户信息，然后用户点击了服务器B给的一个url，从而带上了cookie到B服务器中，B拿到之后就可以模拟用户的行为来操作实际用户的账户了。</li>\n<li>防御方式：用户登录后为用户生成一个单独的csrftoken，每次到服务器之后验证这个token，这个token不会被浏览器的cookie携带，因此不存在泄露的风险，同时只有cookie的情况下请求无法得到验证</li>\n<li>题外话：既然已经有了浏览器的同源策略，为什么还需要防止csrf，其实最根本的原因是当你用户domain A下的cookie的时候，即便你在domain B下，你给domain A发送请求的时候，浏览器还是会自动带上domain A下的所有cookie的。</li>\n</ul>\n</blockquote>\n<h2 id=\"SQL-注入\"><a href=\"#SQL-注入\" class=\"headerlink\" title=\"SQL 注入\"></a>SQL 注入</h2><blockquote>\n<p>sql 注入是一种比较流行的攻击方式，比如当用户提交账号密码进行登录的时候，后端拿到这个username后直接去拼接了一段sql来执行，如下，我们期望的sql是这样的：</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> username=<span class=\"string\">'zoumiaojiang'</span> <span class=\"keyword\">AND</span> psw=<span class=\"string\">'mypassword'</span></span><br></pre></td></tr></table></figure>\n\n<p>但是实际运行的时候，用户在username那里输入了一点别的东西，使得sql变成了:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> username=<span class=\"string\">'zoumiaojiang'</span> <span class=\"keyword\">OR</span> <span class=\"number\">1</span> = <span class=\"number\">1</span> <span class=\"comment\">--' AND psw='xxxx'</span></span><br></pre></td></tr></table></figure>\n\n<p>– 在sql中是注释的意思，因此实际运行的sql变为了</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> username=<span class=\"string\">'zoumiaojiang'</span> <span class=\"keyword\">OR</span> <span class=\"number\">1</span> = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>1 = 1永远为真，因此攻击者绕过了密码就进入了这个用户的账户，后面可以做的事情就更多了，后果是非常严重的</p>\n<ul>\n<li>如何预防：<ul>\n<li>对所有提交到sql的内容进行转义</li>\n<li>严格限制Web应用的数据库的操作权限</li>\n<li>后端代码检查输入的数据是否符合预期</li>\n<li>对进入数据库的特殊字符（’，”，\\，&lt;，&gt;，&amp;，*，; 等）进行转义处理，或编码转换</li>\n<li>所有的查询语句建议使用数据库提供的参数化查询接口</li>\n<li>在应用发布之前建议使用专业的 SQL 注入检测工具进行检测</li>\n<li>避免网站打印出 SQL 错误信息</li>\n<li>不要过于细化返回的错误信息</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"命令行注入\"><a href=\"#命令行注入\" class=\"headerlink\" title=\"命令行注入\"></a>命令行注入</h2><blockquote>\n<p>在代码中设定了一段shell脚本，并且其中的一部分内容是用户输入的内容，比如下面这个：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 以 Node.js 为例，假如在接口中需要从 github 下载用户指定的 repo</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> exec = <span class=\"built_in\">require</span>(<span class=\"string\">'mz/child_process'</span>).exec;</span><br><span class=\"line\"><span class=\"keyword\">let</span> params = &#123;<span class=\"comment\">/* 用户输入的参数 */</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">exec(<span class=\"string\">`git clone <span class=\"subst\">$&#123;params.repo&#125;</span> /some/path`</span>);</span><br></pre></td></tr></table></figure>\n\n<p>如果正常的设置repo是没问题的，但是当用户这样给入的时候</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://github.com/xx/xx.git &amp;&amp; rm -rf /* &amp;&amp;</span><br></pre></td></tr></table></figure>\n\n<p>碰巧你还是sudo权限执行的话，后果不堪设想~</p>\n<ul>\n<li>预防方式：<ul>\n<li>后端对前端提交内容需要完全选择不相信，并且对其进行规则限制（比如正则表达式）。</li>\n<li>在调用系统命令前对所有传入参数进行命令行参数转义过滤。</li>\n<li>不要直接拼接命令语句，借助一些工具做拼接、转义预处理，例如 Node.js 的 shell-escape npm 包。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"DDOS-攻击\"><a href=\"#DDOS-攻击\" class=\"headerlink\" title=\"DDOS 攻击\"></a>DDOS 攻击</h2><h3 id=\"ddos【Distributed-Denial-of-Service】分布式拒绝服务\"><a href=\"#ddos【Distributed-Denial-of-Service】分布式拒绝服务\" class=\"headerlink\" title=\"ddos【Distributed Denial of Service】分布式拒绝服务\"></a>ddos【Distributed Denial of Service】分布式拒绝服务</h3><blockquote>\n<p>核心原理就是利用大量的请求造成服务器资源过载，服务不可用，比如我们某个服务器的最大承载流量是400的qps，那么当有人用qps500的频率来攻击我们服务器的时候，服务器就会因为qps太高导致挂掉，然后服务就没法用了，这个东西不算是安全问题，是一种流氓攻击。</p>\n</blockquote>\n<p>除了通过请求的方式攻击，ddos最常见的还是网络层面的攻击，比如 SYN Flood、ACK Flood、UDP Flood、ICMP Flood 等；</p>\n<ul>\n<li><p>syn flood：我们知道tcp的三次握手是需要时间的，当服务器进入握手的第一个环节，需要将syn+ask返回去来询问是否可以正常连接，但是这个时候因为攻击者的ip是假的，随机模拟的，导致一直无法响应，服务器对无法响应的ip会不停的重试，以防止丢包问题，因此这里链接一直被占用，并且无法得到释放，就会导致服务器资源吃紧，然后挂掉。</p>\n</li>\n<li><p>ack flood：在 TCP 连接建立之后，所有的数据传输 TCP 报文都是带有 ACK 标志位的，主机在接收到一个带有 ACK 标志位的数据包的时候，需要检查该数据包所表示的连接四元组是否存在，如果存在则检查该数据包所表示的状态是否合法，然后再向应用层传递该数据包。如果在检查中发现该数据包不合法，例如该数据包所指向的目的端口在本机并未开放，则主机操作系统协议栈会回应 RST 包告诉对方此端口不存在。</p>\n</li>\n<li><p>udp flood：由于 UDP 是一种无连接的协议，因此攻击者可以伪造大量的源 IP 地址去发送 UDP 包，此种攻击属于大流量攻击。正常应用情况下，UDP 包双向流量会基本相等，因此发起这种攻击的攻击者在消耗对方资源的时候也在消耗自己的资源。</p>\n</li>\n<li><p>ICMP Flood：ICMP Flood 攻击属于大流量攻击，其原理就是不断发送不正常的 ICMP 包（所谓不正常就是 ICMP 包内容很大），导致目标带宽被占用，但其本身资源也会被消耗。目前很多服务器都是禁 ping 的（在防火墙在可以屏蔽 ICMP 包），因此这种攻击方式已经落伍。</p>\n</li>\n</ul>\n<p>防御方式：<br>    - 负载均衡<br>    - 抗ddos设备，增加流量清洗<br>    - 限制ip访问频率，拉黑ip</p>\n<h2 id=\"流量劫持\"><a href=\"#流量劫持\" class=\"headerlink\" title=\"流量劫持\"></a>流量劫持</h2><blockquote>\n<p>流量劫持就是当用户在访问A地址的时候，给用户呈现的不是全部的A，其中加载了一些广告或者别的东西等等内容</p>\n</blockquote>\n<ul>\n<li><p>DNS 劫持<br>  也叫域名劫持，当用户打开baidu.com的时候，实际的DNS解析地址的IP是123，如果DNS解析服务器上被恶意处理了，很有可能查到的IP变成了456，从而把用户引导到了新的服务器上，返回一个类似的页面，再让用户输入账号密码，轻松获取账号信息，因为一般的域名解析服务器都是在运营商的手里，所以劫持都需要运营商参与的，运营商与黑产机构勾结下的产物。</p>\n</li>\n<li><p>HTTP 劫持<br>  由于http本身在网络中是明文传递的，因此不法运营商和黑产勾结可以修改http返回的页面，在其中插入一点别的内容，比如广告内容，然后再丢给用户，这样的话用户就不得不一直看一些没有用的广告，更狠一点可以直接把整个页面篡改掉，如果想要屏蔽这种现象的话可以使用https，因为https在传输过程中是加密的，无法被篡改</p>\n</li>\n</ul>\n"},{"title":"手写async函数","date":"2019-03-05T13:58:18.000Z","_content":"\n![1327f9baa13e86641c721d111e51bc1e.jpeg](evernotecid://2E1F95D0-6D94-423F-BC95-0D422C913EFE/appyinxiangcom/22692071/ENResource/p24)\n\n## js的异步历史\n\n##### 我们都知道JavaScript是单线程的，避开了操作多线程的上锁和复杂的状态同步问题，单线程是无法充分利用cpu的，不过早期的JavaScript只是作为浏览器的脚本工具实现的，因此采用单线程是最方便最省事的，作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？\n\n## 水深火热的callback\n\n##### 受制于单线程的原因，JavaScript在处理异步任务的时候就出现了比较尴尬的局面，比如AJAX请求，如果事情只能一件一件的来，当用户到服务器上去请求的时候，必须干等到结果回来才能继续后面的动作，这显而易见是不能被接受的，因此callback顺势而出，到后来的nodejs崛起，实现IO读取等异步的方式都是采用了callback的方式，也诞生了臭名昭著的callback hell，场面开始失控...\n\n```javascript\nfunction (param, cb){\n    false.readFile(param, function(err, data){\n        if(err) return cb(err);\n        async1(data, function(err, data){\n            if(err) return cb(err);\n            async2(data, function(err, data){\n                if(err) return cb(err);\n                // asyncN... 不知道会有多少\n            })\n        })\n    })\n}\n```\n\n## 拯救callback的promise\n\n>我的意中人是盖世英雄，有一天他会踏着七色云彩前来拯救我 \n\n##### es6将promise纳入了JavaScript的标准，promise代表着“承诺”，初始化了一个“承诺”之后，你只要在then中定义好这个承诺若是在未来达成要做什么事情，在catch中定义好这个承诺失败了需要做什么事情，就ok了\n\n```javascript\nconst somePromiseObject = return new Promise((resolve, reject) => {\n    const result = doSomeThing();\n    if(result) {\n        return resolve(result); // handle success\n    }\n    reject('err') // handle error\n})\n\nsomePromiseObject\n    .then(data => {\n        // success callback  \n    },\n    err => {\n        // err callback\n    })\n```\n\n##### promise的出现完美的解救了callback的回调地狱，原因是promise允许链式调用，并且可以统一到最外层去做错误的catch~\n\n```javascript\nsomePromiseObject\n    .then(data => {\n        // do someThings..\n    })\n    .then(data => {\n        // do someThings..\n    })\n    .then(data => {\n        // do someThings..\n    })\n    .catch(err => {\n        // handle errs here\n    })\n```\n\n#### but 当我们认为promise就是JavaScript解决异步的最优方案的时候，ES2017 标准又引入了async 函数，使得异步操作变得更加方便\n\n## 异步终极利器async函数\n\n>我猜中了前头可我猜不中这结局 --promise\n\n##### 没错就在es6将promise加入标准后的不久，es7又新加入一种新的异步解决方案（号称终极解决方案）-- async函数\n\n##### 假设有个异步函数\n\n```javascript\najax1().then(() => {\n    ajax2().then(() => {\n        ajax3().then((data) => {\n            console.log(data) // success\n        }, err => {\n            console.log(err)\n        })\n    },\n    err => {\n        console.log(err)\n    })\n}, err => {\n    console.log(err)\n})\n```\n\n##### 好吧我们赶紧试试用async来实现\n\n```javascript\nconst asyncFun = async () => {\n    try{\n        await ajax1();\n        await ajax2();\n        const data = await ajax3();\n        console.log(data) // success\n    }catch(err){\n        console.log(err) // handle errs here\n    }\n}\n```\n\n##### 可以看到明显的看到，async的写法比promise的链式更舒服，它允许我们像写同步的语法一样去写嵌套的异步，实际的效果也会按照async 被 await 的顺序来运行，而且对开发最友好的是所有中间出现的错误都能被最外层的catch给捕获，所以说很多人都认为async将是js异步的终极解决方案，下面我们先来认识一下实现async的函数的一个基础函数，generator函数~\n\n## 什么是generator\n\n* 可以先看下阮一峰老师的[概念理解](http://es6.ruanyifeng.com/#docs/generator)\n* generator函数最神奇的地方在于它可以交出函数的控制权，什么意思呢，我们正常情况下的函数一旦被执行就会全部执行结束，除非发生错误，是不能在执行中间停下来的，而generator函数就不一样了，它可以用yeild关键字来将函数的执行暂停，generator函数执行后会返回一个迭代器(也可以理解为指针)，这个指针对象拥有一个关键的next方法，用来移动当前指针所在的位置，每次调用next返回一个对象，包含2个内容：value：当前generator函数中yeild语句后面表达式的值，done：bool值，标识当前迭代器是否结束迭代了，也就是说是否所有的yeild语句都走完了；\n* genarator 不仅仅可以暂停一个函数的执行，还可以在执行的时候送入数据给函数，改变函数中yeild关键字后面表达式的值；\n```javascript\n    function* gen(x) {\n        const y = yield x + 2;\n        const y1 = yield y + 3;\n        return y1;\n    }\n    \n    var g = gen(1);\n    console.log(g.next()); // { value: 3, done: false }\n    console.log(g.next(2)); // { value: 5, done: false }\n    console.log(g.next()); // { value: undefined, done: true }\n```\n* 可以看到运行g.next(2)之前y的值已经是3了，+3应该是6，实际返回的确实5，因为我们给入的值会替换掉yeild关键字后面的表达式，也就是y=2了，所以next(2)后的值是5而不是6；\n\n##### 既然generator可以暂停，如果我们每次遇到promise就暂停，等拿到promise.then()执行的结果在返回data，岂不是就是async函数的表现形式？dei，这确实就是async实现的基本原理，下面我们一起来手撸一个模拟async的函数--\"myAsync\"，盘它！\n\n## 盘它\n\n1. 根据async函数的表现，async关键字后面跟的是一个generator函数，我们用函数来模拟，如下结果：\n```javascript\n    // 函数A(正常情况);\nconst test = async function myGenerator(){\n    const data = await Promise.resolve(\"success\");\n    console.log(data);\n}\n\n// 函数B(模拟情况);\nfunction myAsync(myGenerator) {\n    // handle...\n}\nfunction* myGenerator() {\n    const data = yield Promise.resolve(\"success\");\n    console.log(data); // success\n}\nconst test = myAsync(myGenerator);\n```\n2. ok，然后我们来实现myAsync函数，这个函数会接受一个generator函数，我们知道generator函数调用后才会生成迭代器，拿到迭代器后，我们肯定需要调用next()来获取下一个yeild的值，然后如果这个值是一个promise，那我们就调用then拿到结果后再next到下一次的迭代中，否则，我们直接把拿到的数据不做处理直接给到next--核心思想：generator的迭代器结果，是promise就等异步完成，否则就直接返回数据，然后递归调用handle函数处理下一个迭代，直到迭代器的done是true，返回，看代码：\n\n```javascript\n// 函数B(模拟情况);\nfunction myAsync(myGenerator) {\n    const gen = myGenerator(); // 生成迭代器\n    const handle = genResult => {\n        if (genResult.done) return; // 如果迭代器结束了，直接返回；\n        return genResult.value instanceof Promise // 判断当前迭代器的value是否是Promise的实例\n            ? genResult.value\n                  // 如果是，则等待异步完成后继续递归下一个迭代，并把resolve后的data带过去\n                  .then(data => handle(gen.next(data)))\n                  .catch(err => gen.throw(err)) // gen.throw 可以抛出一个允许外层去catch的err\n            : handle(gen.next(genResult.value)); // 如果不是promise，就可以直接递归下一次迭代了\n    };\n    try {\n        handle(gen.next()); // 开始处理next迭代\n    } catch (err) {\n        throw err;\n    }\n}\nfunction* myGenerator() {\n    const data = yield Promise.resolve(\"success\");\n    console.log(data); // success\n}\nconst test = myAsync(myGenerator);\n```\n\n>到现在其实我们的核心功能handle函数就完成了，现在去调用next()方法，已经看到可以打印success了，但是，除了正常的promise，我们还要考虑下面的情况\n\n```javascript\n// 函数A(正常情况);\nconst a = {\n    then: () => {\n        console.log(\"then\");\n        return 123123;\n    }\n};\n\nconst test0 = async function() {};\n\nconst test1 = async function() {\n    return 123;\n};\nconst test2 = async function() {\n    console.log(123);\n};\nconst test4 = async function() {\n    return a;\n};\n\ntest0().then(console.log); // undefined\ntest1().then(console.log); // 123\ntest2().then(console.log); // 123 undefined\ntest4().then(console.log); // then\n```\n\n>也就是说在async接受到的函数不是generator函数的情况下：\n\n1. async函数默认返回一Promise.resolve(undefined)\n2. 当async接受到的函数有返回值，并且返回值不是promise的情况下，async函数默认用promise包装这个返回结果\n3. 当async接受到函数没有返回值，async会直接运行函数，并返回一个Promise.resolve(undefined)\n4. 考虑到thenable这种promise的鸭子类型函数的特殊性，我尝试去返回了一个这种类型的对象，果然，发现then被执行了~\n\n##### 那么，我们来完善边界情况的处理\n\n>所以现在的代码变成\n\n```javascript\n// 函数B(模拟情况);\nfunction myAsync(myGenerator) {\n    // 判断接受到的参数不是一个generator函数\n    if (\n        Object.prototype.toString.call(myGenerator) !==\n        \"[object GeneratorFunction]\"\n    ) {\n        // 如果是一个普通函数\n        if (\n            Object.prototype.toString.call(myGenerator) === \"[object Function]\"\n        ) {\n            return new Promise((resolve, reject) => {\n                // 默认返回一个promise对象\n                try {\n                    const data = myGenerator();\n                    return resolve(data); // 尝试运行这个函数，并把结果resolve出去\n                } catch (err) {\n                    return reject(err); // 失败处理\n                }\n            });\n        }\n        // 如果参数含有then这个方法--thenable 鸭子类型\n        if (typeof myGenerator.then === \"function\") {\n            return new Promise((resolve, reject) => {\n                try {\n                    // 运行这个对象的then函数，并resolve出去\n                    const data = myGenerator.then();\n                    return resolve(data);\n                } catch (err) {\n                    return reject(err); // 失败处理\n                }\n            });\n        }\n        // 剩下的情况，统一resolve出去给的参数\n        return Promise.resolve(myGenerator);\n    }\n    const gen = myGenerator(); // 生成迭代器\n    const handle = genResult => {\n        if (genResult.done) return; // 如果迭代器结束了，直接返回；\n        return genResult.value instanceof Promise // 判断当前迭代器的value是否是Promise的实例\n            ? genResult.value\n                  .then(data => handle(gen.next(data))) // 如果是，则等待异步完成后继续递归下一个迭代，并把resolve后的data带过去\n                  .catch(err => gen.throw(err)) // gen.throw 可以抛出一个允许外层去catch的err\n            : handle(gen.next(genResult.value)); // 如果不是promise，就可以直接递归下一次迭代了\n    };\n    try {\n        handle(gen.next()); // 开始处理next迭代\n    } catch (err) {\n        throw err;\n    }\n}\n\nconst a = {\n    then: () => {\n        console.log(\"then\");\n        return 123123;\n    }\n};\n\nconst test0 = myAsync(function() {});\n\nconst test1 = myAsync(function() {\n    return 123;\n});\n\nconst test2 = myAsync(function() {\n    console.log(123);\n});\nconst test4 = myAsync(function() {\n    return a;\n});\n\ntest0.then(console.log); // undefined\ntest1.then(console.log); // 123\ntest2.then(console.log); // 123 undefined\ntest4.then(console.log); // then\n```\n\n>有的同学可能会说，咦，es6的 async 函数返回的那个是个函数，需要执行才能拿到结果，比如test0 应该是 test() 返回的是promise，但是模拟出来的怎么直接就拿到返回的promise了，其实很简单，你只要再用一个函数(比如myAsyncWrapper)把这个函数包装一下就ok~\n\n##### 到此，我们的模拟就结束了，现在让我们来尽情的实验一下~\n\n```javascript\nmyAsync(function*() {\n    try {\n        const data1 = yield new Promise(res => {\n            setTimeout(() => {\n                res(1234);\n                console.log(\"step 1\"); // step 1\n            }, 1000);\n        });\n        console.log(data1); // step 1 打印1s后 打印 123\n        const data2 = yield new Promise(res => {\n            setTimeout(() => {\n                res(12342);\n                console.log(\"step 2\"); // step 2\n            }, 1000);\n        });\n        console.log(data2); // step 2 打印1s后打印 12342\n    } catch (err) {\n        console.log(888, err); \n    }\n});\n```\n\n>完美啊有么有，再来试试reject\n\n```javascript\nmyAsync(function*() {\n    try {\n        yield Promise.reject(123);\n        const data1 = yield new Promise(res => {\n            setTimeout(() => {\n                res(1234);\n                console.log(\"step 1\");\n            }, 1000);\n        });\n        console.log(data1);\n        const data2 = yield new Promise(res => {\n            setTimeout(() => {\n                res(12342);\n                console.log(\"step 2\");\n            }, 1000);\n        });\n        console.log(data2);\n    } catch (err) {\n        console.log(888, err); // 888 123\n    }\n});\n```\n\n>没问题直接输出了888 123\n\n##### 完美结束\n\n\n## 总结\n\n##### 1.async 函数是generator+promise的语法糖，可能es6具体的实现一定有一定的优化和处理，但是个人觉得理论上偏差不大\n\n##### 2.想要用的得心应手还是建议去猜测和理解一下实现的原理\n\n#### 3.特此声明：以上内容基本都是模拟实现，并不是真实的实现原理，没有写测试，因此可能有漏洞的存在，欢迎各位大佬批评指正，希望大家能够共同进步~\n\n\n> [代码demo传送门](https://github.com/jinggk/FrontEndCode/blob/master/async/demo.js)\n","source":"_posts/手写async函数.md","raw":"---\ntitle: 手写async函数\ndate: 2019-03-05 21:58:18\ntags: javascript\n---\n\n![1327f9baa13e86641c721d111e51bc1e.jpeg](evernotecid://2E1F95D0-6D94-423F-BC95-0D422C913EFE/appyinxiangcom/22692071/ENResource/p24)\n\n## js的异步历史\n\n##### 我们都知道JavaScript是单线程的，避开了操作多线程的上锁和复杂的状态同步问题，单线程是无法充分利用cpu的，不过早期的JavaScript只是作为浏览器的脚本工具实现的，因此采用单线程是最方便最省事的，作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？\n\n## 水深火热的callback\n\n##### 受制于单线程的原因，JavaScript在处理异步任务的时候就出现了比较尴尬的局面，比如AJAX请求，如果事情只能一件一件的来，当用户到服务器上去请求的时候，必须干等到结果回来才能继续后面的动作，这显而易见是不能被接受的，因此callback顺势而出，到后来的nodejs崛起，实现IO读取等异步的方式都是采用了callback的方式，也诞生了臭名昭著的callback hell，场面开始失控...\n\n```javascript\nfunction (param, cb){\n    false.readFile(param, function(err, data){\n        if(err) return cb(err);\n        async1(data, function(err, data){\n            if(err) return cb(err);\n            async2(data, function(err, data){\n                if(err) return cb(err);\n                // asyncN... 不知道会有多少\n            })\n        })\n    })\n}\n```\n\n## 拯救callback的promise\n\n>我的意中人是盖世英雄，有一天他会踏着七色云彩前来拯救我 \n\n##### es6将promise纳入了JavaScript的标准，promise代表着“承诺”，初始化了一个“承诺”之后，你只要在then中定义好这个承诺若是在未来达成要做什么事情，在catch中定义好这个承诺失败了需要做什么事情，就ok了\n\n```javascript\nconst somePromiseObject = return new Promise((resolve, reject) => {\n    const result = doSomeThing();\n    if(result) {\n        return resolve(result); // handle success\n    }\n    reject('err') // handle error\n})\n\nsomePromiseObject\n    .then(data => {\n        // success callback  \n    },\n    err => {\n        // err callback\n    })\n```\n\n##### promise的出现完美的解救了callback的回调地狱，原因是promise允许链式调用，并且可以统一到最外层去做错误的catch~\n\n```javascript\nsomePromiseObject\n    .then(data => {\n        // do someThings..\n    })\n    .then(data => {\n        // do someThings..\n    })\n    .then(data => {\n        // do someThings..\n    })\n    .catch(err => {\n        // handle errs here\n    })\n```\n\n#### but 当我们认为promise就是JavaScript解决异步的最优方案的时候，ES2017 标准又引入了async 函数，使得异步操作变得更加方便\n\n## 异步终极利器async函数\n\n>我猜中了前头可我猜不中这结局 --promise\n\n##### 没错就在es6将promise加入标准后的不久，es7又新加入一种新的异步解决方案（号称终极解决方案）-- async函数\n\n##### 假设有个异步函数\n\n```javascript\najax1().then(() => {\n    ajax2().then(() => {\n        ajax3().then((data) => {\n            console.log(data) // success\n        }, err => {\n            console.log(err)\n        })\n    },\n    err => {\n        console.log(err)\n    })\n}, err => {\n    console.log(err)\n})\n```\n\n##### 好吧我们赶紧试试用async来实现\n\n```javascript\nconst asyncFun = async () => {\n    try{\n        await ajax1();\n        await ajax2();\n        const data = await ajax3();\n        console.log(data) // success\n    }catch(err){\n        console.log(err) // handle errs here\n    }\n}\n```\n\n##### 可以看到明显的看到，async的写法比promise的链式更舒服，它允许我们像写同步的语法一样去写嵌套的异步，实际的效果也会按照async 被 await 的顺序来运行，而且对开发最友好的是所有中间出现的错误都能被最外层的catch给捕获，所以说很多人都认为async将是js异步的终极解决方案，下面我们先来认识一下实现async的函数的一个基础函数，generator函数~\n\n## 什么是generator\n\n* 可以先看下阮一峰老师的[概念理解](http://es6.ruanyifeng.com/#docs/generator)\n* generator函数最神奇的地方在于它可以交出函数的控制权，什么意思呢，我们正常情况下的函数一旦被执行就会全部执行结束，除非发生错误，是不能在执行中间停下来的，而generator函数就不一样了，它可以用yeild关键字来将函数的执行暂停，generator函数执行后会返回一个迭代器(也可以理解为指针)，这个指针对象拥有一个关键的next方法，用来移动当前指针所在的位置，每次调用next返回一个对象，包含2个内容：value：当前generator函数中yeild语句后面表达式的值，done：bool值，标识当前迭代器是否结束迭代了，也就是说是否所有的yeild语句都走完了；\n* genarator 不仅仅可以暂停一个函数的执行，还可以在执行的时候送入数据给函数，改变函数中yeild关键字后面表达式的值；\n```javascript\n    function* gen(x) {\n        const y = yield x + 2;\n        const y1 = yield y + 3;\n        return y1;\n    }\n    \n    var g = gen(1);\n    console.log(g.next()); // { value: 3, done: false }\n    console.log(g.next(2)); // { value: 5, done: false }\n    console.log(g.next()); // { value: undefined, done: true }\n```\n* 可以看到运行g.next(2)之前y的值已经是3了，+3应该是6，实际返回的确实5，因为我们给入的值会替换掉yeild关键字后面的表达式，也就是y=2了，所以next(2)后的值是5而不是6；\n\n##### 既然generator可以暂停，如果我们每次遇到promise就暂停，等拿到promise.then()执行的结果在返回data，岂不是就是async函数的表现形式？dei，这确实就是async实现的基本原理，下面我们一起来手撸一个模拟async的函数--\"myAsync\"，盘它！\n\n## 盘它\n\n1. 根据async函数的表现，async关键字后面跟的是一个generator函数，我们用函数来模拟，如下结果：\n```javascript\n    // 函数A(正常情况);\nconst test = async function myGenerator(){\n    const data = await Promise.resolve(\"success\");\n    console.log(data);\n}\n\n// 函数B(模拟情况);\nfunction myAsync(myGenerator) {\n    // handle...\n}\nfunction* myGenerator() {\n    const data = yield Promise.resolve(\"success\");\n    console.log(data); // success\n}\nconst test = myAsync(myGenerator);\n```\n2. ok，然后我们来实现myAsync函数，这个函数会接受一个generator函数，我们知道generator函数调用后才会生成迭代器，拿到迭代器后，我们肯定需要调用next()来获取下一个yeild的值，然后如果这个值是一个promise，那我们就调用then拿到结果后再next到下一次的迭代中，否则，我们直接把拿到的数据不做处理直接给到next--核心思想：generator的迭代器结果，是promise就等异步完成，否则就直接返回数据，然后递归调用handle函数处理下一个迭代，直到迭代器的done是true，返回，看代码：\n\n```javascript\n// 函数B(模拟情况);\nfunction myAsync(myGenerator) {\n    const gen = myGenerator(); // 生成迭代器\n    const handle = genResult => {\n        if (genResult.done) return; // 如果迭代器结束了，直接返回；\n        return genResult.value instanceof Promise // 判断当前迭代器的value是否是Promise的实例\n            ? genResult.value\n                  // 如果是，则等待异步完成后继续递归下一个迭代，并把resolve后的data带过去\n                  .then(data => handle(gen.next(data)))\n                  .catch(err => gen.throw(err)) // gen.throw 可以抛出一个允许外层去catch的err\n            : handle(gen.next(genResult.value)); // 如果不是promise，就可以直接递归下一次迭代了\n    };\n    try {\n        handle(gen.next()); // 开始处理next迭代\n    } catch (err) {\n        throw err;\n    }\n}\nfunction* myGenerator() {\n    const data = yield Promise.resolve(\"success\");\n    console.log(data); // success\n}\nconst test = myAsync(myGenerator);\n```\n\n>到现在其实我们的核心功能handle函数就完成了，现在去调用next()方法，已经看到可以打印success了，但是，除了正常的promise，我们还要考虑下面的情况\n\n```javascript\n// 函数A(正常情况);\nconst a = {\n    then: () => {\n        console.log(\"then\");\n        return 123123;\n    }\n};\n\nconst test0 = async function() {};\n\nconst test1 = async function() {\n    return 123;\n};\nconst test2 = async function() {\n    console.log(123);\n};\nconst test4 = async function() {\n    return a;\n};\n\ntest0().then(console.log); // undefined\ntest1().then(console.log); // 123\ntest2().then(console.log); // 123 undefined\ntest4().then(console.log); // then\n```\n\n>也就是说在async接受到的函数不是generator函数的情况下：\n\n1. async函数默认返回一Promise.resolve(undefined)\n2. 当async接受到的函数有返回值，并且返回值不是promise的情况下，async函数默认用promise包装这个返回结果\n3. 当async接受到函数没有返回值，async会直接运行函数，并返回一个Promise.resolve(undefined)\n4. 考虑到thenable这种promise的鸭子类型函数的特殊性，我尝试去返回了一个这种类型的对象，果然，发现then被执行了~\n\n##### 那么，我们来完善边界情况的处理\n\n>所以现在的代码变成\n\n```javascript\n// 函数B(模拟情况);\nfunction myAsync(myGenerator) {\n    // 判断接受到的参数不是一个generator函数\n    if (\n        Object.prototype.toString.call(myGenerator) !==\n        \"[object GeneratorFunction]\"\n    ) {\n        // 如果是一个普通函数\n        if (\n            Object.prototype.toString.call(myGenerator) === \"[object Function]\"\n        ) {\n            return new Promise((resolve, reject) => {\n                // 默认返回一个promise对象\n                try {\n                    const data = myGenerator();\n                    return resolve(data); // 尝试运行这个函数，并把结果resolve出去\n                } catch (err) {\n                    return reject(err); // 失败处理\n                }\n            });\n        }\n        // 如果参数含有then这个方法--thenable 鸭子类型\n        if (typeof myGenerator.then === \"function\") {\n            return new Promise((resolve, reject) => {\n                try {\n                    // 运行这个对象的then函数，并resolve出去\n                    const data = myGenerator.then();\n                    return resolve(data);\n                } catch (err) {\n                    return reject(err); // 失败处理\n                }\n            });\n        }\n        // 剩下的情况，统一resolve出去给的参数\n        return Promise.resolve(myGenerator);\n    }\n    const gen = myGenerator(); // 生成迭代器\n    const handle = genResult => {\n        if (genResult.done) return; // 如果迭代器结束了，直接返回；\n        return genResult.value instanceof Promise // 判断当前迭代器的value是否是Promise的实例\n            ? genResult.value\n                  .then(data => handle(gen.next(data))) // 如果是，则等待异步完成后继续递归下一个迭代，并把resolve后的data带过去\n                  .catch(err => gen.throw(err)) // gen.throw 可以抛出一个允许外层去catch的err\n            : handle(gen.next(genResult.value)); // 如果不是promise，就可以直接递归下一次迭代了\n    };\n    try {\n        handle(gen.next()); // 开始处理next迭代\n    } catch (err) {\n        throw err;\n    }\n}\n\nconst a = {\n    then: () => {\n        console.log(\"then\");\n        return 123123;\n    }\n};\n\nconst test0 = myAsync(function() {});\n\nconst test1 = myAsync(function() {\n    return 123;\n});\n\nconst test2 = myAsync(function() {\n    console.log(123);\n});\nconst test4 = myAsync(function() {\n    return a;\n});\n\ntest0.then(console.log); // undefined\ntest1.then(console.log); // 123\ntest2.then(console.log); // 123 undefined\ntest4.then(console.log); // then\n```\n\n>有的同学可能会说，咦，es6的 async 函数返回的那个是个函数，需要执行才能拿到结果，比如test0 应该是 test() 返回的是promise，但是模拟出来的怎么直接就拿到返回的promise了，其实很简单，你只要再用一个函数(比如myAsyncWrapper)把这个函数包装一下就ok~\n\n##### 到此，我们的模拟就结束了，现在让我们来尽情的实验一下~\n\n```javascript\nmyAsync(function*() {\n    try {\n        const data1 = yield new Promise(res => {\n            setTimeout(() => {\n                res(1234);\n                console.log(\"step 1\"); // step 1\n            }, 1000);\n        });\n        console.log(data1); // step 1 打印1s后 打印 123\n        const data2 = yield new Promise(res => {\n            setTimeout(() => {\n                res(12342);\n                console.log(\"step 2\"); // step 2\n            }, 1000);\n        });\n        console.log(data2); // step 2 打印1s后打印 12342\n    } catch (err) {\n        console.log(888, err); \n    }\n});\n```\n\n>完美啊有么有，再来试试reject\n\n```javascript\nmyAsync(function*() {\n    try {\n        yield Promise.reject(123);\n        const data1 = yield new Promise(res => {\n            setTimeout(() => {\n                res(1234);\n                console.log(\"step 1\");\n            }, 1000);\n        });\n        console.log(data1);\n        const data2 = yield new Promise(res => {\n            setTimeout(() => {\n                res(12342);\n                console.log(\"step 2\");\n            }, 1000);\n        });\n        console.log(data2);\n    } catch (err) {\n        console.log(888, err); // 888 123\n    }\n});\n```\n\n>没问题直接输出了888 123\n\n##### 完美结束\n\n\n## 总结\n\n##### 1.async 函数是generator+promise的语法糖，可能es6具体的实现一定有一定的优化和处理，但是个人觉得理论上偏差不大\n\n##### 2.想要用的得心应手还是建议去猜测和理解一下实现的原理\n\n#### 3.特此声明：以上内容基本都是模拟实现，并不是真实的实现原理，没有写测试，因此可能有漏洞的存在，欢迎各位大佬批评指正，希望大家能够共同进步~\n\n\n> [代码demo传送门](https://github.com/jinggk/FrontEndCode/blob/master/async/demo.js)\n","slug":"手写async函数","published":1,"updated":"2019-06-20T05:05:12.895Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx4afn530009q67wexz62bkd","content":"<p><img src=\"evernotecid://2E1F95D0-6D94-423F-BC95-0D422C913EFE/appyinxiangcom/22692071/ENResource/p24\" alt=\"1327f9baa13e86641c721d111e51bc1e.jpeg\"></p>\n<h2 id=\"js的异步历史\"><a href=\"#js的异步历史\" class=\"headerlink\" title=\"js的异步历史\"></a>js的异步历史</h2><h5 id=\"我们都知道JavaScript是单线程的，避开了操作多线程的上锁和复杂的状态同步问题，单线程是无法充分利用cpu的，不过早期的JavaScript只是作为浏览器的脚本工具实现的，因此采用单线程是最方便最省事的，作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？\"><a href=\"#我们都知道JavaScript是单线程的，避开了操作多线程的上锁和复杂的状态同步问题，单线程是无法充分利用cpu的，不过早期的JavaScript只是作为浏览器的脚本工具实现的，因此采用单线程是最方便最省事的，作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？\" class=\"headerlink\" title=\"我们都知道JavaScript是单线程的，避开了操作多线程的上锁和复杂的状态同步问题，单线程是无法充分利用cpu的，不过早期的JavaScript只是作为浏览器的脚本工具实现的，因此采用单线程是最方便最省事的，作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？\"></a>我们都知道JavaScript是单线程的，避开了操作多线程的上锁和复杂的状态同步问题，单线程是无法充分利用cpu的，不过早期的JavaScript只是作为浏览器的脚本工具实现的，因此采用单线程是最方便最省事的，作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</h5><h2 id=\"水深火热的callback\"><a href=\"#水深火热的callback\" class=\"headerlink\" title=\"水深火热的callback\"></a>水深火热的callback</h2><h5 id=\"受制于单线程的原因，JavaScript在处理异步任务的时候就出现了比较尴尬的局面，比如AJAX请求，如果事情只能一件一件的来，当用户到服务器上去请求的时候，必须干等到结果回来才能继续后面的动作，这显而易见是不能被接受的，因此callback顺势而出，到后来的nodejs崛起，实现IO读取等异步的方式都是采用了callback的方式，也诞生了臭名昭著的callback-hell，场面开始失控…\"><a href=\"#受制于单线程的原因，JavaScript在处理异步任务的时候就出现了比较尴尬的局面，比如AJAX请求，如果事情只能一件一件的来，当用户到服务器上去请求的时候，必须干等到结果回来才能继续后面的动作，这显而易见是不能被接受的，因此callback顺势而出，到后来的nodejs崛起，实现IO读取等异步的方式都是采用了callback的方式，也诞生了臭名昭著的callback-hell，场面开始失控…\" class=\"headerlink\" title=\"受制于单线程的原因，JavaScript在处理异步任务的时候就出现了比较尴尬的局面，比如AJAX请求，如果事情只能一件一件的来，当用户到服务器上去请求的时候，必须干等到结果回来才能继续后面的动作，这显而易见是不能被接受的，因此callback顺势而出，到后来的nodejs崛起，实现IO读取等异步的方式都是采用了callback的方式，也诞生了臭名昭著的callback hell，场面开始失控…\"></a>受制于单线程的原因，JavaScript在处理异步任务的时候就出现了比较尴尬的局面，比如AJAX请求，如果事情只能一件一件的来，当用户到服务器上去请求的时候，必须干等到结果回来才能继续后面的动作，这显而易见是不能被接受的，因此callback顺势而出，到后来的nodejs崛起，实现IO读取等异步的方式都是采用了callback的方式，也诞生了臭名昭著的callback hell，场面开始失控…</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">param, cb</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"literal\">false</span>.readFile(param, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(err) <span class=\"keyword\">return</span> cb(err);</span><br><span class=\"line\">        async1(data, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(err) <span class=\"keyword\">return</span> cb(err);</span><br><span class=\"line\">            async2(data, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>)</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(err) <span class=\"keyword\">return</span> cb(err);</span><br><span class=\"line\">                <span class=\"comment\">// asyncN... 不知道会有多少</span></span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"拯救callback的promise\"><a href=\"#拯救callback的promise\" class=\"headerlink\" title=\"拯救callback的promise\"></a>拯救callback的promise</h2><blockquote>\n<p>我的意中人是盖世英雄，有一天他会踏着七色云彩前来拯救我 </p>\n</blockquote>\n<h5 id=\"es6将promise纳入了JavaScript的标准，promise代表着“承诺”，初始化了一个“承诺”之后，你只要在then中定义好这个承诺若是在未来达成要做什么事情，在catch中定义好这个承诺失败了需要做什么事情，就ok了\"><a href=\"#es6将promise纳入了JavaScript的标准，promise代表着“承诺”，初始化了一个“承诺”之后，你只要在then中定义好这个承诺若是在未来达成要做什么事情，在catch中定义好这个承诺失败了需要做什么事情，就ok了\" class=\"headerlink\" title=\"es6将promise纳入了JavaScript的标准，promise代表着“承诺”，初始化了一个“承诺”之后，你只要在then中定义好这个承诺若是在未来达成要做什么事情，在catch中定义好这个承诺失败了需要做什么事情，就ok了\"></a>es6将promise纳入了JavaScript的标准，promise代表着“承诺”，初始化了一个“承诺”之后，你只要在then中定义好这个承诺若是在未来达成要做什么事情，在catch中定义好这个承诺失败了需要做什么事情，就ok了</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> somePromiseObject = <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = doSomeThing();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(result) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> resolve(result); <span class=\"comment\">// handle success</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    reject(<span class=\"string\">'err'</span>) <span class=\"comment\">// handle error</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">somePromiseObject</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// success callback  </span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    err =&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// err callback</span></span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"promise的出现完美的解救了callback的回调地狱，原因是promise允许链式调用，并且可以统一到最外层去做错误的catch\"><a href=\"#promise的出现完美的解救了callback的回调地狱，原因是promise允许链式调用，并且可以统一到最外层去做错误的catch\" class=\"headerlink\" title=\"promise的出现完美的解救了callback的回调地狱，原因是promise允许链式调用，并且可以统一到最外层去做错误的catch~\"></a>promise的出现完美的解救了callback的回调地狱，原因是promise允许链式调用，并且可以统一到最外层去做错误的catch~</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">somePromiseObject</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do someThings..</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do someThings..</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do someThings..</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// handle errs here</span></span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"but-当我们认为promise就是JavaScript解决异步的最优方案的时候，ES2017-标准又引入了async-函数，使得异步操作变得更加方便\"><a href=\"#but-当我们认为promise就是JavaScript解决异步的最优方案的时候，ES2017-标准又引入了async-函数，使得异步操作变得更加方便\" class=\"headerlink\" title=\"but 当我们认为promise就是JavaScript解决异步的最优方案的时候，ES2017 标准又引入了async 函数，使得异步操作变得更加方便\"></a>but 当我们认为promise就是JavaScript解决异步的最优方案的时候，ES2017 标准又引入了async 函数，使得异步操作变得更加方便</h4><h2 id=\"异步终极利器async函数\"><a href=\"#异步终极利器async函数\" class=\"headerlink\" title=\"异步终极利器async函数\"></a>异步终极利器async函数</h2><blockquote>\n<p>我猜中了前头可我猜不中这结局 –promise</p>\n</blockquote>\n<h5 id=\"没错就在es6将promise加入标准后的不久，es7又新加入一种新的异步解决方案（号称终极解决方案）–-async函数\"><a href=\"#没错就在es6将promise加入标准后的不久，es7又新加入一种新的异步解决方案（号称终极解决方案）–-async函数\" class=\"headerlink\" title=\"没错就在es6将promise加入标准后的不久，es7又新加入一种新的异步解决方案（号称终极解决方案）– async函数\"></a>没错就在es6将promise加入标准后的不久，es7又新加入一种新的异步解决方案（号称终极解决方案）– async函数</h5><h5 id=\"假设有个异步函数\"><a href=\"#假设有个异步函数\" class=\"headerlink\" title=\"假设有个异步函数\"></a>假设有个异步函数</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ajax1().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    ajax2().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        ajax3().then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(data) <span class=\"comment\">// success</span></span><br><span class=\"line\">        &#125;, err =&gt; &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    err =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;, err =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"好吧我们赶紧试试用async来实现\"><a href=\"#好吧我们赶紧试试用async来实现\" class=\"headerlink\" title=\"好吧我们赶紧试试用async来实现\"></a>好吧我们赶紧试试用async来实现</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> asyncFun = <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">await</span> ajax1();</span><br><span class=\"line\">        <span class=\"keyword\">await</span> ajax2();</span><br><span class=\"line\">        <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> ajax3();</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(data) <span class=\"comment\">// success</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(err)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(err) <span class=\"comment\">// handle errs here</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"可以看到明显的看到，async的写法比promise的链式更舒服，它允许我们像写同步的语法一样去写嵌套的异步，实际的效果也会按照async-被-await-的顺序来运行，而且对开发最友好的是所有中间出现的错误都能被最外层的catch给捕获，所以说很多人都认为async将是js异步的终极解决方案，下面我们先来认识一下实现async的函数的一个基础函数，generator函数\"><a href=\"#可以看到明显的看到，async的写法比promise的链式更舒服，它允许我们像写同步的语法一样去写嵌套的异步，实际的效果也会按照async-被-await-的顺序来运行，而且对开发最友好的是所有中间出现的错误都能被最外层的catch给捕获，所以说很多人都认为async将是js异步的终极解决方案，下面我们先来认识一下实现async的函数的一个基础函数，generator函数\" class=\"headerlink\" title=\"可以看到明显的看到，async的写法比promise的链式更舒服，它允许我们像写同步的语法一样去写嵌套的异步，实际的效果也会按照async 被 await 的顺序来运行，而且对开发最友好的是所有中间出现的错误都能被最外层的catch给捕获，所以说很多人都认为async将是js异步的终极解决方案，下面我们先来认识一下实现async的函数的一个基础函数，generator函数~\"></a>可以看到明显的看到，async的写法比promise的链式更舒服，它允许我们像写同步的语法一样去写嵌套的异步，实际的效果也会按照async 被 await 的顺序来运行，而且对开发最友好的是所有中间出现的错误都能被最外层的catch给捕获，所以说很多人都认为async将是js异步的终极解决方案，下面我们先来认识一下实现async的函数的一个基础函数，generator函数~</h5><h2 id=\"什么是generator\"><a href=\"#什么是generator\" class=\"headerlink\" title=\"什么是generator\"></a>什么是generator</h2><ul>\n<li><p>可以先看下阮一峰老师的<a href=\"http://es6.ruanyifeng.com/#docs/generator\" target=\"_blank\" rel=\"noopener\">概念理解</a></p>\n</li>\n<li><p>generator函数最神奇的地方在于它可以交出函数的控制权，什么意思呢，我们正常情况下的函数一旦被执行就会全部执行结束，除非发生错误，是不能在执行中间停下来的，而generator函数就不一样了，它可以用yeild关键字来将函数的执行暂停，generator函数执行后会返回一个迭代器(也可以理解为指针)，这个指针对象拥有一个关键的next方法，用来移动当前指针所在的位置，每次调用next返回一个对象，包含2个内容：value：当前generator函数中yeild语句后面表达式的值，done：bool值，标识当前迭代器是否结束迭代了，也就是说是否所有的yeild语句都走完了；</p>\n</li>\n<li><p>genarator 不仅仅可以暂停一个函数的执行，还可以在执行的时候送入数据给函数，改变函数中yeild关键字后面表达式的值；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> y = <span class=\"keyword\">yield</span> x + <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> y1 = <span class=\"keyword\">yield</span> y + <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> y1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = gen(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g.next()); <span class=\"comment\">// &#123; value: 3, done: false &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g.next(<span class=\"number\">2</span>)); <span class=\"comment\">// &#123; value: 5, done: false &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g.next()); <span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以看到运行g.next(2)之前y的值已经是3了，+3应该是6，实际返回的确实5，因为我们给入的值会替换掉yeild关键字后面的表达式，也就是y=2了，所以next(2)后的值是5而不是6；</p>\n</li>\n</ul>\n<h5 id=\"既然generator可以暂停，如果我们每次遇到promise就暂停，等拿到promise-then-执行的结果在返回data，岂不是就是async函数的表现形式？dei，这确实就是async实现的基本原理，下面我们一起来手撸一个模拟async的函数–”myAsync”，盘它！\"><a href=\"#既然generator可以暂停，如果我们每次遇到promise就暂停，等拿到promise-then-执行的结果在返回data，岂不是就是async函数的表现形式？dei，这确实就是async实现的基本原理，下面我们一起来手撸一个模拟async的函数–”myAsync”，盘它！\" class=\"headerlink\" title=\"既然generator可以暂停，如果我们每次遇到promise就暂停，等拿到promise.then()执行的结果在返回data，岂不是就是async函数的表现形式？dei，这确实就是async实现的基本原理，下面我们一起来手撸一个模拟async的函数–”myAsync”，盘它！\"></a>既然generator可以暂停，如果我们每次遇到promise就暂停，等拿到promise.then()执行的结果在返回data，岂不是就是async函数的表现形式？dei，这确实就是async实现的基本原理，下面我们一起来手撸一个模拟async的函数–”myAsync”，盘它！</h5><h2 id=\"盘它\"><a href=\"#盘它\" class=\"headerlink\" title=\"盘它\"></a>盘它</h2><ol>\n<li><p>根据async函数的表现，async关键字后面跟的是一个generator函数，我们用函数来模拟，如下结果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">// 函数A(正常情况);</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> test = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myGenerator</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">\"success\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数B(模拟情况);</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myAsync</span>(<span class=\"params\">myGenerator</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// handle...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">myGenerator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"keyword\">yield</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">\"success\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data); <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> test = myAsync(myGenerator);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ok，然后我们来实现myAsync函数，这个函数会接受一个generator函数，我们知道generator函数调用后才会生成迭代器，拿到迭代器后，我们肯定需要调用next()来获取下一个yeild的值，然后如果这个值是一个promise，那我们就调用then拿到结果后再next到下一次的迭代中，否则，我们直接把拿到的数据不做处理直接给到next–核心思想：generator的迭代器结果，是promise就等异步完成，否则就直接返回数据，然后递归调用handle函数处理下一个迭代，直到迭代器的done是true，返回，看代码：</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数B(模拟情况);</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myAsync</span>(<span class=\"params\">myGenerator</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> gen = myGenerator(); <span class=\"comment\">// 生成迭代器</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> handle = <span class=\"function\"><span class=\"params\">genResult</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (genResult.done) <span class=\"keyword\">return</span>; <span class=\"comment\">// 如果迭代器结束了，直接返回；</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> genResult.value <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span> <span class=\"comment\">// 判断当前迭代器的value是否是Promise的实例</span></span><br><span class=\"line\">            ? genResult.value</span><br><span class=\"line\">                  <span class=\"comment\">// 如果是，则等待异步完成后继续递归下一个迭代，并把resolve后的data带过去</span></span><br><span class=\"line\">                  .then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> handle(gen.next(data)))</span><br><span class=\"line\">                  .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> gen.throw(err)) <span class=\"comment\">// gen.throw 可以抛出一个允许外层去catch的err</span></span><br><span class=\"line\">            : handle(gen.next(genResult.value)); <span class=\"comment\">// 如果不是promise，就可以直接递归下一次迭代了</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        handle(gen.next()); <span class=\"comment\">// 开始处理next迭代</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">myGenerator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"keyword\">yield</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">\"success\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data); <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> test = myAsync(myGenerator);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>到现在其实我们的核心功能handle函数就完成了，现在去调用next()方法，已经看到可以打印success了，但是，除了正常的promise，我们还要考虑下面的情况</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数A(正常情况);</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = &#123;</span><br><span class=\"line\">    then: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"then\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">123123</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> test0 = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> test1 = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">123</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> test2 = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">123</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> test4 = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">test0().then(<span class=\"built_in\">console</span>.log); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">test1().then(<span class=\"built_in\">console</span>.log); <span class=\"comment\">// 123</span></span><br><span class=\"line\">test2().then(<span class=\"built_in\">console</span>.log); <span class=\"comment\">// 123 undefined</span></span><br><span class=\"line\">test4().then(<span class=\"built_in\">console</span>.log); <span class=\"comment\">// then</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>也就是说在async接受到的函数不是generator函数的情况下：</p>\n</blockquote>\n<ol>\n<li>async函数默认返回一Promise.resolve(undefined)</li>\n<li>当async接受到的函数有返回值，并且返回值不是promise的情况下，async函数默认用promise包装这个返回结果</li>\n<li>当async接受到函数没有返回值，async会直接运行函数，并返回一个Promise.resolve(undefined)</li>\n<li>考虑到thenable这种promise的鸭子类型函数的特殊性，我尝试去返回了一个这种类型的对象，果然，发现then被执行了~</li>\n</ol>\n<h5 id=\"那么，我们来完善边界情况的处理\"><a href=\"#那么，我们来完善边界情况的处理\" class=\"headerlink\" title=\"那么，我们来完善边界情况的处理\"></a>那么，我们来完善边界情况的处理</h5><blockquote>\n<p>所以现在的代码变成</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数B(模拟情况);</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myAsync</span>(<span class=\"params\">myGenerator</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断接受到的参数不是一个generator函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        <span class=\"built_in\">Object</span>.prototype.toString.call(myGenerator) !==</span><br><span class=\"line\">        <span class=\"string\">\"[object GeneratorFunction]\"</span></span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果是一个普通函数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (</span><br><span class=\"line\">            <span class=\"built_in\">Object</span>.prototype.toString.call(myGenerator) === <span class=\"string\">\"[object Function]\"</span></span><br><span class=\"line\">        ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 默认返回一个promise对象</span></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">const</span> data = myGenerator();</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> resolve(data); <span class=\"comment\">// 尝试运行这个函数，并把结果resolve出去</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> reject(err); <span class=\"comment\">// 失败处理</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果参数含有then这个方法--thenable 鸭子类型</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> myGenerator.then === <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 运行这个对象的then函数，并resolve出去</span></span><br><span class=\"line\">                    <span class=\"keyword\">const</span> data = myGenerator.then();</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> resolve(data);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> reject(err); <span class=\"comment\">// 失败处理</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 剩下的情况，统一resolve出去给的参数</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(myGenerator);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> gen = myGenerator(); <span class=\"comment\">// 生成迭代器</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> handle = <span class=\"function\"><span class=\"params\">genResult</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (genResult.done) <span class=\"keyword\">return</span>; <span class=\"comment\">// 如果迭代器结束了，直接返回；</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> genResult.value <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span> <span class=\"comment\">// 判断当前迭代器的value是否是Promise的实例</span></span><br><span class=\"line\">            ? genResult.value</span><br><span class=\"line\">                  .then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> handle(gen.next(data))) <span class=\"comment\">// 如果是，则等待异步完成后继续递归下一个迭代，并把resolve后的data带过去</span></span><br><span class=\"line\">                  .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> gen.throw(err)) <span class=\"comment\">// gen.throw 可以抛出一个允许外层去catch的err</span></span><br><span class=\"line\">            : handle(gen.next(genResult.value)); <span class=\"comment\">// 如果不是promise，就可以直接递归下一次迭代了</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        handle(gen.next()); <span class=\"comment\">// 开始处理next迭代</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = &#123;</span><br><span class=\"line\">    then: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"then\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">123123</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> test0 = myAsync(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> test1 = myAsync(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">123</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> test2 = myAsync(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">123</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> test4 = myAsync(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">test0.then(<span class=\"built_in\">console</span>.log); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">test1.then(<span class=\"built_in\">console</span>.log); <span class=\"comment\">// 123</span></span><br><span class=\"line\">test2.then(<span class=\"built_in\">console</span>.log); <span class=\"comment\">// 123 undefined</span></span><br><span class=\"line\">test4.then(<span class=\"built_in\">console</span>.log); <span class=\"comment\">// then</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>有的同学可能会说，咦，es6的 async 函数返回的那个是个函数，需要执行才能拿到结果，比如test0 应该是 test() 返回的是promise，但是模拟出来的怎么直接就拿到返回的promise了，其实很简单，你只要再用一个函数(比如myAsyncWrapper)把这个函数包装一下就ok~</p>\n</blockquote>\n<h5 id=\"到此，我们的模拟就结束了，现在让我们来尽情的实验一下\"><a href=\"#到此，我们的模拟就结束了，现在让我们来尽情的实验一下\" class=\"headerlink\" title=\"到此，我们的模拟就结束了，现在让我们来尽情的实验一下~\"></a>到此，我们的模拟就结束了，现在让我们来尽情的实验一下~</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myAsync(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> data1 = <span class=\"keyword\">yield</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">            setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">                res(<span class=\"number\">1234</span>);</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"step 1\"</span>); <span class=\"comment\">// step 1</span></span><br><span class=\"line\">            &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(data1); <span class=\"comment\">// step 1 打印1s后 打印 123</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> data2 = <span class=\"keyword\">yield</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">            setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">                res(<span class=\"number\">12342</span>);</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"step 2\"</span>); <span class=\"comment\">// step 2</span></span><br><span class=\"line\">            &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(data2); <span class=\"comment\">// step 2 打印1s后打印 12342</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">888</span>, err); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>完美啊有么有，再来试试reject</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myAsync(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"number\">123</span>);</span><br><span class=\"line\">        <span class=\"keyword\">const</span> data1 = <span class=\"keyword\">yield</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">            setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">                res(<span class=\"number\">1234</span>);</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"step 1\"</span>);</span><br><span class=\"line\">            &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(data1);</span><br><span class=\"line\">        <span class=\"keyword\">const</span> data2 = <span class=\"keyword\">yield</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">            setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">                res(<span class=\"number\">12342</span>);</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"step 2\"</span>);</span><br><span class=\"line\">            &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(data2);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">888</span>, err); <span class=\"comment\">// 888 123</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>没问题直接输出了888 123</p>\n</blockquote>\n<h5 id=\"完美结束\"><a href=\"#完美结束\" class=\"headerlink\" title=\"完美结束\"></a>完美结束</h5><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h5 id=\"1-async-函数是generator-promise的语法糖，可能es6具体的实现一定有一定的优化和处理，但是个人觉得理论上偏差不大\"><a href=\"#1-async-函数是generator-promise的语法糖，可能es6具体的实现一定有一定的优化和处理，但是个人觉得理论上偏差不大\" class=\"headerlink\" title=\"1.async 函数是generator+promise的语法糖，可能es6具体的实现一定有一定的优化和处理，但是个人觉得理论上偏差不大\"></a>1.async 函数是generator+promise的语法糖，可能es6具体的实现一定有一定的优化和处理，但是个人觉得理论上偏差不大</h5><h5 id=\"2-想要用的得心应手还是建议去猜测和理解一下实现的原理\"><a href=\"#2-想要用的得心应手还是建议去猜测和理解一下实现的原理\" class=\"headerlink\" title=\"2.想要用的得心应手还是建议去猜测和理解一下实现的原理\"></a>2.想要用的得心应手还是建议去猜测和理解一下实现的原理</h5><h4 id=\"3-特此声明：以上内容基本都是模拟实现，并不是真实的实现原理，没有写测试，因此可能有漏洞的存在，欢迎各位大佬批评指正，希望大家能够共同进步\"><a href=\"#3-特此声明：以上内容基本都是模拟实现，并不是真实的实现原理，没有写测试，因此可能有漏洞的存在，欢迎各位大佬批评指正，希望大家能够共同进步\" class=\"headerlink\" title=\"3.特此声明：以上内容基本都是模拟实现，并不是真实的实现原理，没有写测试，因此可能有漏洞的存在，欢迎各位大佬批评指正，希望大家能够共同进步~\"></a>3.特此声明：以上内容基本都是模拟实现，并不是真实的实现原理，没有写测试，因此可能有漏洞的存在，欢迎各位大佬批评指正，希望大家能够共同进步~</h4><blockquote>\n<p><a href=\"https://github.com/jinggk/FrontEndCode/blob/master/async/demo.js\" target=\"_blank\" rel=\"noopener\">代码demo传送门</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"evernotecid://2E1F95D0-6D94-423F-BC95-0D422C913EFE/appyinxiangcom/22692071/ENResource/p24\" alt=\"1327f9baa13e86641c721d111e51bc1e.jpeg\"></p>\n<h2 id=\"js的异步历史\"><a href=\"#js的异步历史\" class=\"headerlink\" title=\"js的异步历史\"></a>js的异步历史</h2><h5 id=\"我们都知道JavaScript是单线程的，避开了操作多线程的上锁和复杂的状态同步问题，单线程是无法充分利用cpu的，不过早期的JavaScript只是作为浏览器的脚本工具实现的，因此采用单线程是最方便最省事的，作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？\"><a href=\"#我们都知道JavaScript是单线程的，避开了操作多线程的上锁和复杂的状态同步问题，单线程是无法充分利用cpu的，不过早期的JavaScript只是作为浏览器的脚本工具实现的，因此采用单线程是最方便最省事的，作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？\" class=\"headerlink\" title=\"我们都知道JavaScript是单线程的，避开了操作多线程的上锁和复杂的状态同步问题，单线程是无法充分利用cpu的，不过早期的JavaScript只是作为浏览器的脚本工具实现的，因此采用单线程是最方便最省事的，作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？\"></a>我们都知道JavaScript是单线程的，避开了操作多线程的上锁和复杂的状态同步问题，单线程是无法充分利用cpu的，不过早期的JavaScript只是作为浏览器的脚本工具实现的，因此采用单线程是最方便最省事的，作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</h5><h2 id=\"水深火热的callback\"><a href=\"#水深火热的callback\" class=\"headerlink\" title=\"水深火热的callback\"></a>水深火热的callback</h2><h5 id=\"受制于单线程的原因，JavaScript在处理异步任务的时候就出现了比较尴尬的局面，比如AJAX请求，如果事情只能一件一件的来，当用户到服务器上去请求的时候，必须干等到结果回来才能继续后面的动作，这显而易见是不能被接受的，因此callback顺势而出，到后来的nodejs崛起，实现IO读取等异步的方式都是采用了callback的方式，也诞生了臭名昭著的callback-hell，场面开始失控…\"><a href=\"#受制于单线程的原因，JavaScript在处理异步任务的时候就出现了比较尴尬的局面，比如AJAX请求，如果事情只能一件一件的来，当用户到服务器上去请求的时候，必须干等到结果回来才能继续后面的动作，这显而易见是不能被接受的，因此callback顺势而出，到后来的nodejs崛起，实现IO读取等异步的方式都是采用了callback的方式，也诞生了臭名昭著的callback-hell，场面开始失控…\" class=\"headerlink\" title=\"受制于单线程的原因，JavaScript在处理异步任务的时候就出现了比较尴尬的局面，比如AJAX请求，如果事情只能一件一件的来，当用户到服务器上去请求的时候，必须干等到结果回来才能继续后面的动作，这显而易见是不能被接受的，因此callback顺势而出，到后来的nodejs崛起，实现IO读取等异步的方式都是采用了callback的方式，也诞生了臭名昭著的callback hell，场面开始失控…\"></a>受制于单线程的原因，JavaScript在处理异步任务的时候就出现了比较尴尬的局面，比如AJAX请求，如果事情只能一件一件的来，当用户到服务器上去请求的时候，必须干等到结果回来才能继续后面的动作，这显而易见是不能被接受的，因此callback顺势而出，到后来的nodejs崛起，实现IO读取等异步的方式都是采用了callback的方式，也诞生了臭名昭著的callback hell，场面开始失控…</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">param, cb</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"literal\">false</span>.readFile(param, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(err) <span class=\"keyword\">return</span> cb(err);</span><br><span class=\"line\">        async1(data, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(err) <span class=\"keyword\">return</span> cb(err);</span><br><span class=\"line\">            async2(data, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>)</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(err) <span class=\"keyword\">return</span> cb(err);</span><br><span class=\"line\">                <span class=\"comment\">// asyncN... 不知道会有多少</span></span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"拯救callback的promise\"><a href=\"#拯救callback的promise\" class=\"headerlink\" title=\"拯救callback的promise\"></a>拯救callback的promise</h2><blockquote>\n<p>我的意中人是盖世英雄，有一天他会踏着七色云彩前来拯救我 </p>\n</blockquote>\n<h5 id=\"es6将promise纳入了JavaScript的标准，promise代表着“承诺”，初始化了一个“承诺”之后，你只要在then中定义好这个承诺若是在未来达成要做什么事情，在catch中定义好这个承诺失败了需要做什么事情，就ok了\"><a href=\"#es6将promise纳入了JavaScript的标准，promise代表着“承诺”，初始化了一个“承诺”之后，你只要在then中定义好这个承诺若是在未来达成要做什么事情，在catch中定义好这个承诺失败了需要做什么事情，就ok了\" class=\"headerlink\" title=\"es6将promise纳入了JavaScript的标准，promise代表着“承诺”，初始化了一个“承诺”之后，你只要在then中定义好这个承诺若是在未来达成要做什么事情，在catch中定义好这个承诺失败了需要做什么事情，就ok了\"></a>es6将promise纳入了JavaScript的标准，promise代表着“承诺”，初始化了一个“承诺”之后，你只要在then中定义好这个承诺若是在未来达成要做什么事情，在catch中定义好这个承诺失败了需要做什么事情，就ok了</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> somePromiseObject = <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = doSomeThing();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(result) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> resolve(result); <span class=\"comment\">// handle success</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    reject(<span class=\"string\">'err'</span>) <span class=\"comment\">// handle error</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">somePromiseObject</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// success callback  </span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    err =&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// err callback</span></span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"promise的出现完美的解救了callback的回调地狱，原因是promise允许链式调用，并且可以统一到最外层去做错误的catch\"><a href=\"#promise的出现完美的解救了callback的回调地狱，原因是promise允许链式调用，并且可以统一到最外层去做错误的catch\" class=\"headerlink\" title=\"promise的出现完美的解救了callback的回调地狱，原因是promise允许链式调用，并且可以统一到最外层去做错误的catch~\"></a>promise的出现完美的解救了callback的回调地狱，原因是promise允许链式调用，并且可以统一到最外层去做错误的catch~</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">somePromiseObject</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do someThings..</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do someThings..</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do someThings..</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// handle errs here</span></span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"but-当我们认为promise就是JavaScript解决异步的最优方案的时候，ES2017-标准又引入了async-函数，使得异步操作变得更加方便\"><a href=\"#but-当我们认为promise就是JavaScript解决异步的最优方案的时候，ES2017-标准又引入了async-函数，使得异步操作变得更加方便\" class=\"headerlink\" title=\"but 当我们认为promise就是JavaScript解决异步的最优方案的时候，ES2017 标准又引入了async 函数，使得异步操作变得更加方便\"></a>but 当我们认为promise就是JavaScript解决异步的最优方案的时候，ES2017 标准又引入了async 函数，使得异步操作变得更加方便</h4><h2 id=\"异步终极利器async函数\"><a href=\"#异步终极利器async函数\" class=\"headerlink\" title=\"异步终极利器async函数\"></a>异步终极利器async函数</h2><blockquote>\n<p>我猜中了前头可我猜不中这结局 –promise</p>\n</blockquote>\n<h5 id=\"没错就在es6将promise加入标准后的不久，es7又新加入一种新的异步解决方案（号称终极解决方案）–-async函数\"><a href=\"#没错就在es6将promise加入标准后的不久，es7又新加入一种新的异步解决方案（号称终极解决方案）–-async函数\" class=\"headerlink\" title=\"没错就在es6将promise加入标准后的不久，es7又新加入一种新的异步解决方案（号称终极解决方案）– async函数\"></a>没错就在es6将promise加入标准后的不久，es7又新加入一种新的异步解决方案（号称终极解决方案）– async函数</h5><h5 id=\"假设有个异步函数\"><a href=\"#假设有个异步函数\" class=\"headerlink\" title=\"假设有个异步函数\"></a>假设有个异步函数</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ajax1().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    ajax2().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        ajax3().then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(data) <span class=\"comment\">// success</span></span><br><span class=\"line\">        &#125;, err =&gt; &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    err =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;, err =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"好吧我们赶紧试试用async来实现\"><a href=\"#好吧我们赶紧试试用async来实现\" class=\"headerlink\" title=\"好吧我们赶紧试试用async来实现\"></a>好吧我们赶紧试试用async来实现</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> asyncFun = <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">await</span> ajax1();</span><br><span class=\"line\">        <span class=\"keyword\">await</span> ajax2();</span><br><span class=\"line\">        <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> ajax3();</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(data) <span class=\"comment\">// success</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(err)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(err) <span class=\"comment\">// handle errs here</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"可以看到明显的看到，async的写法比promise的链式更舒服，它允许我们像写同步的语法一样去写嵌套的异步，实际的效果也会按照async-被-await-的顺序来运行，而且对开发最友好的是所有中间出现的错误都能被最外层的catch给捕获，所以说很多人都认为async将是js异步的终极解决方案，下面我们先来认识一下实现async的函数的一个基础函数，generator函数\"><a href=\"#可以看到明显的看到，async的写法比promise的链式更舒服，它允许我们像写同步的语法一样去写嵌套的异步，实际的效果也会按照async-被-await-的顺序来运行，而且对开发最友好的是所有中间出现的错误都能被最外层的catch给捕获，所以说很多人都认为async将是js异步的终极解决方案，下面我们先来认识一下实现async的函数的一个基础函数，generator函数\" class=\"headerlink\" title=\"可以看到明显的看到，async的写法比promise的链式更舒服，它允许我们像写同步的语法一样去写嵌套的异步，实际的效果也会按照async 被 await 的顺序来运行，而且对开发最友好的是所有中间出现的错误都能被最外层的catch给捕获，所以说很多人都认为async将是js异步的终极解决方案，下面我们先来认识一下实现async的函数的一个基础函数，generator函数~\"></a>可以看到明显的看到，async的写法比promise的链式更舒服，它允许我们像写同步的语法一样去写嵌套的异步，实际的效果也会按照async 被 await 的顺序来运行，而且对开发最友好的是所有中间出现的错误都能被最外层的catch给捕获，所以说很多人都认为async将是js异步的终极解决方案，下面我们先来认识一下实现async的函数的一个基础函数，generator函数~</h5><h2 id=\"什么是generator\"><a href=\"#什么是generator\" class=\"headerlink\" title=\"什么是generator\"></a>什么是generator</h2><ul>\n<li><p>可以先看下阮一峰老师的<a href=\"http://es6.ruanyifeng.com/#docs/generator\" target=\"_blank\" rel=\"noopener\">概念理解</a></p>\n</li>\n<li><p>generator函数最神奇的地方在于它可以交出函数的控制权，什么意思呢，我们正常情况下的函数一旦被执行就会全部执行结束，除非发生错误，是不能在执行中间停下来的，而generator函数就不一样了，它可以用yeild关键字来将函数的执行暂停，generator函数执行后会返回一个迭代器(也可以理解为指针)，这个指针对象拥有一个关键的next方法，用来移动当前指针所在的位置，每次调用next返回一个对象，包含2个内容：value：当前generator函数中yeild语句后面表达式的值，done：bool值，标识当前迭代器是否结束迭代了，也就是说是否所有的yeild语句都走完了；</p>\n</li>\n<li><p>genarator 不仅仅可以暂停一个函数的执行，还可以在执行的时候送入数据给函数，改变函数中yeild关键字后面表达式的值；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> y = <span class=\"keyword\">yield</span> x + <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> y1 = <span class=\"keyword\">yield</span> y + <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> y1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = gen(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g.next()); <span class=\"comment\">// &#123; value: 3, done: false &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g.next(<span class=\"number\">2</span>)); <span class=\"comment\">// &#123; value: 5, done: false &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g.next()); <span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以看到运行g.next(2)之前y的值已经是3了，+3应该是6，实际返回的确实5，因为我们给入的值会替换掉yeild关键字后面的表达式，也就是y=2了，所以next(2)后的值是5而不是6；</p>\n</li>\n</ul>\n<h5 id=\"既然generator可以暂停，如果我们每次遇到promise就暂停，等拿到promise-then-执行的结果在返回data，岂不是就是async函数的表现形式？dei，这确实就是async实现的基本原理，下面我们一起来手撸一个模拟async的函数–”myAsync”，盘它！\"><a href=\"#既然generator可以暂停，如果我们每次遇到promise就暂停，等拿到promise-then-执行的结果在返回data，岂不是就是async函数的表现形式？dei，这确实就是async实现的基本原理，下面我们一起来手撸一个模拟async的函数–”myAsync”，盘它！\" class=\"headerlink\" title=\"既然generator可以暂停，如果我们每次遇到promise就暂停，等拿到promise.then()执行的结果在返回data，岂不是就是async函数的表现形式？dei，这确实就是async实现的基本原理，下面我们一起来手撸一个模拟async的函数–”myAsync”，盘它！\"></a>既然generator可以暂停，如果我们每次遇到promise就暂停，等拿到promise.then()执行的结果在返回data，岂不是就是async函数的表现形式？dei，这确实就是async实现的基本原理，下面我们一起来手撸一个模拟async的函数–”myAsync”，盘它！</h5><h2 id=\"盘它\"><a href=\"#盘它\" class=\"headerlink\" title=\"盘它\"></a>盘它</h2><ol>\n<li><p>根据async函数的表现，async关键字后面跟的是一个generator函数，我们用函数来模拟，如下结果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">// 函数A(正常情况);</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> test = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myGenerator</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">\"success\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数B(模拟情况);</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myAsync</span>(<span class=\"params\">myGenerator</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// handle...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">myGenerator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"keyword\">yield</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">\"success\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data); <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> test = myAsync(myGenerator);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ok，然后我们来实现myAsync函数，这个函数会接受一个generator函数，我们知道generator函数调用后才会生成迭代器，拿到迭代器后，我们肯定需要调用next()来获取下一个yeild的值，然后如果这个值是一个promise，那我们就调用then拿到结果后再next到下一次的迭代中，否则，我们直接把拿到的数据不做处理直接给到next–核心思想：generator的迭代器结果，是promise就等异步完成，否则就直接返回数据，然后递归调用handle函数处理下一个迭代，直到迭代器的done是true，返回，看代码：</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数B(模拟情况);</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myAsync</span>(<span class=\"params\">myGenerator</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> gen = myGenerator(); <span class=\"comment\">// 生成迭代器</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> handle = <span class=\"function\"><span class=\"params\">genResult</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (genResult.done) <span class=\"keyword\">return</span>; <span class=\"comment\">// 如果迭代器结束了，直接返回；</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> genResult.value <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span> <span class=\"comment\">// 判断当前迭代器的value是否是Promise的实例</span></span><br><span class=\"line\">            ? genResult.value</span><br><span class=\"line\">                  <span class=\"comment\">// 如果是，则等待异步完成后继续递归下一个迭代，并把resolve后的data带过去</span></span><br><span class=\"line\">                  .then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> handle(gen.next(data)))</span><br><span class=\"line\">                  .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> gen.throw(err)) <span class=\"comment\">// gen.throw 可以抛出一个允许外层去catch的err</span></span><br><span class=\"line\">            : handle(gen.next(genResult.value)); <span class=\"comment\">// 如果不是promise，就可以直接递归下一次迭代了</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        handle(gen.next()); <span class=\"comment\">// 开始处理next迭代</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">myGenerator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"keyword\">yield</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">\"success\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data); <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> test = myAsync(myGenerator);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>到现在其实我们的核心功能handle函数就完成了，现在去调用next()方法，已经看到可以打印success了，但是，除了正常的promise，我们还要考虑下面的情况</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数A(正常情况);</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = &#123;</span><br><span class=\"line\">    then: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"then\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">123123</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> test0 = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> test1 = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">123</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> test2 = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">123</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> test4 = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">test0().then(<span class=\"built_in\">console</span>.log); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">test1().then(<span class=\"built_in\">console</span>.log); <span class=\"comment\">// 123</span></span><br><span class=\"line\">test2().then(<span class=\"built_in\">console</span>.log); <span class=\"comment\">// 123 undefined</span></span><br><span class=\"line\">test4().then(<span class=\"built_in\">console</span>.log); <span class=\"comment\">// then</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>也就是说在async接受到的函数不是generator函数的情况下：</p>\n</blockquote>\n<ol>\n<li>async函数默认返回一Promise.resolve(undefined)</li>\n<li>当async接受到的函数有返回值，并且返回值不是promise的情况下，async函数默认用promise包装这个返回结果</li>\n<li>当async接受到函数没有返回值，async会直接运行函数，并返回一个Promise.resolve(undefined)</li>\n<li>考虑到thenable这种promise的鸭子类型函数的特殊性，我尝试去返回了一个这种类型的对象，果然，发现then被执行了~</li>\n</ol>\n<h5 id=\"那么，我们来完善边界情况的处理\"><a href=\"#那么，我们来完善边界情况的处理\" class=\"headerlink\" title=\"那么，我们来完善边界情况的处理\"></a>那么，我们来完善边界情况的处理</h5><blockquote>\n<p>所以现在的代码变成</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数B(模拟情况);</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myAsync</span>(<span class=\"params\">myGenerator</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断接受到的参数不是一个generator函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        <span class=\"built_in\">Object</span>.prototype.toString.call(myGenerator) !==</span><br><span class=\"line\">        <span class=\"string\">\"[object GeneratorFunction]\"</span></span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果是一个普通函数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (</span><br><span class=\"line\">            <span class=\"built_in\">Object</span>.prototype.toString.call(myGenerator) === <span class=\"string\">\"[object Function]\"</span></span><br><span class=\"line\">        ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 默认返回一个promise对象</span></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">const</span> data = myGenerator();</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> resolve(data); <span class=\"comment\">// 尝试运行这个函数，并把结果resolve出去</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> reject(err); <span class=\"comment\">// 失败处理</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果参数含有then这个方法--thenable 鸭子类型</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> myGenerator.then === <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 运行这个对象的then函数，并resolve出去</span></span><br><span class=\"line\">                    <span class=\"keyword\">const</span> data = myGenerator.then();</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> resolve(data);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> reject(err); <span class=\"comment\">// 失败处理</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 剩下的情况，统一resolve出去给的参数</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(myGenerator);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> gen = myGenerator(); <span class=\"comment\">// 生成迭代器</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> handle = <span class=\"function\"><span class=\"params\">genResult</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (genResult.done) <span class=\"keyword\">return</span>; <span class=\"comment\">// 如果迭代器结束了，直接返回；</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> genResult.value <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span> <span class=\"comment\">// 判断当前迭代器的value是否是Promise的实例</span></span><br><span class=\"line\">            ? genResult.value</span><br><span class=\"line\">                  .then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> handle(gen.next(data))) <span class=\"comment\">// 如果是，则等待异步完成后继续递归下一个迭代，并把resolve后的data带过去</span></span><br><span class=\"line\">                  .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> gen.throw(err)) <span class=\"comment\">// gen.throw 可以抛出一个允许外层去catch的err</span></span><br><span class=\"line\">            : handle(gen.next(genResult.value)); <span class=\"comment\">// 如果不是promise，就可以直接递归下一次迭代了</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        handle(gen.next()); <span class=\"comment\">// 开始处理next迭代</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = &#123;</span><br><span class=\"line\">    then: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"then\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">123123</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> test0 = myAsync(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> test1 = myAsync(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">123</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> test2 = myAsync(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">123</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> test4 = myAsync(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">test0.then(<span class=\"built_in\">console</span>.log); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">test1.then(<span class=\"built_in\">console</span>.log); <span class=\"comment\">// 123</span></span><br><span class=\"line\">test2.then(<span class=\"built_in\">console</span>.log); <span class=\"comment\">// 123 undefined</span></span><br><span class=\"line\">test4.then(<span class=\"built_in\">console</span>.log); <span class=\"comment\">// then</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>有的同学可能会说，咦，es6的 async 函数返回的那个是个函数，需要执行才能拿到结果，比如test0 应该是 test() 返回的是promise，但是模拟出来的怎么直接就拿到返回的promise了，其实很简单，你只要再用一个函数(比如myAsyncWrapper)把这个函数包装一下就ok~</p>\n</blockquote>\n<h5 id=\"到此，我们的模拟就结束了，现在让我们来尽情的实验一下\"><a href=\"#到此，我们的模拟就结束了，现在让我们来尽情的实验一下\" class=\"headerlink\" title=\"到此，我们的模拟就结束了，现在让我们来尽情的实验一下~\"></a>到此，我们的模拟就结束了，现在让我们来尽情的实验一下~</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myAsync(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> data1 = <span class=\"keyword\">yield</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">            setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">                res(<span class=\"number\">1234</span>);</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"step 1\"</span>); <span class=\"comment\">// step 1</span></span><br><span class=\"line\">            &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(data1); <span class=\"comment\">// step 1 打印1s后 打印 123</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> data2 = <span class=\"keyword\">yield</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">            setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">                res(<span class=\"number\">12342</span>);</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"step 2\"</span>); <span class=\"comment\">// step 2</span></span><br><span class=\"line\">            &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(data2); <span class=\"comment\">// step 2 打印1s后打印 12342</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">888</span>, err); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>完美啊有么有，再来试试reject</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myAsync(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"number\">123</span>);</span><br><span class=\"line\">        <span class=\"keyword\">const</span> data1 = <span class=\"keyword\">yield</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">            setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">                res(<span class=\"number\">1234</span>);</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"step 1\"</span>);</span><br><span class=\"line\">            &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(data1);</span><br><span class=\"line\">        <span class=\"keyword\">const</span> data2 = <span class=\"keyword\">yield</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">            setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">                res(<span class=\"number\">12342</span>);</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"step 2\"</span>);</span><br><span class=\"line\">            &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(data2);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">888</span>, err); <span class=\"comment\">// 888 123</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>没问题直接输出了888 123</p>\n</blockquote>\n<h5 id=\"完美结束\"><a href=\"#完美结束\" class=\"headerlink\" title=\"完美结束\"></a>完美结束</h5><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h5 id=\"1-async-函数是generator-promise的语法糖，可能es6具体的实现一定有一定的优化和处理，但是个人觉得理论上偏差不大\"><a href=\"#1-async-函数是generator-promise的语法糖，可能es6具体的实现一定有一定的优化和处理，但是个人觉得理论上偏差不大\" class=\"headerlink\" title=\"1.async 函数是generator+promise的语法糖，可能es6具体的实现一定有一定的优化和处理，但是个人觉得理论上偏差不大\"></a>1.async 函数是generator+promise的语法糖，可能es6具体的实现一定有一定的优化和处理，但是个人觉得理论上偏差不大</h5><h5 id=\"2-想要用的得心应手还是建议去猜测和理解一下实现的原理\"><a href=\"#2-想要用的得心应手还是建议去猜测和理解一下实现的原理\" class=\"headerlink\" title=\"2.想要用的得心应手还是建议去猜测和理解一下实现的原理\"></a>2.想要用的得心应手还是建议去猜测和理解一下实现的原理</h5><h4 id=\"3-特此声明：以上内容基本都是模拟实现，并不是真实的实现原理，没有写测试，因此可能有漏洞的存在，欢迎各位大佬批评指正，希望大家能够共同进步\"><a href=\"#3-特此声明：以上内容基本都是模拟实现，并不是真实的实现原理，没有写测试，因此可能有漏洞的存在，欢迎各位大佬批评指正，希望大家能够共同进步\" class=\"headerlink\" title=\"3.特此声明：以上内容基本都是模拟实现，并不是真实的实现原理，没有写测试，因此可能有漏洞的存在，欢迎各位大佬批评指正，希望大家能够共同进步~\"></a>3.特此声明：以上内容基本都是模拟实现，并不是真实的实现原理，没有写测试，因此可能有漏洞的存在，欢迎各位大佬批评指正，希望大家能够共同进步~</h4><blockquote>\n<p><a href=\"https://github.com/jinggk/FrontEndCode/blob/master/async/demo.js\" target=\"_blank\" rel=\"noopener\">代码demo传送门</a></p>\n</blockquote>\n"},{"title":"网页布局相关","date":"2019-05-22T05:25:20.000Z","_content":"\n### 分辨率\n1. **屏幕分辨率**\n    指的是屏幕由多少个像素点构成的，比如 375 * 667 就是说有375 * 667个像素点组成\n2. **图像分辨率**\n    指的是一张图片由多少个像素点构成，表示图片分别在垂直和水平上所具有的像素点数，当然对于同一大小尺寸的图片，像素点越多，分辨率越高，图片越清晰\n3. **PPI(Pixel Per Inch)：每英寸包括的像素数**\n    这个数字越大，说明同一尺寸的像素点越多，当然越清晰了\n4. **DPI(Dot Per Inch)：即每英寸包括的点数**\n    这个主要形容打印机的墨点数的，如果放到设备上，和楼上的意义是一样的\n5. **DP 设备独立像素**\n    新的智能设备的出现，追求更精细的像素，比如宽度都是375，老版手机可能真的是用375个像素去渲染，但是为了更精细的体验，新的智能设备会采用750个物理像素去渲染，但是显示出来的大小最终是一样的，我们用一种单位来告诉不同分辨率的设备，在当前设备上，一个元素究竟应该使用多少个像素，这个单位就是DP\n6. **DPR device pixel ratio物理像素和设备独立像素比**\n    对于iphone6 7 8这样的机器，DPR=3 因此当你构建一个宽高都是200px的div时，实际渲染的物理像素点是600 * 600\n    获取： web中可以通过 window.devicePixelRatio来帮助我们获取设备的dpr\n    设置：css的媒体查询可以解决 @media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2){ }\n\n### 视口\n1. **布局视口**\n    布局视口(layout viewport)：当我们以百分比来指定一个元素的大小时，它的计算值是由这个元素的包含块计算而来的。当这个元素是最顶级的元素时，它就是基于布局视口来计算的。默认情况下，布局视口就等于当前浏览器的窗口大小，不包括滚动条，borders和margins等\n    我们可以通过调用document.documentElement.clientWidth / clientHeight来获取布局视口大小\n2. **视觉视口**\n    视觉视口(visual viewport)：用户通过屏幕真实看到的区域。默认情况下也是浏览器的窗口大小，但是会包含上滚动条，borders等这些内容的宽高\n    我们可以通过调用window.innerWidth / innerHeight来获取视觉视口大小。\n3. **理想视口**\n    当页面的缩放比例是100%的时候，css像素就是设备独立像素，理想视口大小就是视觉视口的大小\n4. **meta viewport**\n    常用：\n    ```javascript\n    <meta name=\"viewport\" content=\"width=device-width; initial-scale=1; maximum-scale=1; minimum-scale=1; user-scalable=no;”>\n    ```\n    具体详解：\n        width：正整数或者device-width 定义的是布局视口的宽度\n        height：同上，定义的是布局视口的高度\n        Inital-scale：定义的是页面的初始缩放比例\n        Minimum-scale：定义最小的缩放比例，必须小于或者等于最大缩放比例\n        maximum-scale：定义最大缩放比例\n        User-scalable： bool值，表示用户是否可以手动缩放页面，默认是yes，设置为no，即可禁止缩放\n","source":"_posts/网页布局相关.md","raw":"---\ntitle: 网页布局相关\ndate: 2019-05-22 13:25:20\ntags:\n---\n\n### 分辨率\n1. **屏幕分辨率**\n    指的是屏幕由多少个像素点构成的，比如 375 * 667 就是说有375 * 667个像素点组成\n2. **图像分辨率**\n    指的是一张图片由多少个像素点构成，表示图片分别在垂直和水平上所具有的像素点数，当然对于同一大小尺寸的图片，像素点越多，分辨率越高，图片越清晰\n3. **PPI(Pixel Per Inch)：每英寸包括的像素数**\n    这个数字越大，说明同一尺寸的像素点越多，当然越清晰了\n4. **DPI(Dot Per Inch)：即每英寸包括的点数**\n    这个主要形容打印机的墨点数的，如果放到设备上，和楼上的意义是一样的\n5. **DP 设备独立像素**\n    新的智能设备的出现，追求更精细的像素，比如宽度都是375，老版手机可能真的是用375个像素去渲染，但是为了更精细的体验，新的智能设备会采用750个物理像素去渲染，但是显示出来的大小最终是一样的，我们用一种单位来告诉不同分辨率的设备，在当前设备上，一个元素究竟应该使用多少个像素，这个单位就是DP\n6. **DPR device pixel ratio物理像素和设备独立像素比**\n    对于iphone6 7 8这样的机器，DPR=3 因此当你构建一个宽高都是200px的div时，实际渲染的物理像素点是600 * 600\n    获取： web中可以通过 window.devicePixelRatio来帮助我们获取设备的dpr\n    设置：css的媒体查询可以解决 @media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2){ }\n\n### 视口\n1. **布局视口**\n    布局视口(layout viewport)：当我们以百分比来指定一个元素的大小时，它的计算值是由这个元素的包含块计算而来的。当这个元素是最顶级的元素时，它就是基于布局视口来计算的。默认情况下，布局视口就等于当前浏览器的窗口大小，不包括滚动条，borders和margins等\n    我们可以通过调用document.documentElement.clientWidth / clientHeight来获取布局视口大小\n2. **视觉视口**\n    视觉视口(visual viewport)：用户通过屏幕真实看到的区域。默认情况下也是浏览器的窗口大小，但是会包含上滚动条，borders等这些内容的宽高\n    我们可以通过调用window.innerWidth / innerHeight来获取视觉视口大小。\n3. **理想视口**\n    当页面的缩放比例是100%的时候，css像素就是设备独立像素，理想视口大小就是视觉视口的大小\n4. **meta viewport**\n    常用：\n    ```javascript\n    <meta name=\"viewport\" content=\"width=device-width; initial-scale=1; maximum-scale=1; minimum-scale=1; user-scalable=no;”>\n    ```\n    具体详解：\n        width：正整数或者device-width 定义的是布局视口的宽度\n        height：同上，定义的是布局视口的高度\n        Inital-scale：定义的是页面的初始缩放比例\n        Minimum-scale：定义最小的缩放比例，必须小于或者等于最大缩放比例\n        maximum-scale：定义最大缩放比例\n        User-scalable： bool值，表示用户是否可以手动缩放页面，默认是yes，设置为no，即可禁止缩放\n","slug":"网页布局相关","published":1,"updated":"2019-06-20T03:08:54.963Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx4afn55000aq67wzk5kefpi","content":"<h3 id=\"分辨率\"><a href=\"#分辨率\" class=\"headerlink\" title=\"分辨率\"></a>分辨率</h3><ol>\n<li><strong>屏幕分辨率</strong><br> 指的是屏幕由多少个像素点构成的，比如 375 * 667 就是说有375 * 667个像素点组成</li>\n<li><strong>图像分辨率</strong><br> 指的是一张图片由多少个像素点构成，表示图片分别在垂直和水平上所具有的像素点数，当然对于同一大小尺寸的图片，像素点越多，分辨率越高，图片越清晰</li>\n<li><strong>PPI(Pixel Per Inch)：每英寸包括的像素数</strong><br> 这个数字越大，说明同一尺寸的像素点越多，当然越清晰了</li>\n<li><strong>DPI(Dot Per Inch)：即每英寸包括的点数</strong><br> 这个主要形容打印机的墨点数的，如果放到设备上，和楼上的意义是一样的</li>\n<li><strong>DP 设备独立像素</strong><br> 新的智能设备的出现，追求更精细的像素，比如宽度都是375，老版手机可能真的是用375个像素去渲染，但是为了更精细的体验，新的智能设备会采用750个物理像素去渲染，但是显示出来的大小最终是一样的，我们用一种单位来告诉不同分辨率的设备，在当前设备上，一个元素究竟应该使用多少个像素，这个单位就是DP</li>\n<li><strong>DPR device pixel ratio物理像素和设备独立像素比</strong><br> 对于iphone6 7 8这样的机器，DPR=3 因此当你构建一个宽高都是200px的div时，实际渲染的物理像素点是600 * 600<br> 获取： web中可以通过 window.devicePixelRatio来帮助我们获取设备的dpr<br> 设置：css的媒体查询可以解决 @media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2){ }</li>\n</ol>\n<h3 id=\"视口\"><a href=\"#视口\" class=\"headerlink\" title=\"视口\"></a>视口</h3><ol>\n<li><p><strong>布局视口</strong><br> 布局视口(layout viewport)：当我们以百分比来指定一个元素的大小时，它的计算值是由这个元素的包含块计算而来的。当这个元素是最顶级的元素时，它就是基于布局视口来计算的。默认情况下，布局视口就等于当前浏览器的窗口大小，不包括滚动条，borders和margins等<br> 我们可以通过调用document.documentElement.clientWidth / clientHeight来获取布局视口大小</p>\n</li>\n<li><p><strong>视觉视口</strong><br> 视觉视口(visual viewport)：用户通过屏幕真实看到的区域。默认情况下也是浏览器的窗口大小，但是会包含上滚动条，borders等这些内容的宽高<br> 我们可以通过调用window.innerWidth / innerHeight来获取视觉视口大小。</p>\n</li>\n<li><p><strong>理想视口</strong><br> 当页面的缩放比例是100%的时候，css像素就是设备独立像素，理想视口大小就是视觉视口的大小</p>\n</li>\n<li><p><strong>meta viewport</strong><br> 常用：</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=<span class=\"string\">\"viewport\"</span> content=<span class=\"string\">\"width=device-width; initial-scale=1; maximum-scale=1; minimum-scale=1; user-scalable=no;”&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p> 具体详解：</p>\n<pre><code>width：正整数或者device-width 定义的是布局视口的宽度\nheight：同上，定义的是布局视口的高度\nInital-scale：定义的是页面的初始缩放比例\nMinimum-scale：定义最小的缩放比例，必须小于或者等于最大缩放比例\nmaximum-scale：定义最大缩放比例\nUser-scalable： bool值，表示用户是否可以手动缩放页面，默认是yes，设置为no，即可禁止缩放</code></pre></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"分辨率\"><a href=\"#分辨率\" class=\"headerlink\" title=\"分辨率\"></a>分辨率</h3><ol>\n<li><strong>屏幕分辨率</strong><br> 指的是屏幕由多少个像素点构成的，比如 375 * 667 就是说有375 * 667个像素点组成</li>\n<li><strong>图像分辨率</strong><br> 指的是一张图片由多少个像素点构成，表示图片分别在垂直和水平上所具有的像素点数，当然对于同一大小尺寸的图片，像素点越多，分辨率越高，图片越清晰</li>\n<li><strong>PPI(Pixel Per Inch)：每英寸包括的像素数</strong><br> 这个数字越大，说明同一尺寸的像素点越多，当然越清晰了</li>\n<li><strong>DPI(Dot Per Inch)：即每英寸包括的点数</strong><br> 这个主要形容打印机的墨点数的，如果放到设备上，和楼上的意义是一样的</li>\n<li><strong>DP 设备独立像素</strong><br> 新的智能设备的出现，追求更精细的像素，比如宽度都是375，老版手机可能真的是用375个像素去渲染，但是为了更精细的体验，新的智能设备会采用750个物理像素去渲染，但是显示出来的大小最终是一样的，我们用一种单位来告诉不同分辨率的设备，在当前设备上，一个元素究竟应该使用多少个像素，这个单位就是DP</li>\n<li><strong>DPR device pixel ratio物理像素和设备独立像素比</strong><br> 对于iphone6 7 8这样的机器，DPR=3 因此当你构建一个宽高都是200px的div时，实际渲染的物理像素点是600 * 600<br> 获取： web中可以通过 window.devicePixelRatio来帮助我们获取设备的dpr<br> 设置：css的媒体查询可以解决 @media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2){ }</li>\n</ol>\n<h3 id=\"视口\"><a href=\"#视口\" class=\"headerlink\" title=\"视口\"></a>视口</h3><ol>\n<li><p><strong>布局视口</strong><br> 布局视口(layout viewport)：当我们以百分比来指定一个元素的大小时，它的计算值是由这个元素的包含块计算而来的。当这个元素是最顶级的元素时，它就是基于布局视口来计算的。默认情况下，布局视口就等于当前浏览器的窗口大小，不包括滚动条，borders和margins等<br> 我们可以通过调用document.documentElement.clientWidth / clientHeight来获取布局视口大小</p>\n</li>\n<li><p><strong>视觉视口</strong><br> 视觉视口(visual viewport)：用户通过屏幕真实看到的区域。默认情况下也是浏览器的窗口大小，但是会包含上滚动条，borders等这些内容的宽高<br> 我们可以通过调用window.innerWidth / innerHeight来获取视觉视口大小。</p>\n</li>\n<li><p><strong>理想视口</strong><br> 当页面的缩放比例是100%的时候，css像素就是设备独立像素，理想视口大小就是视觉视口的大小</p>\n</li>\n<li><p><strong>meta viewport</strong><br> 常用：</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=<span class=\"string\">\"viewport\"</span> content=<span class=\"string\">\"width=device-width; initial-scale=1; maximum-scale=1; minimum-scale=1; user-scalable=no;”&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p> 具体详解：</p>\n<pre><code>width：正整数或者device-width 定义的是布局视口的宽度\nheight：同上，定义的是布局视口的高度\nInital-scale：定义的是页面的初始缩放比例\nMinimum-scale：定义最小的缩放比例，必须小于或者等于最大缩放比例\nmaximum-scale：定义最大缩放比例\nUser-scalable： bool值，表示用户是否可以手动缩放页面，默认是yes，设置为no，即可禁止缩放</code></pre></li>\n</ol>\n"},{"title":"防抖和节流","date":"2018-12-11T09:01:50.000Z","_content":"\n# js 中的防抖和节流函数\n\n#### 函数节流\n节流其实就是说类似于同一个事件在被多次连续触发时，如果上一次的没有完成，就禁止当前的跑进去，挡在门外\n\n#### 函数防抖\n防抖其实是说，每一次进去的时候，都重置状态，相当于把上一次的取消\n\n### 看到很多大佬讲的防抖和节流都比较深入，其实我觉得可以简单点，看2个函数自己感觉下？\n\n##### 防抖\n```javascript\nconst debounce = (fn, delay) => {\n    let timer;\n    return function(...args) {\n        // 如果有定时任务，直接重置\n        if (timer) {\n            clearTimeout(timer);\n        }\n        timer = setTimeout(() => {\n            fn.apply(this, args);\n        }, delay);\n    };\n};\n```\n\n测试\n\n```javascript\nconst test = () => {\n    console.log(123123);\n};\n\nsetInterval(debounce(test, 3000), 1000); // 无输出，因为1s会导致timeout被重置\nsetInterval(debounce(test, 3000), 4000); // 第一次等7s后输出，之后4s输出一次\n```\n其实很好理解，防抖就是说在我超时的时间内如果跑进来，就会直接重置我的超时，因此如果执行的间隔小与我超时的时间设置，就会导致永远不输出\n\n#### 函数节流\n##### 节流\n```javascript\nconst throttle = (fn, gapTime) => {\n    let timer;\n    return function(...args) {\n        // 如果有定时任务，就等待执行掉再处理\n        if (timer) return;\n        timer = setTimeout(() => {\n            fn.apply(this, args);\n            clearTimeout(timer);\n            timer = null;\n        }, gapTime);\n    };\n};\n```\n\n测试\n\n```javascript\nconst test = () => {\n    console.log(123123);\n};\n\nsetInterval(throttle(test, 3000), 1000); // 到第4s的时候输出，之后每3s输出一次\nsetInterval(throttle(test, 3000), 5000); // 到第8s的时候输出，之后每5s输出一次\n```\n\n节流是什么意思呢，就是说无论你外界怎么调用，必须要满足我的超时，在我超时等待的这段时间内不允许任何打断，因此当我超时是3s但是每隔1s就调用一次的时候，会被直接return，到我定时的任务执行之后，才允许下一个进来，但是如果我的时间间隔比你的执行时间要短，那么我一定会按照你的频率来执行，比如第2种情况会每隔5s输出一次\n\n\n#### 结论：\n防抖就是在一定时间内触发的话直接重置我要执行的任务，从头开始。\n节流就是说一定时间内，我的任务必须消化掉才能继续接收后面的，这中间的就直接丢弃了。\n\n\n#### 适用场景\n\n防抖：\n\n假设在某一个页面的input框上我们要做一个智能提示，就是说用户输入内容后，要去发请求获取提示的内容，当用户输入过快的时候，我们是没必要有变动就去发请求，这样对服务器的冲击太大了，这个时候可以利用防抖来做一个1s的delay，因为1s内如果用户连续输入也没必要去发请求。\n\n节流：\n\n假设有一个落地页，页面上有一个购买按钮，点这个按钮我们会发起支付请求，如果什么都不做的情况下用户会连续猛击20次的话，我们会发20个请求到后台去生成订单，这明显是不合理的，这个时候如果用节流函数来做，用户在1s内连续按多少次都没用，我们必须消化掉点击的第一次才能继续处理后面的流程。\n\n\n\n\n","source":"_posts/防抖和节流.md","raw":"---\ntitle: 防抖和节流\ndate: 2018-12-11 17:01:50\ntags: javascript\n---\n\n# js 中的防抖和节流函数\n\n#### 函数节流\n节流其实就是说类似于同一个事件在被多次连续触发时，如果上一次的没有完成，就禁止当前的跑进去，挡在门外\n\n#### 函数防抖\n防抖其实是说，每一次进去的时候，都重置状态，相当于把上一次的取消\n\n### 看到很多大佬讲的防抖和节流都比较深入，其实我觉得可以简单点，看2个函数自己感觉下？\n\n##### 防抖\n```javascript\nconst debounce = (fn, delay) => {\n    let timer;\n    return function(...args) {\n        // 如果有定时任务，直接重置\n        if (timer) {\n            clearTimeout(timer);\n        }\n        timer = setTimeout(() => {\n            fn.apply(this, args);\n        }, delay);\n    };\n};\n```\n\n测试\n\n```javascript\nconst test = () => {\n    console.log(123123);\n};\n\nsetInterval(debounce(test, 3000), 1000); // 无输出，因为1s会导致timeout被重置\nsetInterval(debounce(test, 3000), 4000); // 第一次等7s后输出，之后4s输出一次\n```\n其实很好理解，防抖就是说在我超时的时间内如果跑进来，就会直接重置我的超时，因此如果执行的间隔小与我超时的时间设置，就会导致永远不输出\n\n#### 函数节流\n##### 节流\n```javascript\nconst throttle = (fn, gapTime) => {\n    let timer;\n    return function(...args) {\n        // 如果有定时任务，就等待执行掉再处理\n        if (timer) return;\n        timer = setTimeout(() => {\n            fn.apply(this, args);\n            clearTimeout(timer);\n            timer = null;\n        }, gapTime);\n    };\n};\n```\n\n测试\n\n```javascript\nconst test = () => {\n    console.log(123123);\n};\n\nsetInterval(throttle(test, 3000), 1000); // 到第4s的时候输出，之后每3s输出一次\nsetInterval(throttle(test, 3000), 5000); // 到第8s的时候输出，之后每5s输出一次\n```\n\n节流是什么意思呢，就是说无论你外界怎么调用，必须要满足我的超时，在我超时等待的这段时间内不允许任何打断，因此当我超时是3s但是每隔1s就调用一次的时候，会被直接return，到我定时的任务执行之后，才允许下一个进来，但是如果我的时间间隔比你的执行时间要短，那么我一定会按照你的频率来执行，比如第2种情况会每隔5s输出一次\n\n\n#### 结论：\n防抖就是在一定时间内触发的话直接重置我要执行的任务，从头开始。\n节流就是说一定时间内，我的任务必须消化掉才能继续接收后面的，这中间的就直接丢弃了。\n\n\n#### 适用场景\n\n防抖：\n\n假设在某一个页面的input框上我们要做一个智能提示，就是说用户输入内容后，要去发请求获取提示的内容，当用户输入过快的时候，我们是没必要有变动就去发请求，这样对服务器的冲击太大了，这个时候可以利用防抖来做一个1s的delay，因为1s内如果用户连续输入也没必要去发请求。\n\n节流：\n\n假设有一个落地页，页面上有一个购买按钮，点这个按钮我们会发起支付请求，如果什么都不做的情况下用户会连续猛击20次的话，我们会发20个请求到后台去生成订单，这明显是不合理的，这个时候如果用节流函数来做，用户在1s内连续按多少次都没用，我们必须消化掉点击的第一次才能继续处理后面的流程。\n\n\n\n\n","slug":"防抖和节流","published":1,"updated":"2019-06-20T03:03:01.608Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx4afn57000cq67wwkslq589","content":"<h1 id=\"js-中的防抖和节流函数\"><a href=\"#js-中的防抖和节流函数\" class=\"headerlink\" title=\"js 中的防抖和节流函数\"></a>js 中的防抖和节流函数</h1><h4 id=\"函数节流\"><a href=\"#函数节流\" class=\"headerlink\" title=\"函数节流\"></a>函数节流</h4><p>节流其实就是说类似于同一个事件在被多次连续触发时，如果上一次的没有完成，就禁止当前的跑进去，挡在门外</p>\n<h4 id=\"函数防抖\"><a href=\"#函数防抖\" class=\"headerlink\" title=\"函数防抖\"></a>函数防抖</h4><p>防抖其实是说，每一次进去的时候，都重置状态，相当于把上一次的取消</p>\n<h3 id=\"看到很多大佬讲的防抖和节流都比较深入，其实我觉得可以简单点，看2个函数自己感觉下？\"><a href=\"#看到很多大佬讲的防抖和节流都比较深入，其实我觉得可以简单点，看2个函数自己感觉下？\" class=\"headerlink\" title=\"看到很多大佬讲的防抖和节流都比较深入，其实我觉得可以简单点，看2个函数自己感觉下？\"></a>看到很多大佬讲的防抖和节流都比较深入，其实我觉得可以简单点，看2个函数自己感觉下？</h3><h5 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a>防抖</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> debounce = <span class=\"function\">(<span class=\"params\">fn, delay</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timer;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果有定时任务，直接重置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timer) &#123;</span><br><span class=\"line\">            clearTimeout(timer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        timer = setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            fn.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">        &#125;, delay);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>测试</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> test = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">123123</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(debounce(test, <span class=\"number\">3000</span>), <span class=\"number\">1000</span>); <span class=\"comment\">// 无输出，因为1s会导致timeout被重置</span></span><br><span class=\"line\">setInterval(debounce(test, <span class=\"number\">3000</span>), <span class=\"number\">4000</span>); <span class=\"comment\">// 第一次等7s后输出，之后4s输出一次</span></span><br></pre></td></tr></table></figure>\n\n<p>其实很好理解，防抖就是说在我超时的时间内如果跑进来，就会直接重置我的超时，因此如果执行的间隔小与我超时的时间设置，就会导致永远不输出</p>\n<h4 id=\"函数节流-1\"><a href=\"#函数节流-1\" class=\"headerlink\" title=\"函数节流\"></a>函数节流</h4><h5 id=\"节流\"><a href=\"#节流\" class=\"headerlink\" title=\"节流\"></a>节流</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> throttle = <span class=\"function\">(<span class=\"params\">fn, gapTime</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timer;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果有定时任务，就等待执行掉再处理</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timer) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        timer = setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            fn.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">            clearTimeout(timer);</span><br><span class=\"line\">            timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;, gapTime);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>测试</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> test = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">123123</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(throttle(test, <span class=\"number\">3000</span>), <span class=\"number\">1000</span>); <span class=\"comment\">// 到第4s的时候输出，之后每3s输出一次</span></span><br><span class=\"line\">setInterval(throttle(test, <span class=\"number\">3000</span>), <span class=\"number\">5000</span>); <span class=\"comment\">// 到第8s的时候输出，之后每5s输出一次</span></span><br></pre></td></tr></table></figure>\n\n<p>节流是什么意思呢，就是说无论你外界怎么调用，必须要满足我的超时，在我超时等待的这段时间内不允许任何打断，因此当我超时是3s但是每隔1s就调用一次的时候，会被直接return，到我定时的任务执行之后，才允许下一个进来，但是如果我的时间间隔比你的执行时间要短，那么我一定会按照你的频率来执行，比如第2种情况会每隔5s输出一次</p>\n<h4 id=\"结论：\"><a href=\"#结论：\" class=\"headerlink\" title=\"结论：\"></a>结论：</h4><p>防抖就是在一定时间内触发的话直接重置我要执行的任务，从头开始。<br>节流就是说一定时间内，我的任务必须消化掉才能继续接收后面的，这中间的就直接丢弃了。</p>\n<h4 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h4><p>防抖：</p>\n<p>假设在某一个页面的input框上我们要做一个智能提示，就是说用户输入内容后，要去发请求获取提示的内容，当用户输入过快的时候，我们是没必要有变动就去发请求，这样对服务器的冲击太大了，这个时候可以利用防抖来做一个1s的delay，因为1s内如果用户连续输入也没必要去发请求。</p>\n<p>节流：</p>\n<p>假设有一个落地页，页面上有一个购买按钮，点这个按钮我们会发起支付请求，如果什么都不做的情况下用户会连续猛击20次的话，我们会发20个请求到后台去生成订单，这明显是不合理的，这个时候如果用节流函数来做，用户在1s内连续按多少次都没用，我们必须消化掉点击的第一次才能继续处理后面的流程。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"js-中的防抖和节流函数\"><a href=\"#js-中的防抖和节流函数\" class=\"headerlink\" title=\"js 中的防抖和节流函数\"></a>js 中的防抖和节流函数</h1><h4 id=\"函数节流\"><a href=\"#函数节流\" class=\"headerlink\" title=\"函数节流\"></a>函数节流</h4><p>节流其实就是说类似于同一个事件在被多次连续触发时，如果上一次的没有完成，就禁止当前的跑进去，挡在门外</p>\n<h4 id=\"函数防抖\"><a href=\"#函数防抖\" class=\"headerlink\" title=\"函数防抖\"></a>函数防抖</h4><p>防抖其实是说，每一次进去的时候，都重置状态，相当于把上一次的取消</p>\n<h3 id=\"看到很多大佬讲的防抖和节流都比较深入，其实我觉得可以简单点，看2个函数自己感觉下？\"><a href=\"#看到很多大佬讲的防抖和节流都比较深入，其实我觉得可以简单点，看2个函数自己感觉下？\" class=\"headerlink\" title=\"看到很多大佬讲的防抖和节流都比较深入，其实我觉得可以简单点，看2个函数自己感觉下？\"></a>看到很多大佬讲的防抖和节流都比较深入，其实我觉得可以简单点，看2个函数自己感觉下？</h3><h5 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a>防抖</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> debounce = <span class=\"function\">(<span class=\"params\">fn, delay</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timer;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果有定时任务，直接重置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timer) &#123;</span><br><span class=\"line\">            clearTimeout(timer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        timer = setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            fn.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">        &#125;, delay);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>测试</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> test = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">123123</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(debounce(test, <span class=\"number\">3000</span>), <span class=\"number\">1000</span>); <span class=\"comment\">// 无输出，因为1s会导致timeout被重置</span></span><br><span class=\"line\">setInterval(debounce(test, <span class=\"number\">3000</span>), <span class=\"number\">4000</span>); <span class=\"comment\">// 第一次等7s后输出，之后4s输出一次</span></span><br></pre></td></tr></table></figure>\n\n<p>其实很好理解，防抖就是说在我超时的时间内如果跑进来，就会直接重置我的超时，因此如果执行的间隔小与我超时的时间设置，就会导致永远不输出</p>\n<h4 id=\"函数节流-1\"><a href=\"#函数节流-1\" class=\"headerlink\" title=\"函数节流\"></a>函数节流</h4><h5 id=\"节流\"><a href=\"#节流\" class=\"headerlink\" title=\"节流\"></a>节流</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> throttle = <span class=\"function\">(<span class=\"params\">fn, gapTime</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timer;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果有定时任务，就等待执行掉再处理</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timer) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        timer = setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            fn.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">            clearTimeout(timer);</span><br><span class=\"line\">            timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;, gapTime);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>测试</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> test = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">123123</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(throttle(test, <span class=\"number\">3000</span>), <span class=\"number\">1000</span>); <span class=\"comment\">// 到第4s的时候输出，之后每3s输出一次</span></span><br><span class=\"line\">setInterval(throttle(test, <span class=\"number\">3000</span>), <span class=\"number\">5000</span>); <span class=\"comment\">// 到第8s的时候输出，之后每5s输出一次</span></span><br></pre></td></tr></table></figure>\n\n<p>节流是什么意思呢，就是说无论你外界怎么调用，必须要满足我的超时，在我超时等待的这段时间内不允许任何打断，因此当我超时是3s但是每隔1s就调用一次的时候，会被直接return，到我定时的任务执行之后，才允许下一个进来，但是如果我的时间间隔比你的执行时间要短，那么我一定会按照你的频率来执行，比如第2种情况会每隔5s输出一次</p>\n<h4 id=\"结论：\"><a href=\"#结论：\" class=\"headerlink\" title=\"结论：\"></a>结论：</h4><p>防抖就是在一定时间内触发的话直接重置我要执行的任务，从头开始。<br>节流就是说一定时间内，我的任务必须消化掉才能继续接收后面的，这中间的就直接丢弃了。</p>\n<h4 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h4><p>防抖：</p>\n<p>假设在某一个页面的input框上我们要做一个智能提示，就是说用户输入内容后，要去发请求获取提示的内容，当用户输入过快的时候，我们是没必要有变动就去发请求，这样对服务器的冲击太大了，这个时候可以利用防抖来做一个1s的delay，因为1s内如果用户连续输入也没必要去发请求。</p>\n<p>节流：</p>\n<p>假设有一个落地页，页面上有一个购买按钮，点这个按钮我们会发起支付请求，如果什么都不做的情况下用户会连续猛击20次的话，我们会发20个请求到后台去生成订单，这明显是不合理的，这个时候如果用节流函数来做，用户在1s内连续按多少次都没用，我们必须消化掉点击的第一次才能继续处理后面的流程。</p>\n"},{"title":"随笔","date":"2019-01-21T03:03:41.000Z","_content":"\n##### 1.写好代码的前提是想清楚自己的计划\n\n##### 2.不要急着写代码，先把流程理清楚，花2天想清楚，花一天就能写好代码，上来就写上2天代码，回头重构不一定能搞定，说不好就得重写\n\n##### 3.不要滥用注释，但是要用好注释\n\n##### 4.注释过多说明代码的可读性差，但是关键的地方还是需要加注释的，不要让2天后的自己看不懂2天前的代码\n\n##### 5.基础很重要，前端门槛低，入门简单上升难，很多人平时不积累，到面试的时候临时抱佛脚，这种的3年之外的大有人在，3年是个分水岭，如果你这个时候不行，基本上很少有人会肯定你的之后\n\n```javascript\n[1,2,3].map(parseInt) //?\n```\n\n##### 6.前端东西多，内容杂，所以不妨省下地铁上看那些乱七八糟的时间去看看一些技术的文档，每天看看，找时间试试，慢慢的就会质变\n\n##### 7.面试永远不要说你在上家公司的时候学不到东西，没有氛围，如果你有能力，为什么你不带带节奏，最次你要有点自己的东西能够证明你自己\n\n##### 8.如果你在比较开放的公司，有什么想法就大胆的说大胆的做，不要畏手畏脚，前提是想好你这个东西带来的效益以及拿出你的方案(公司很重要)\n\n##### 9.做人永远比做事重要，虽然是程序猿，怎么样和产品友好的相处，怎么样和领导相处都很重要，如果你连人都做不好，你的领导是不会看重你的能力的，因为团队比你一个人重要性更大\n\n##### 10.多关注走势，跟得上潮流，但是不要盲目的焦虑，软件界的东西虽然很多但是很多理念都是互通的，要能够举一反三\n\n##### 11.实战促进技术，能把看到的用到工作中才是能力\n","source":"_posts/随笔.md","raw":"---\ntitle: 随笔\ndate: 2019-01-21 11:03:41\ntags: 成长\n---\n\n##### 1.写好代码的前提是想清楚自己的计划\n\n##### 2.不要急着写代码，先把流程理清楚，花2天想清楚，花一天就能写好代码，上来就写上2天代码，回头重构不一定能搞定，说不好就得重写\n\n##### 3.不要滥用注释，但是要用好注释\n\n##### 4.注释过多说明代码的可读性差，但是关键的地方还是需要加注释的，不要让2天后的自己看不懂2天前的代码\n\n##### 5.基础很重要，前端门槛低，入门简单上升难，很多人平时不积累，到面试的时候临时抱佛脚，这种的3年之外的大有人在，3年是个分水岭，如果你这个时候不行，基本上很少有人会肯定你的之后\n\n```javascript\n[1,2,3].map(parseInt) //?\n```\n\n##### 6.前端东西多，内容杂，所以不妨省下地铁上看那些乱七八糟的时间去看看一些技术的文档，每天看看，找时间试试，慢慢的就会质变\n\n##### 7.面试永远不要说你在上家公司的时候学不到东西，没有氛围，如果你有能力，为什么你不带带节奏，最次你要有点自己的东西能够证明你自己\n\n##### 8.如果你在比较开放的公司，有什么想法就大胆的说大胆的做，不要畏手畏脚，前提是想好你这个东西带来的效益以及拿出你的方案(公司很重要)\n\n##### 9.做人永远比做事重要，虽然是程序猿，怎么样和产品友好的相处，怎么样和领导相处都很重要，如果你连人都做不好，你的领导是不会看重你的能力的，因为团队比你一个人重要性更大\n\n##### 10.多关注走势，跟得上潮流，但是不要盲目的焦虑，软件界的东西虽然很多但是很多理念都是互通的，要能够举一反三\n\n##### 11.实战促进技术，能把看到的用到工作中才是能力\n","slug":"随笔","published":1,"updated":"2019-06-20T03:04:30.744Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx4afn59000eq67wnolzg24t","content":"<h5 id=\"1-写好代码的前提是想清楚自己的计划\"><a href=\"#1-写好代码的前提是想清楚自己的计划\" class=\"headerlink\" title=\"1.写好代码的前提是想清楚自己的计划\"></a>1.写好代码的前提是想清楚自己的计划</h5><h5 id=\"2-不要急着写代码，先把流程理清楚，花2天想清楚，花一天就能写好代码，上来就写上2天代码，回头重构不一定能搞定，说不好就得重写\"><a href=\"#2-不要急着写代码，先把流程理清楚，花2天想清楚，花一天就能写好代码，上来就写上2天代码，回头重构不一定能搞定，说不好就得重写\" class=\"headerlink\" title=\"2.不要急着写代码，先把流程理清楚，花2天想清楚，花一天就能写好代码，上来就写上2天代码，回头重构不一定能搞定，说不好就得重写\"></a>2.不要急着写代码，先把流程理清楚，花2天想清楚，花一天就能写好代码，上来就写上2天代码，回头重构不一定能搞定，说不好就得重写</h5><h5 id=\"3-不要滥用注释，但是要用好注释\"><a href=\"#3-不要滥用注释，但是要用好注释\" class=\"headerlink\" title=\"3.不要滥用注释，但是要用好注释\"></a>3.不要滥用注释，但是要用好注释</h5><h5 id=\"4-注释过多说明代码的可读性差，但是关键的地方还是需要加注释的，不要让2天后的自己看不懂2天前的代码\"><a href=\"#4-注释过多说明代码的可读性差，但是关键的地方还是需要加注释的，不要让2天后的自己看不懂2天前的代码\" class=\"headerlink\" title=\"4.注释过多说明代码的可读性差，但是关键的地方还是需要加注释的，不要让2天后的自己看不懂2天前的代码\"></a>4.注释过多说明代码的可读性差，但是关键的地方还是需要加注释的，不要让2天后的自己看不懂2天前的代码</h5><h5 id=\"5-基础很重要，前端门槛低，入门简单上升难，很多人平时不积累，到面试的时候临时抱佛脚，这种的3年之外的大有人在，3年是个分水岭，如果你这个时候不行，基本上很少有人会肯定你的之后\"><a href=\"#5-基础很重要，前端门槛低，入门简单上升难，很多人平时不积累，到面试的时候临时抱佛脚，这种的3年之外的大有人在，3年是个分水岭，如果你这个时候不行，基本上很少有人会肯定你的之后\" class=\"headerlink\" title=\"5.基础很重要，前端门槛低，入门简单上升难，很多人平时不积累，到面试的时候临时抱佛脚，这种的3年之外的大有人在，3年是个分水岭，如果你这个时候不行，基本上很少有人会肯定你的之后\"></a>5.基础很重要，前端门槛低，入门简单上升难，很多人平时不积累，到面试的时候临时抱佛脚，这种的3年之外的大有人在，3年是个分水岭，如果你这个时候不行，基本上很少有人会肯定你的之后</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>].map(<span class=\"built_in\">parseInt</span>) <span class=\"comment\">//?</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"6-前端东西多，内容杂，所以不妨省下地铁上看那些乱七八糟的时间去看看一些技术的文档，每天看看，找时间试试，慢慢的就会质变\"><a href=\"#6-前端东西多，内容杂，所以不妨省下地铁上看那些乱七八糟的时间去看看一些技术的文档，每天看看，找时间试试，慢慢的就会质变\" class=\"headerlink\" title=\"6.前端东西多，内容杂，所以不妨省下地铁上看那些乱七八糟的时间去看看一些技术的文档，每天看看，找时间试试，慢慢的就会质变\"></a>6.前端东西多，内容杂，所以不妨省下地铁上看那些乱七八糟的时间去看看一些技术的文档，每天看看，找时间试试，慢慢的就会质变</h5><h5 id=\"7-面试永远不要说你在上家公司的时候学不到东西，没有氛围，如果你有能力，为什么你不带带节奏，最次你要有点自己的东西能够证明你自己\"><a href=\"#7-面试永远不要说你在上家公司的时候学不到东西，没有氛围，如果你有能力，为什么你不带带节奏，最次你要有点自己的东西能够证明你自己\" class=\"headerlink\" title=\"7.面试永远不要说你在上家公司的时候学不到东西，没有氛围，如果你有能力，为什么你不带带节奏，最次你要有点自己的东西能够证明你自己\"></a>7.面试永远不要说你在上家公司的时候学不到东西，没有氛围，如果你有能力，为什么你不带带节奏，最次你要有点自己的东西能够证明你自己</h5><h5 id=\"8-如果你在比较开放的公司，有什么想法就大胆的说大胆的做，不要畏手畏脚，前提是想好你这个东西带来的效益以及拿出你的方案-公司很重要\"><a href=\"#8-如果你在比较开放的公司，有什么想法就大胆的说大胆的做，不要畏手畏脚，前提是想好你这个东西带来的效益以及拿出你的方案-公司很重要\" class=\"headerlink\" title=\"8.如果你在比较开放的公司，有什么想法就大胆的说大胆的做，不要畏手畏脚，前提是想好你这个东西带来的效益以及拿出你的方案(公司很重要)\"></a>8.如果你在比较开放的公司，有什么想法就大胆的说大胆的做，不要畏手畏脚，前提是想好你这个东西带来的效益以及拿出你的方案(公司很重要)</h5><h5 id=\"9-做人永远比做事重要，虽然是程序猿，怎么样和产品友好的相处，怎么样和领导相处都很重要，如果你连人都做不好，你的领导是不会看重你的能力的，因为团队比你一个人重要性更大\"><a href=\"#9-做人永远比做事重要，虽然是程序猿，怎么样和产品友好的相处，怎么样和领导相处都很重要，如果你连人都做不好，你的领导是不会看重你的能力的，因为团队比你一个人重要性更大\" class=\"headerlink\" title=\"9.做人永远比做事重要，虽然是程序猿，怎么样和产品友好的相处，怎么样和领导相处都很重要，如果你连人都做不好，你的领导是不会看重你的能力的，因为团队比你一个人重要性更大\"></a>9.做人永远比做事重要，虽然是程序猿，怎么样和产品友好的相处，怎么样和领导相处都很重要，如果你连人都做不好，你的领导是不会看重你的能力的，因为团队比你一个人重要性更大</h5><h5 id=\"10-多关注走势，跟得上潮流，但是不要盲目的焦虑，软件界的东西虽然很多但是很多理念都是互通的，要能够举一反三\"><a href=\"#10-多关注走势，跟得上潮流，但是不要盲目的焦虑，软件界的东西虽然很多但是很多理念都是互通的，要能够举一反三\" class=\"headerlink\" title=\"10.多关注走势，跟得上潮流，但是不要盲目的焦虑，软件界的东西虽然很多但是很多理念都是互通的，要能够举一反三\"></a>10.多关注走势，跟得上潮流，但是不要盲目的焦虑，软件界的东西虽然很多但是很多理念都是互通的，要能够举一反三</h5><h5 id=\"11-实战促进技术，能把看到的用到工作中才是能力\"><a href=\"#11-实战促进技术，能把看到的用到工作中才是能力\" class=\"headerlink\" title=\"11.实战促进技术，能把看到的用到工作中才是能力\"></a>11.实战促进技术，能把看到的用到工作中才是能力</h5>","site":{"data":{}},"excerpt":"","more":"<h5 id=\"1-写好代码的前提是想清楚自己的计划\"><a href=\"#1-写好代码的前提是想清楚自己的计划\" class=\"headerlink\" title=\"1.写好代码的前提是想清楚自己的计划\"></a>1.写好代码的前提是想清楚自己的计划</h5><h5 id=\"2-不要急着写代码，先把流程理清楚，花2天想清楚，花一天就能写好代码，上来就写上2天代码，回头重构不一定能搞定，说不好就得重写\"><a href=\"#2-不要急着写代码，先把流程理清楚，花2天想清楚，花一天就能写好代码，上来就写上2天代码，回头重构不一定能搞定，说不好就得重写\" class=\"headerlink\" title=\"2.不要急着写代码，先把流程理清楚，花2天想清楚，花一天就能写好代码，上来就写上2天代码，回头重构不一定能搞定，说不好就得重写\"></a>2.不要急着写代码，先把流程理清楚，花2天想清楚，花一天就能写好代码，上来就写上2天代码，回头重构不一定能搞定，说不好就得重写</h5><h5 id=\"3-不要滥用注释，但是要用好注释\"><a href=\"#3-不要滥用注释，但是要用好注释\" class=\"headerlink\" title=\"3.不要滥用注释，但是要用好注释\"></a>3.不要滥用注释，但是要用好注释</h5><h5 id=\"4-注释过多说明代码的可读性差，但是关键的地方还是需要加注释的，不要让2天后的自己看不懂2天前的代码\"><a href=\"#4-注释过多说明代码的可读性差，但是关键的地方还是需要加注释的，不要让2天后的自己看不懂2天前的代码\" class=\"headerlink\" title=\"4.注释过多说明代码的可读性差，但是关键的地方还是需要加注释的，不要让2天后的自己看不懂2天前的代码\"></a>4.注释过多说明代码的可读性差，但是关键的地方还是需要加注释的，不要让2天后的自己看不懂2天前的代码</h5><h5 id=\"5-基础很重要，前端门槛低，入门简单上升难，很多人平时不积累，到面试的时候临时抱佛脚，这种的3年之外的大有人在，3年是个分水岭，如果你这个时候不行，基本上很少有人会肯定你的之后\"><a href=\"#5-基础很重要，前端门槛低，入门简单上升难，很多人平时不积累，到面试的时候临时抱佛脚，这种的3年之外的大有人在，3年是个分水岭，如果你这个时候不行，基本上很少有人会肯定你的之后\" class=\"headerlink\" title=\"5.基础很重要，前端门槛低，入门简单上升难，很多人平时不积累，到面试的时候临时抱佛脚，这种的3年之外的大有人在，3年是个分水岭，如果你这个时候不行，基本上很少有人会肯定你的之后\"></a>5.基础很重要，前端门槛低，入门简单上升难，很多人平时不积累，到面试的时候临时抱佛脚，这种的3年之外的大有人在，3年是个分水岭，如果你这个时候不行，基本上很少有人会肯定你的之后</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>].map(<span class=\"built_in\">parseInt</span>) <span class=\"comment\">//?</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"6-前端东西多，内容杂，所以不妨省下地铁上看那些乱七八糟的时间去看看一些技术的文档，每天看看，找时间试试，慢慢的就会质变\"><a href=\"#6-前端东西多，内容杂，所以不妨省下地铁上看那些乱七八糟的时间去看看一些技术的文档，每天看看，找时间试试，慢慢的就会质变\" class=\"headerlink\" title=\"6.前端东西多，内容杂，所以不妨省下地铁上看那些乱七八糟的时间去看看一些技术的文档，每天看看，找时间试试，慢慢的就会质变\"></a>6.前端东西多，内容杂，所以不妨省下地铁上看那些乱七八糟的时间去看看一些技术的文档，每天看看，找时间试试，慢慢的就会质变</h5><h5 id=\"7-面试永远不要说你在上家公司的时候学不到东西，没有氛围，如果你有能力，为什么你不带带节奏，最次你要有点自己的东西能够证明你自己\"><a href=\"#7-面试永远不要说你在上家公司的时候学不到东西，没有氛围，如果你有能力，为什么你不带带节奏，最次你要有点自己的东西能够证明你自己\" class=\"headerlink\" title=\"7.面试永远不要说你在上家公司的时候学不到东西，没有氛围，如果你有能力，为什么你不带带节奏，最次你要有点自己的东西能够证明你自己\"></a>7.面试永远不要说你在上家公司的时候学不到东西，没有氛围，如果你有能力，为什么你不带带节奏，最次你要有点自己的东西能够证明你自己</h5><h5 id=\"8-如果你在比较开放的公司，有什么想法就大胆的说大胆的做，不要畏手畏脚，前提是想好你这个东西带来的效益以及拿出你的方案-公司很重要\"><a href=\"#8-如果你在比较开放的公司，有什么想法就大胆的说大胆的做，不要畏手畏脚，前提是想好你这个东西带来的效益以及拿出你的方案-公司很重要\" class=\"headerlink\" title=\"8.如果你在比较开放的公司，有什么想法就大胆的说大胆的做，不要畏手畏脚，前提是想好你这个东西带来的效益以及拿出你的方案(公司很重要)\"></a>8.如果你在比较开放的公司，有什么想法就大胆的说大胆的做，不要畏手畏脚，前提是想好你这个东西带来的效益以及拿出你的方案(公司很重要)</h5><h5 id=\"9-做人永远比做事重要，虽然是程序猿，怎么样和产品友好的相处，怎么样和领导相处都很重要，如果你连人都做不好，你的领导是不会看重你的能力的，因为团队比你一个人重要性更大\"><a href=\"#9-做人永远比做事重要，虽然是程序猿，怎么样和产品友好的相处，怎么样和领导相处都很重要，如果你连人都做不好，你的领导是不会看重你的能力的，因为团队比你一个人重要性更大\" class=\"headerlink\" title=\"9.做人永远比做事重要，虽然是程序猿，怎么样和产品友好的相处，怎么样和领导相处都很重要，如果你连人都做不好，你的领导是不会看重你的能力的，因为团队比你一个人重要性更大\"></a>9.做人永远比做事重要，虽然是程序猿，怎么样和产品友好的相处，怎么样和领导相处都很重要，如果你连人都做不好，你的领导是不会看重你的能力的，因为团队比你一个人重要性更大</h5><h5 id=\"10-多关注走势，跟得上潮流，但是不要盲目的焦虑，软件界的东西虽然很多但是很多理念都是互通的，要能够举一反三\"><a href=\"#10-多关注走势，跟得上潮流，但是不要盲目的焦虑，软件界的东西虽然很多但是很多理念都是互通的，要能够举一反三\" class=\"headerlink\" title=\"10.多关注走势，跟得上潮流，但是不要盲目的焦虑，软件界的东西虽然很多但是很多理念都是互通的，要能够举一反三\"></a>10.多关注走势，跟得上潮流，但是不要盲目的焦虑，软件界的东西虽然很多但是很多理念都是互通的，要能够举一反三</h5><h5 id=\"11-实战促进技术，能把看到的用到工作中才是能力\"><a href=\"#11-实战促进技术，能把看到的用到工作中才是能力\" class=\"headerlink\" title=\"11.实战促进技术，能把看到的用到工作中才是能力\"></a>11.实战促进技术，能把看到的用到工作中才是能力</h5>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjx4afn3x0000q67wum63c4sx","tag_id":"cjx4afn4m0003q67wifvj202f","_id":"cjx4afn530008q67w29zrlf25"},{"post_id":"cjx4afn4g0002q67wfgt9ywur","tag_id":"cjx4afn520007q67wxxi3sl0p","_id":"cjx4afn59000dq67w5ljn1utv"},{"post_id":"cjx4afn57000cq67wwkslq589","tag_id":"cjx4afn56000bq67wwn3wle6j","_id":"cjx4afn5b000gq67wnwdx27nn"},{"post_id":"cjx4afn4r0004q67wla83xqr7","tag_id":"cjx4afn56000bq67wwn3wle6j","_id":"cjx4afn5e000hq67wjn49od9t"},{"post_id":"cjx4afn4w0005q67wvt5ksm9w","tag_id":"cjx4afn56000bq67wwn3wle6j","_id":"cjx4afn5g000jq67wl7lmbnrq"},{"post_id":"cjx4afn510006q67widw3q4xa","tag_id":"cjx4afn520007q67wxxi3sl0p","_id":"cjx4afn5h000lq67w3zy21a4a"},{"post_id":"cjx4afn530009q67wexz62bkd","tag_id":"cjx4afn56000bq67wwn3wle6j","_id":"cjx4afn5i000nq67w3w77haus"},{"post_id":"cjx4afn59000eq67wnolzg24t","tag_id":"cjx4afn5h000mq67ws5smstio","_id":"cjx4afn5i000oq67wuy4eyn0a"}],"Tag":[{"name":"http","_id":"cjx4afn4m0003q67wifvj202f"},{"name":"网络","_id":"cjx4afn520007q67wxxi3sl0p"},{"name":"javascript","_id":"cjx4afn56000bq67wwn3wle6j"},{"name":"成长","_id":"cjx4afn5h000mq67ws5smstio"}]}}